<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>winterfell30</title>
  <icon>https://www.gravatar.com/avatar/6c81d3499e5e453a0b9b6dd77a68b668</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.winterfell30.com/"/>
  <updated>2020-04-11T10:43:20.197Z</updated>
  <id>http://www.winterfell30.com/</id>
  
  <author>
    <name>Winterfell30</name>
    <email>1225825277@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一次离职</title>
    <link href="http://www.winterfell30.com/2020/04/10/new-start/"/>
    <id>http://www.winterfell30.com/2020/04/10/new-start/</id>
    <published>2020-04-10T06:55:18.000Z</published>
    <updated>2020-04-11T10:43:20.197Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;博客的上次更新还停留在17年，更新最后一篇的时候还在忙活秋招，百度的一面面试官面试时看到了我写在简历上的博客，看到我的最新一篇博客里提到了brpc还问了我一些brpc相关的问题。如今两年半过去了，当时的一面面试官trans到了别的部门，brpc的作者戈大神离职去了B站，我马上也要离开百度和我的第一份正式工作告别了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;百度真的是一个很适合应届生的地方，内部资料丰富，人才梯度健全，注重技术积累和分享。我们组同事平均年龄大一点，基本都是80后，我本身上学比较早再加上本科毕业，提到年龄时同事们都表现出了不小的震惊（和同情）。因为比组内平均值大约小10的年龄，能感觉到在工作中同事对我特殊的照顾，在分配工作时会考虑我的强度和压力，并且同事们没有因为年龄问题而轻视我，在我提出意见时会认真的思考分析，在我提出架构优化上的想法时能让我放手去做，刚毕业时能和这些同事一起工作感觉很幸运，从他们身上学到了很多东西。当初选择百度offer还有一个原因是妹子也选择百度，这两年和妹子的聊天一直在百度Hi上，不知道的看到我们一周都聊不了几次的微信肯定会以为我们是假情侣吧2333。妹子的办公区一直在科技园，我最初是在奎科，后面搬到了大厦，这两年多的时间里，每周会抽出两天的中午坐10分钟的班车到科技园一起吃饭，科技园的饭比较丰富，大厦和奎科的饭就挺一般。百度内部设施也比较全，大厦和科技园都有健身房、篮球场、舞蹈室这些，间歇性的有几段时间我会在晚上下班后到健身房锻炼一会，现在<del>受疫情影响</del>也挺久没练了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;为什么毕业一年多就匆匆离开了呢，其实这两年一直挺迷茫的，产品本身已经比较稳定，大家都是在找事情做的状态，做的很多事情在我感觉起来并不是什么强需求，自我价值全靠自己骗自己。在项目比较忙的可以不去想这些安心把事情做好，手上没有事情的时候又会陷入迷茫，对自己未来的方向毫无头绪，甚至对自己下个季度要做什么都一无所知，我已经将组内的所有小方向都尝试过一遍，依然没有找到一个可以让我深入持久的做下去的方向，所以我决定离职了（以上提到的只是我们组的情况，公司内成百上千个组差别很大）。在和经理说离职理由的时候我说是因为想去做一些底层的东西，因为我不好意思说是觉得现在的工作没意思，实际上随着工作时间增长我对纯infra研发已经没有了什么执念，offer中也有相关的机会，纠结后还是选择了放弃，感觉业务架构的抽象和设计更能给我带来实实在在的技术挑战和开阔的视野，infra还是留作心底的白月光自己私下慢慢研究吧。所以我现在的期望就是能够去一个迅速发展的项目，和项目一起成长，在还年轻的时候，体验一把被飞速上涨的流量和层出不穷的需求追在屁股后面推动的感觉。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;一直没有写博客的原因主要有两个，一是平时的积累和踩的坑都直接写在内部wiki上了，二是确实没有沉淀下来什么有点深度的东西，学的东西都是零零散散，我也不想当复读机把网上到处都有的东西再说一遍。最近越来越感受到系统性学习的重要性，零散的学习带来的都是表面繁荣，用之前看到过的一句话描述就是：“学习一项技能就像滚雪球一样，它在滚的过程中会带起越来越多的雪，但如果放置不管它就会融化”。后续会更注意系统性，也会将自己的感悟和提炼更新在博客上。继续写博客还有一个原因，我觉得我现在总结精炼语言的能力越来越差，和人讲事情时总是急于表达，说一堆我眼中事情的关键点而不是串成一条清晰的线。。。以后要是成为一个啰啰嗦嗦说不清事情的人就太可怕了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我最近一直在想这段经历到底给我带来了什么，就是单纯的通过这两年时间完成了学校到工作的过渡期吗，我心中理想的职业发展曲线应该是每一段经历都能作为后面的铺垫，就像是一个有趣的游戏一定不会是每一关之间独立的，一定是随着游戏的深入玩家对游戏的理解和技能也逐步的深入。可是我现在依然没有想清楚这两年到底给我带来了什么，也许这就像小时候背的无聊课文一样，在未来的某些时刻才会感悟到吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="杂记" scheme="http://www.winterfell30.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于内存对齐</title>
    <link href="http://www.winterfell30.com/2017/10/09/memoryalignment/"/>
    <id>http://www.winterfell30.com/2017/10/09/memoryalignment/</id>
    <published>2017-10-09T08:10:33.000Z</published>
    <updated>2017-10-10T12:32:14.389Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>关于内存对齐的东西一直都了解的比较浅，在看内存管理的时候想到这个，去看了一些资料消除了一些误解。</p><p>很多人都知道内存对齐能够提高CPU取址效率，还有计算sizeof(struct)时的两个规则：1.每个数据的起始地址要是这个数据大小的整数倍，2.struct的大小是最大数据的整数倍。</p><p>CPU在读取总线的时候并非按照一个一个连着的地址而是分块，这个块的大小取决于CPU的型号（例如数据总线宽度为32位的就是按照4对齐），而后面要提到的#pragma pack(n)的方法改变的是编译器内存对齐的方式，并不是CPU的！！！</p><p>假设我们存一个int(假设4位)在0x00~0x03的地址位，CPU从00开始对齐，那么CPU读取的时候一次就可以读到整个int，假设这个int在0x01~0x04的位置，需要先读0x00~0x03然后取0x01~0x03的部分，再读0x04~0x07取0x04的部分，然后将两部分拼起来，比较影响效率。</p><p>然后如果你的struct本身是不对齐，比如最前面一个char，后面全是int，编译器一点都不处理（相当于在声明后面加<strong>attribute</strong>((packed))或者作用域前面加#pragma pack(1)）的话，对CPU读数据可以说是相当的不友好了，于是编译器会给第一个char后面填充3个无意义地址，让第一个int从0x04开始，按照对齐后的地址生成目标文件，再把这个目标文件交给CPU的时候，CPU读数据的效率就提高了很多。</p><p>然后这是编译器默认的对齐规则，我们可以使用#pragma pack改变编译器改变的对齐字节，用法不再多提，要注意的是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)          </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)      <span class="comment">//#progma pack(1)出栈，将对齐方式回退到之前</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#progma pack(1) </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#progma pack()         <span class="comment">//取消指定对齐，恢复到缺省值</span></span></span><br></pre></td></tr></table></figure><p>这两种方法上面的要好一点。</p><p>前两天看BRPC代码的时候看到用了很多__declspec(align(n))，这个可以精确控制用户自定义数据对齐，可以加在struct，union，class定义的前面，也可以直接加在变量声明的前面只控制这一个变量。<br>declspec的优先级要比#pragma pack高。</p><p>说了这么多，平时写代码的时候定义数据结构的时候应该无脑把大的数据往前放，然后可以根据数据类型自己规定#pragma pack(n)和__declspec(align(n))，在数据一个完整的字节都用不满时可以使用位域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="系统" scheme="http://www.winterfell30.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>优雅的Haskell快排实现</title>
    <link href="http://www.winterfell30.com/2017/04/22/quicksort-Haskell/"/>
    <id>http://www.winterfell30.com/2017/04/22/quicksort-Haskell/</id>
    <published>2017-04-22T07:53:56.000Z</published>
    <updated>2017-04-22T08:03:16.408Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>试着用Haskell写了一下快排，然后直接就能用了。。。测试了一下没什么问题<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quicksort [] = []</span><br><span class="line">quicksort (x : xs) = quicksort [<span class="keyword">a</span> | <span class="keyword">a</span> &lt;- xs, <span class="keyword">a</span> &lt;= x] ++ [x] ++ quicksort [<span class="keyword">a</span> | <span class="keyword">a</span> &lt;- xs, <span class="keyword">a</span> &gt; x]</span><br></pre></td></tr></table></figure></p><p>Haskell真的让递归变的很爽。不过出于清晰函数前面最好还是声明一下参数和返回类型<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quicksort <span class="comment">:: (Ord a) =&gt; [a] -&gt; [a]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Haskell" scheme="http://www.winterfell30.com/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>WebBench源码分析</title>
    <link href="http://www.winterfell30.com/2017/04/11/webbench-source/"/>
    <id>http://www.winterfell30.com/2017/04/11/webbench-source/</id>
    <published>2017-04-11T05:25:44.000Z</published>
    <updated>2017-04-11T07:33:13.143Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>之前测试HTTP服务器性能的时候用到这个，好奇是怎么实现的就去看了一下源码，源码很短只有五百多行，思路和想象中差不多比较简单。<br><a href="https://github.com/EZLippi/WebBench" target="_blank" rel="noopener">源码地址：https://github.com/EZLippi/WebBench</a><br>大体流程就是：<br><img src="http://7xno52.com1.z0.glb.clouddn.com/webbenchsource.png" alt></p><p>源码有两个c文件，主要函数：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">Socket(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">host</span>, <span class="params">int</span> <span class="params">clientPort</span>)</span>;</span><br></pre></td></tr></table></figure></p><p>接受主机和端口，创建连接，返回套接字的描述符，返回-1连接失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_request</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *url)</span></span>;</span><br></pre></td></tr></table></figure><p>接受url，创建http请求报文头</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bench</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>创建管道，创建子进程，判断进程是子进程还是父进程。<br>如果是子进程调用benchcore创建连接结果写进管道，如果是父进程读取管道结果统计一下输出出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">benchcore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* host,<span class="keyword">const</span> <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *request)</span></span>;</span><br></pre></td></tr></table></figure><p>创建HTTP连接测试，对HTTP请求进行测试。</p><p>整体思路比较清晰，一些细节的处理比较多。</p><p>源代码及注释：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">int</span> clientPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> inaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ad</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;ad, <span class="number">0</span>, <span class="keyword">sizeof</span>(ad));                    <span class="comment">//初始化地址</span></span><br><span class="line">    ad.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    inaddr = inet_addr(host);                      <span class="comment">//点分十进制的IP转换成一个长整数型数      </span></span><br><span class="line">    <span class="keyword">if</span> (inaddr != INADDR_NONE)                     <span class="comment">//如果是IP</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="keyword">sizeof</span>(inaddr));</span><br><span class="line">    <span class="keyword">else</span>                                           <span class="comment">//如果是域名先获取IP</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = gethostbyname(host);</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);</span><br><span class="line">    &#125;</span><br><span class="line">    ad.sin_port = htons(clientPort);               <span class="comment">//将16位数从主机字节顺序转换成网络字节顺序</span></span><br><span class="line">    </span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);        <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (struct sockaddr *)&amp;ad, <span class="keyword">sizeof</span>(ad)) &lt; <span class="number">0</span>)   <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> sock;                                   <span class="comment">//返回套接字描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> timerexpired=<span class="number">0</span>;                                          </span><br><span class="line"><span class="keyword">int</span> speed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> failed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytes=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* globals */</span></span><br><span class="line"><span class="keyword">int</span> http10=<span class="number">1</span>; <span class="comment">/* 0 - http/0.9, 1 - http/1.0, 2 - http/1.1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allow: GET, HEAD, OPTIONS, TRACE */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_GET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_HEAD 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_OPTIONS 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_TRACE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGRAM_VERSION <span class="meta-string">"1.5"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> method=METHOD_GET;             <span class="comment">//默认GET</span></span><br><span class="line"><span class="keyword">int</span> clients=<span class="number">1</span>;                     <span class="comment">//默认只有1个客户端</span></span><br><span class="line"><span class="keyword">int</span> force=<span class="number">0</span>;                       <span class="comment">//默认等待服务器请求</span></span><br><span class="line"><span class="keyword">int</span> force_reload=<span class="number">0</span>;                <span class="comment">//默认失败时不重新相应</span></span><br><span class="line"><span class="keyword">int</span> proxyport=<span class="number">80</span>;             </span><br><span class="line"><span class="keyword">char</span> *proxyhost=<span class="literal">NULL</span>;              <span class="comment">//默认不使用代理</span></span><br><span class="line"><span class="keyword">int</span> benchtime=<span class="number">30</span>;                  <span class="comment">//默认测试时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal */</span></span><br><span class="line"><span class="keyword">int</span> mypipe[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> host[MAXHOSTNAMELEN];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_SIZE 2048</span></span><br><span class="line"><span class="keyword">char</span> request[REQUEST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[]=</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    &#123;<span class="string">"force"</span>,no_argument,&amp;force,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"reload"</span>,no_argument,&amp;force_reload,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"time"</span>,required_argument,<span class="literal">NULL</span>,<span class="string">'t'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"help"</span>,no_argument,<span class="literal">NULL</span>,<span class="string">'?'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"http09"</span>,no_argument,<span class="literal">NULL</span>,<span class="string">'9'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"http10"</span>,no_argument,<span class="literal">NULL</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"http11"</span>,no_argument,<span class="literal">NULL</span>,<span class="string">'2'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"get"</span>,no_argument,&amp;method,METHOD_GET&#125;,</span><br><span class="line">    &#123;<span class="string">"head"</span>,no_argument,&amp;method,METHOD_HEAD&#125;,</span><br><span class="line">    &#123;<span class="string">"options"</span>,no_argument,&amp;method,METHOD_OPTIONS&#125;,</span><br><span class="line">    &#123;<span class="string">"trace"</span>,no_argument,&amp;method,METHOD_TRACE&#125;,</span><br><span class="line">    &#123;<span class="string">"version"</span>,no_argument,<span class="literal">NULL</span>,<span class="string">'V'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"proxy"</span>,required_argument,<span class="literal">NULL</span>,<span class="string">'p'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"clients"</span>,required_argument,<span class="literal">NULL</span>,<span class="string">'c'</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timerexpired=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//help信息</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">            <span class="string">"webbench [option]... URL\n"</span></span><br><span class="line">            <span class="string">"  -f|--force               Don't wait for reply from server.\n"</span></span><br><span class="line">            <span class="string">"  -r|--reload              Send reload request - Pragma: no-cache.\n"</span></span><br><span class="line">            <span class="string">"  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.\n"</span></span><br><span class="line">            <span class="string">"  -p|--proxy &lt;server:port&gt; Use proxy server for request.\n"</span></span><br><span class="line">            <span class="string">"  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.\n"</span></span><br><span class="line">            <span class="string">"  -9|--http09              Use HTTP/0.9 style requests.\n"</span></span><br><span class="line">            <span class="string">"  -1|--http10              Use HTTP/1.0 protocol.\n"</span></span><br><span class="line">            <span class="string">"  -2|--http11              Use HTTP/1.1 protocol.\n"</span></span><br><span class="line">            <span class="string">"  --get                    Use GET request method.\n"</span></span><br><span class="line">            <span class="string">"  --head                   Use HEAD request method.\n"</span></span><br><span class="line">            <span class="string">"  --options                Use OPTIONS request method.\n"</span></span><br><span class="line">            <span class="string">"  --trace                  Use TRACE request method.\n"</span></span><br><span class="line">            <span class="string">"  -?|-h|--help             This information.\n"</span></span><br><span class="line">            <span class="string">"  -V|--version             Display program version.\n"</span></span><br><span class="line">           );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> options_index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *tmp=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">1</span>)                 <span class="comment">//没有参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用getopt_long处理命令行，linux下可使用man 3 getlong_opt查看使用方法</span></span><br><span class="line">    <span class="keyword">while</span>((opt=getopt_long(argc,argv,<span class="string">"912Vfrt:p:c:?h"</span>,long_options,&amp;options_index))!=EOF )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="number">0</span> : <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'f'</span>: force=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>: force_reload=<span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'9'</span>: http10=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>: http10=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>: http10=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>: <span class="built_in">printf</span>(PROGRAM_VERSION<span class="string">"\n"</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>: benchtime=atoi(optarg);<span class="keyword">break</span>;     </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'p'</span>: </span><br><span class="line">            <span class="comment">/* proxy server parsing server:port */</span></span><br><span class="line">            tmp=<span class="built_in">strrchr</span>(optarg,<span class="string">':'</span>);</span><br><span class="line">            proxyhost=optarg;</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in option --proxy %s: Missing hostname.\n"</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg+<span class="built_in">strlen</span>(optarg)<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in option --proxy %s Port number is missing.\n"</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *tmp=<span class="string">'\0'</span>;</span><br><span class="line">            proxyport=atoi(tmp+<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>: usage();<span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'c'</span>: clients=atoi(optarg);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(optind==argc) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"webbench: Missing URL!\n"</span>);</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clients==<span class="number">0</span>) clients=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(benchtime==<span class="number">0</span>) benchtime=<span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Copyright */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Webbench - Simple Web Benchmark "</span>PROGRAM_VERSION<span class="string">"\n"</span></span><br><span class="line">            <span class="string">"Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n"</span></span><br><span class="line">            );</span><br><span class="line"> </span><br><span class="line">    build_request(argv[optind]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Runing info: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(clients==<span class="number">1</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1 client"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d clients"</span>,clients);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">", running %d sec"</span>, benchtime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(force) <span class="built_in">printf</span>(<span class="string">", early socket close"</span>);</span><br><span class="line">    <span class="keyword">if</span>(proxyhost!=<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">", via proxy server %s:%d"</span>,proxyhost,proxyport);</span><br><span class="line">    <span class="keyword">if</span>(force_reload) <span class="built_in">printf</span>(<span class="string">", forcing reload"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">".\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bench();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_request</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bzero(host,MAXHOSTNAMELEN);</span></span><br><span class="line">    <span class="comment">//bzero(request,REQUEST_SIZE);</span></span><br><span class="line">    <span class="built_in">memset</span>(host,<span class="number">0</span>,MAXHOSTNAMELEN);</span><br><span class="line">    <span class="built_in">memset</span>(request,<span class="number">0</span>,REQUEST_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span> &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;           <span class="comment">//使用了缓存和代理，HTTP/0.9不行</span></span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_HEAD &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_OPTIONS &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_TRACE &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(method)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> METHOD_GET: <span class="built_in">strcpy</span>(request,<span class="string">"GET"</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_HEAD: <span class="built_in">strcpy</span>(request,<span class="string">"HEAD"</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_OPTIONS: <span class="built_in">strcpy</span>(request,<span class="string">"OPTIONS"</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_TRACE: <span class="built_in">strcpy</span>(request,<span class="string">"TRACE"</span>);<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==<span class="built_in">strstr</span>(url,<span class="string">"://"</span>))                                         <span class="comment">//查找://是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n%s: is not a valid URL.\n"</span>,url);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(url)&gt;<span class="number">1500</span>)                                                <span class="comment">//链接长度小于1500</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"URL is too long.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>!=strncasecmp(<span class="string">"http://"</span>,url,<span class="number">7</span>))                                <span class="comment">//只支持HTTP地址</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nOnly HTTP protocol is directly supported, set --proxy for others.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* protocol/host delimiter */</span></span><br><span class="line">    i=<span class="built_in">strstr</span>(url,<span class="string">"://"</span>)-url+<span class="number">3</span>;                                          <span class="comment">//找到://之后的地址（主机名地址）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strchr</span>(url+i,<span class="string">'/'</span>)==<span class="literal">NULL</span>) &#123;          </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nInvalid URL syntax - hostname don't ends with '/'.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* get port from hostname */</span></span><br><span class="line">        <span class="keyword">if</span>(index(url+i,<span class="string">':'</span>)!=<span class="literal">NULL</span> &amp;&amp; index(url+i,<span class="string">':'</span>)&lt;index(url+i,<span class="string">'/'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strchr</span>(url+i,<span class="string">':'</span>)-url-i);                <span class="comment">//取出主机地址</span></span><br><span class="line">            <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strncpy</span>(tmp,index(url+i,<span class="string">':'</span>)+<span class="number">1</span>,<span class="built_in">strchr</span>(url+i,<span class="string">'/'</span>)-index(url+i,<span class="string">':'</span>)<span class="number">-1</span>);</span><br><span class="line">            proxyport=atoi(tmp);                                        <span class="comment">//端口   </span></span><br><span class="line">            <span class="keyword">if</span>(proxyport==<span class="number">0</span>) proxyport=<span class="number">80</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strcspn</span>(url+i,<span class="string">"/"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf("Host=%s\n",host);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request+<span class="built_in">strlen</span>(request),url+i+<span class="built_in">strcspn</span>(url+i,<span class="string">"/"</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf("ProxyHost=%s\nProxyPort=%d\n",proxyhost,proxyport);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request,url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(http10==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">" HTTP/1.0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (http10==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">" HTTP/1.1"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">"\r\n"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"User-Agent: WebBench "</span>PROGRAM_VERSION<span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span> &amp;&amp; http10&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"Host: "</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(request,host);</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"Pragma: no-cache\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"Connection: close\r\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* add empty line at end */</span></span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>) <span class="built_in">strcat</span>(request,<span class="string">"\r\n"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nRequest:\n%s\n"</span>,request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这一段自带注释比较多*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bench</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check avaibility of target server */</span></span><br><span class="line">    i=Socket(proxyhost==<span class="literal">NULL</span>?host:proxyhost,proxyport);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nConnect to server failed. Aborting benchmark.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* create pipe */</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(mypipe))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fork childs */</span></span><br><span class="line">    <span class="comment">//make childs faster的意思不是让子进程更快，是产生子进程更快</span></span><br><span class="line">    <span class="comment">//判断pid发现不是父进程就sleep把CPU让给父进程产生更多的子进程，make childs faster</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;clients;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt;= (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* child process or error*/</span></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">/* make childs faster */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid &lt; (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"problems forking worker no. %d\n"</span>,i);</span><br><span class="line">        perror(<span class="string">"fork failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* I am a child */</span></span><br><span class="line">        <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">            benchcore(host,proxyport,request);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            benchcore(proxyhost,proxyport,request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* write results to pipe */</span></span><br><span class="line">        f=fdopen(mypipe[<span class="number">1</span>],<span class="string">"w"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open pipe for writing failed."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* fprintf(stderr,"Child - %d %d\n",speed,failed); */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(f,<span class="string">"%d %d %d\n"</span>,speed,failed,bytes);</span><br><span class="line">        fclose(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        f=fdopen(mypipe[<span class="number">0</span>],<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open pipe for reading failed."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setvbuf(f,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        speed=<span class="number">0</span>;</span><br><span class="line">        failed=<span class="number">0</span>;</span><br><span class="line">        bytes=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pid=<span class="built_in">fscanf</span>(f,<span class="string">"%d %d %d"</span>,&amp;i,&amp;j,&amp;k);</span><br><span class="line">            <span class="keyword">if</span>(pid&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Some of our childrens died.\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            speed+=i;</span><br><span class="line">            failed+=j;</span><br><span class="line">            bytes+=k;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* fprintf(stderr,"*Knock* %d %d read=%d\n",speed,failed,pid); */</span></span><br><span class="line">            <span class="keyword">if</span>(--clients==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        fclose(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出测试结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n"</span>,</span><br><span class="line">            (<span class="keyword">int</span>)((speed+failed)/(benchtime/<span class="number">60.0f</span>)),</span><br><span class="line">            (<span class="keyword">int</span>)(bytes/(<span class="keyword">float</span>)benchtime),</span><br><span class="line">            speed,</span><br><span class="line">            failed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">benchcore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host,<span class="keyword">const</span> <span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">char</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rlen;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="keyword">int</span> s,i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup alarm signal handler */</span></span><br><span class="line">    sa.sa_handler=alarm_handler;                   <span class="comment">//定时器方法</span></span><br><span class="line">    sa.sa_flags=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(SIGALRM,&amp;sa,<span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    alarm(benchtime); <span class="comment">// after benchtime,then exit</span></span><br><span class="line"></span><br><span class="line">    rlen=<span class="built_in">strlen</span>(req);</span><br><span class="line">    nexttry:<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(timerexpired)                           <span class="comment">//定时器到的时候就会退出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(failed&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* fprintf(stderr,"Correcting failed by signal\n"); */</span></span><br><span class="line">                failed--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        s=Socket(host,port);                          </span><br><span class="line">        <span class="keyword">if</span>(s&lt;<span class="number">0</span>) &#123; failed++;<span class="keyword">continue</span>;&#125; </span><br><span class="line">        <span class="keyword">if</span>(rlen!=<span class="built_in">write</span>(s,req,rlen)) &#123;failed++;<span class="built_in">close</span>(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(http10==<span class="number">0</span>) <span class="keyword">if</span>(<span class="built_in">shutdown</span>(s,<span class="number">1</span>)) &#123; failed++;<span class="built_in">close</span>(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(force==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* read all available data from socket */</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(timerexpired) <span class="keyword">break</span>; </span><br><span class="line">                i=<span class="built_in">read</span>(s,buf,<span class="number">1500</span>);</span><br><span class="line">                <span class="comment">/* fprintf(stderr,"%d\n",i); */</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) </span><br><span class="line">                &#123; </span><br><span class="line">                    failed++;</span><br><span class="line">                    <span class="built_in">close</span>(s);</span><br><span class="line">                    <span class="keyword">goto</span> nexttry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> bytes+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">close</span>(s)) &#123;failed++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        speed++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="http://www.winterfell30.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="http://www.winterfell30.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>为什么很多服务器不允许使用POST请求静态服务</title>
    <link href="http://www.winterfell30.com/2017/02/24/postinstaticserver/"/>
    <id>http://www.winterfell30.com/2017/02/24/postinstaticserver/</id>
    <published>2017-02-24T10:10:50.000Z</published>
    <updated>2017-02-24T10:13:23.877Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>写POST请求的时候想到现在很多服务器(例如Apache、Nginx)不支持用POST请求静态服务，在请求的时候会返回method error，然后我就不理解为什么他们不实现静态服务的POST请求。<br>后来去找了一下相关资料大概是HTTP协议定义操作的时候GET是对资源的请求，POST含有更改服务器状态的意思，比较重要的一点是GET是安全并且幂等的，POST不是幂等的所以也是不安全的（这里所说的安全不是数据隐私方面的那个安全<br>所以用GET请求资源是网站设计良好的体现，静态服务器最低实际上只实现GET和HEAD就够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="http://www.winterfell30.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《C++ primer》chapter15 程序练习题</title>
    <link href="http://www.winterfell30.com/2017/02/10/cppprimerch15practice/"/>
    <id>http://www.winterfell30.com/2017/02/10/cppprimerch15practice/</id>
    <published>2017-02-10T03:19:35.000Z</published>
    <updated>2017-02-10T03:52:25.036Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>15.6<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> Quote&amp; item, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> ret = item.net_price(n);</span><br><span class="line">os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn()</span><br><span class="line">&lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">" total due: "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>15.11 15.15 15.16<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Quote() = <span class="keyword">default</span>;</span><br><span class="line">Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) :</span><br><span class="line">bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n * price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bookNo:"</span> &lt;&lt; bookNo</span><br><span class="line">&lt;&lt; <span class="string">",price:"</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">0.0</span>;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> qtr, <span class="keyword">double</span> disc) :</span><br><span class="line">Disc_quote(book, price, qtr, disc) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Bulk_quote::net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> cnt)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; quantity)</span><br><span class="line"><span class="keyword">return</span> quantity * discount * price + (cnt - quantity) * price;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> cnt * price * discount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bulk_quote::debug</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Quote::debug();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"quantity:"</span> &lt;&lt; quantity</span><br><span class="line">&lt;&lt; <span class="string">",discount:"</span> &lt;&lt; discount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>15.20<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> prot_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memfun</span><span class="params">(Base &amp;b)</span> </span>&#123; b = *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memfun</span><span class="params">(Base &amp;b)</span> </span>&#123; b = *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Prot_Derv</span> :</span> <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memfun</span><span class="params">(Base &amp;b)</span> </span>&#123; b = *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_Public</span> :</span> <span class="keyword">public</span> Pub_Derv</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memfun</span><span class="params">(Base &amp;b)</span> </span>&#123; b = *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_private</span> :</span> <span class="keyword">public</span> Priv_Derv</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//void memfun(Base &amp;b) &#123; b = *this; &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_protected</span> :</span> <span class="keyword">public</span> Prot_Derv</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memfun</span><span class="params">(Base &amp;b)</span> </span>&#123; b = *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15.18 d1,dd1可以被允许，其他不可以</span></span><br><span class="line"><span class="comment">15.19 Derived_from_private不合法，其他可以</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>15.23<br>去掉参数int即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fcn()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> <span class="keyword">override</span>  </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::fcn()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::f2()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::f2()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base bobj;</span><br><span class="line">D1 d1obj;</span><br><span class="line">D2 d2obj;</span><br><span class="line">Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn();</span><br><span class="line">bp2-&gt;fcn();</span><br><span class="line">bp3-&gt;fcn();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>15.25 15.26<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Quote&amp; lhs, <span class="keyword">const</span> Quote&amp; rhs);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Quote() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructing Quote\n"</span>; &#125;</span><br><span class="line">Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) :</span><br><span class="line">bookNo(book), price(sales_price) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Quote : constructor taking 2 parameters\n"</span>; </span><br><span class="line">&#125;</span><br><span class="line">Quote(<span class="keyword">const</span> Quote&amp; q) : bookNo(q.bookNo), price(q.price)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Quote : copy constructing\n"</span>; </span><br><span class="line">&#125;</span><br><span class="line">Quote(Quote&amp;&amp; q) <span class="keyword">noexcept</span> : bookNo(<span class="built_in">std</span>::<span class="built_in">move</span>(q.bookNo)), price(<span class="built_in">std</span>::<span class="built_in">move</span>(q.price))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Quote : move constructing\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span> != rhs)</span><br><span class="line">&#123;</span><br><span class="line">bookNo = rhs.bookNo;</span><br><span class="line">price = rhs.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Quote : copy = () \n"</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span> != rhs)</span><br><span class="line">&#123;</span><br><span class="line">bookNo = <span class="built_in">std</span>::<span class="built_in">move</span>(rhs.bookNo);</span><br><span class="line">price = <span class="built_in">std</span>::<span class="built_in">move</span>(rhs.price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Quote: move = () \n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n * price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bookNo:"</span> &lt;&lt; bookNo</span><br><span class="line">&lt;&lt; <span class="string">",price:"</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Quote()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing Quote\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">0.0</span>;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">operator</span>!=(<span class="keyword">const</span> Quote&amp; lhs, <span class="keyword">const</span> Quote&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.bookNo != rhs.bookNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Disc_quote&amp; lhs, <span class="keyword">const</span> Disc_quote&amp; rhs);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Disc_quote() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructing Disc_quote\n"</span>; &#125;</span><br><span class="line">Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> price,</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> qtr, <span class="keyword">double</span> disc) :</span><br><span class="line">Quote(book, price),</span><br><span class="line">quantity(qtr), discount(disc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Disc_quote : constructor taking 4 parameters.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Disc_quote(<span class="keyword">const</span> Disc_quote&amp; dq) :</span><br><span class="line">Quote(dq), quantity(dq.quantity), discount(dq.discount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Disc_quote : copy constructor.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Disc_quote(Disc_quote&amp;&amp; dq) <span class="keyword">noexcept</span> :</span><br><span class="line">Quote(<span class="built_in">std</span>::<span class="built_in">move</span>(dq)), quantity(<span class="built_in">std</span>::<span class="built_in">move</span>(dq.quantity)), discount(<span class="built_in">std</span>::<span class="built_in">move</span>(dq.discount))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Disc_quote : move constructor.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Disc_quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Disc_quote&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">Quote::<span class="keyword">operator</span>=(rhs);</span><br><span class="line"><span class="keyword">this</span>-&gt;quantity = rhs.quantity;</span><br><span class="line"><span class="keyword">this</span>-&gt;discount = rhs.discount;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Disc_quote : copy = ()\n"</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Disc_quote&amp; <span class="keyword">operator</span>=(Disc_quote&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span> != rhs)</span><br><span class="line">&#123;</span><br><span class="line">Quote::<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs));</span><br><span class="line"><span class="keyword">this</span>-&gt;quantity = <span class="built_in">std</span>::<span class="built_in">move</span>(rhs.quantity);</span><br><span class="line"><span class="keyword">this</span>-&gt;discount = <span class="built_in">std</span>::<span class="built_in">move</span>(rhs.discount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Disc_quote : move = ()\n"</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">~Disc_quote()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing Dis_quote\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">operator</span>!=(<span class="keyword">const</span> Disc_quote&amp; lhs, <span class="keyword">const</span> Disc_quote&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Quote(lhs) != Quote(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>15.27<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Bulk_quote() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructing Bulk_quote\n"</span>; &#125;</span><br><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> qtr, <span class="keyword">double</span> disc) :</span><br><span class="line">Disc_quote(book, price, qtr, disc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bulk_quote : constructor taking 4 parameters\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bulk_quote(<span class="keyword">const</span> Bulk_quote&amp; bq) : Disc_quote(bq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bulk_quote : copy constructor\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bulk_quote(Bulk_quote&amp;&amp; bq) <span class="keyword">noexcept</span> : Disc_quote(<span class="built_in">std</span>::<span class="built_in">move</span>(bq))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bulk_quote : move constructor\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bulk_quote&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Bulk_quote&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">Disc_quote::<span class="keyword">operator</span> =(rhs);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bulk_quote : copy =()\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bulk_quote&amp; <span class="keyword">operator</span> =(Bulk_quote&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">Disc_quote::<span class="keyword">operator</span> =(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bulk_quote : move =()\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">~Bulk_quote() <span class="keyword">override</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing Bulk_quote\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Bulk_quote::net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> cnt)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; quantity)</span><br><span class="line"><span class="keyword">return</span> quantity * discount * price + (cnt - quantity) * price;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> cnt * price * discount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bulk_quote::debug</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Quote::debug();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"quantity:"</span> &lt;&lt; quantity</span><br><span class="line">&lt;&lt; <span class="string">",discount:"</span> &lt;&lt; discount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>15.28 15.29<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Quote&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">v.push_back(Bulk_quote(<span class="string">"2333"</span>, i * <span class="number">10.1</span>, <span class="number">10</span>, <span class="number">0.3</span>));</span><br><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; b : v)</span><br><span class="line">total += b.net_price(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; pv;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">pv.push_back(<span class="built_in">std</span>::make_shared&lt;Bulk_quote&gt;(Bulk_quote(<span class="string">"2333"</span>, i * <span class="number">10.1</span>, <span class="number">10</span>, <span class="number">0.3</span>)));</span><br><span class="line"><span class="keyword">double</span> total_p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : pv)</span><br><span class="line">total_p += p-&gt;net_price(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; total_p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector添加派生类对象时派生类部分会被忽略，所以上面的没有折扣下面的有</span></span><br></pre></td></tr></table></figure></p><p>15.30<br>Quote.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Quote(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Quote(<span class="built_in">std</span>::<span class="built_in">move</span>(*<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Bulk_quote.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Bulk_quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Bulk_quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(<span class="built_in">std</span>::<span class="built_in">move</span>(*<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Basket.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(sale.clone()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(sale).clone()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(<span class="built_in">std</span>::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;&amp; lhs,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lhs-&gt;isbn() &lt; rhs-&gt;isbn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;, <span class="keyword">decltype</span>(compare)*&gt; items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Basket::total_receipt</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = items.cbegin(); iter != items.cend(); iter = items.upper_bound(*iter))</span><br><span class="line">    &#123;</span><br><span class="line">        sum += print_total(os, **iter, items.count(*iter));</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">"Total Sale: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文本查询程序暂时不写</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>一个Python3多线程爬题程序</title>
    <link href="http://www.winterfell30.com/2017/01/22/downloadproblem/"/>
    <id>http://www.winterfell30.com/2017/01/22/downloadproblem/</id>
    <published>2017-01-22T02:59:14.000Z</published>
    <updated>2017-01-22T04:50:50.153Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>之前打比赛的时候很想把OJ的题目打印下来上课看，LightOj有直接下载PDF的功能，写了个爬虫因为他的PDF地址一直打不开就搁置了（最后手动下载了一些，在纸上做的感觉还是不错的）<br>现在闲下来了就想搞一下这个，本来以为如果支持大部分OJ的话代码量会比较大,后来发现如果直接从VJ爬的话很多工作VJ都做完了只需要下载和转格式就可以了。<br>需要特殊处理的是UVA，因为UVA是直接找原来的PDF地址下载，其他的都是HTML转PDF。<br>大约在期末考试那两天写了个暴力的版本，放假之后就在想能不能多线程优化一下，想了一些方案，经过一些测试，最后决定使用producer-consumer模式，使用一个生产者线程爬取原题目HTML的网址，使用max个消费者线程下载。<br>然后重写了代码<del>（编程一晚上扯淡一星期）</del><br>经过测试，不管是HTML转换还是UVA的直接下载，多线程版本比普通版都能快2-3倍，考虑到网速才是瓶颈，感觉能优化的地方有限。<br>VJ使用get方法爬取，得到url队列<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDownlist</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">while</span> len(<span class="keyword">self</span>.idlist) &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">        url = <span class="string">"https://vjudge.net/problem/"</span> + <span class="keyword">self</span>.oj + <span class="string">"-"</span> + str(<span class="keyword">self</span>.idlist[<span class="number">0</span>])</span><br><span class="line">        response = requests.get(url, params = values, headers = headers).content</span><br><span class="line">        soup = BeautifulSoup(response, <span class="string">'html.parser'</span>)</span><br><span class="line">        originid = soup.find(attrs = &#123;<span class="string">'data-id'</span><span class="symbol">:True</span>&#125;).attrs[<span class="string">'data-id'</span>]</span><br><span class="line">        originurl = <span class="string">"https://vjudge.net/problem/description/"</span> + str(originid)</span><br><span class="line">        <span class="keyword">self</span>.urlQueue.put((originurl, <span class="keyword">self</span>.oj, <span class="keyword">self</span>.idlist[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">self</span>.idlist.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>开辟一个线程获取网址<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">self</span>.crawler = threading.<span class="keyword">Thread</span>(target=getDownlist())       </span><br><span class="line"><span class="built_in">self</span>.crawler.start()</span><br></pre></td></tr></table></figure></p><p>使用max个线程下载，判断调用哪个下载器，传入urlqueue<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (self.maxdownloader):<span class="type"></span></span><br><span class="line"><span class="type">    if self</span>.oj == <span class="string">'UVA'</span>:                                      <span class="type"></span>#uva直接下载PDF文件</span><br><span class="line">        <span class="keyword">new</span><span class="type">thread</span> = uvadownloader(self.urlQueue, self.path)</span><br><span class="line">        <span class="keyword">new</span><span class="type">thread</span>.start()</span><br><span class="line">        self.downlist.append(<span class="keyword">new</span><span class="type">thread</span>)</span><br><span class="line">    <span class="keyword">else</span>:                                                     <span class="type"></span>#其他的使用html转换pdf</span><br><span class="line">        <span class="keyword">new</span><span class="type">thread</span> = normalDownloader(self.urlQueue, self.path)</span><br><span class="line">        <span class="keyword">new</span><span class="type">thread</span>.start()</span><br><span class="line">        self.downlist.append(<span class="keyword">new</span><span class="type">thread</span>)</span><br></pre></td></tr></table></figure></p><p>通过每0.2s一次输出实现进度<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">while</span> len(<span class="keyword">self</span>.idlist) &gt; <span class="number">0</span> <span class="keyword">or</span> not <span class="keyword">self</span>.urlQueue.<span class="keyword">empty</span>() <span class="keyword">or</span> not flag:</span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> len(<span class="keyword">self</span>.idlist) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">'remain '</span> + str(len(<span class="keyword">self</span>.idlist)) + <span class="string">' urls to parse...'</span>)</span><br><span class="line">    <span class="keyword">if</span> not <span class="keyword">self</span>.urlQueue.<span class="keyword">empty</span>():</span><br><span class="line">        <span class="keyword">print</span>(str(<span class="keyword">self</span>.urlQueue.qsize()) + <span class="string">' problems ready to download...'</span>)</span><br><span class="line">    <span class="keyword">for</span> i in <span class="keyword">self</span>.downlist:</span><br><span class="line">        <span class="keyword">if</span> i.working:</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></p><p>下载器下载队列里的链接<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">uvadownloader</span>(<span class="title">threading</span>.<span class="title">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, q, path)</span></span><span class="symbol">:</span></span><br><span class="line">        threading.Thread.__init_<span class="number">_</span>(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">self</span>.q = q              <span class="comment">#下载队列</span></span><br><span class="line">        <span class="keyword">self</span>.path = path        <span class="comment">#当前地址</span></span><br><span class="line">        <span class="keyword">self</span>.filename = <span class="string">""</span>      <span class="comment">#当前下载的文件的文件名 方便输出进度</span></span><br><span class="line">        <span class="keyword">self</span>.sch = <span class="number">0</span>            <span class="comment">#进度</span></span><br><span class="line">        <span class="keyword">self</span>.working = False    <span class="comment">#是否正在工作</span></span><br><span class="line">        <span class="keyword">self</span>.exitflag = False   <span class="comment">#结束标志</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#def reporthook(blocks, blocksize, total):</span></span><br><span class="line">        <span class="comment">#    self.sch = min(50, int(blocks * blocksize / total * 50))  #计算进度</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(url, ojName, proId)</span></span><span class="symbol">:</span></span><br><span class="line">            response = requests.get(url, params=values, headers=headers).content</span><br><span class="line">            soup = BeautifulSoup(response, <span class="string">'html.parser'</span>)</span><br><span class="line">            match = re.compile(r<span class="string">'href\\u003d\\u0027(.+?)\\u0027\\u003e'</span>)</span><br><span class="line">            originurl = re.findall(match, response.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">self</span>.filename = ojName + str(proId) + <span class="string">'.pdf'</span></span><br><span class="line">            fileurl = <span class="keyword">self</span>.path + <span class="string">'/'</span> + <span class="keyword">self</span>.filename</span><br><span class="line">            <span class="symbol">try:</span></span><br><span class="line">                urllib.request.urlretrieve(originurl[<span class="number">0</span>], fileurl)</span><br><span class="line">            <span class="symbol">except:</span></span><br><span class="line">                os.remove(fileurl)                               <span class="comment">#删除下载失败的文件</span></span><br><span class="line">                <span class="keyword">self</span>.q.put((url, ojName, proId))                 <span class="comment">#放回队列</span></span><br><span class="line">            <span class="comment">#print("Problem " + str(self.id) + " Done")</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">exitflag:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.q.empty()<span class="symbol">:</span></span><br><span class="line">                links = <span class="keyword">self</span>.q.get()</span><br><span class="line">                <span class="keyword">self</span>.working = True</span><br><span class="line">                download(links[<span class="number">0</span>], links[<span class="number">1</span>], links[<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">self</span>.sch = <span class="number">0</span></span><br><span class="line">                <span class="keyword">self</span>.working = False</span><br></pre></td></tr></table></figure></p><p>其他OJ和UVA的下载器大致相同，将下载改成pdfkit转换即可<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pdfkit.from_url(url, fileurl)</span><br><span class="line">except <span class="keyword">Exception</span> <span class="keyword">as</span> e:</span><br><span class="line">    os.remove(fileurl)                               <span class="comment">#删除下载失败的文件</span></span><br><span class="line">    <span class="keyword">self</span>.q.put((url, ojName, proId))                 <span class="comment">#放回队列</span></span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/winterfell30/downloadproblems" target="_blank" rel="noopener">两个版本的完整代码地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://www.winterfell30.com/tags/Python/"/>
    
      <category term="网络" scheme="http://www.winterfell30.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Good Bye 2016</title>
    <link href="http://www.winterfell30.com/2016/12/31/goodbye2016/"/>
    <id>http://www.winterfell30.com/2016/12/31/goodbye2016/</id>
    <published>2016-12-31T04:02:04.000Z</published>
    <updated>2020-04-10T06:56:35.685Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>CF又到了一年一度的Good Bye Contest，心满意足的掉了一小波分，感觉自己很是智障。。。</p><p>去年GoodBye2015的杂记什么都没写，因为当时还在不停地做题，有种才刚开始的感觉，然后随着做题记录变长大二飞速的过去。那个做题记录差不多是从上了大二之后开始记录，在今年暑假因为太懒就停下了。</p><p>上半年拿到了打ACM以来的第一块牌，是省赛的，虽然有点遗憾不过也算上半年不是一无所获了。。。</p><p>在今年的不知道什么时候坚定了不考研。成绩不够保不了个啥好点的学校也懒得考了。。。省赛之前还在想要不省赛之后就不打了吧，后来还是决定搞一波，还报名了多校。<br>基本上后来就是学习了一些比较偏后期的算法吧，反正学习新东西还是比较开心。</p><p>区域赛之后就开始看看书学学习制定一下方向，不知道怎么想的报了个CCF成绩。</p><p>然后就下来还是看书，有一摞的书要看，有很多东西要学，其实感觉挺爽的。</p><p>被亲戚嘲讽了一波之后决定不再自暴自弃，不再穿运动裤卫衣什么的，不要因为所谓“程序员都是这样”就放弃治疗了= =</p><p>打算好好研究一下加缪和萨特= =我相信更深入的学习哲学能让我真的找到人生的意义。。。</p><p>买了一本《程序员健康指南》，希望有生之年不要被伤病困扰（虽然看起来好像颈椎背部什么的已经开始搞事情了。。。</p><p>就这样啦明年再见</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="杂记" scheme="http://www.winterfell30.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>将一个类指针赋值为nullptr之后</title>
    <link href="http://www.winterfell30.com/2016/12/28/nullpointerclass/"/>
    <id>http://www.winterfell30.com/2016/12/28/nullpointerclass/</id>
    <published>2016-12-28T15:37:38.000Z</published>
    <updated>2017-01-22T03:04:41.004Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>今天突然想到很久之前看到的一个问题，运行这段程序，会发生什么呢<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    test()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;(*<span class="keyword">this</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test* p = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析一下，定义一个test类的指针，并把指针指向的地址赋为null，然后调用f()输出这个类的地址。<br>测试之后这个函数f()能够正常执行并且输出0，并没有因为地址为null就发生异常，然后去查了一下相关知道了：<br>成员函数是存在全局内存的函数表里面的，也就是在编译的时候函数f()就已经被分配了地址，我们可以使用一些黑科技输出一下成员函数f的地址：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> dst_type,<span class="keyword">typename</span> src_type&gt;</span><br><span class="line"><span class="function">dst_type <span class="title">pointer_cast</span><span class="params">(src_type src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;dst_type*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;src));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p1 = pointer_cast&lt;<span class="keyword">void</span>*&gt;(&amp;test::f);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>输出了p1的值为0x40415c，虽然知道这个没有什么意义，但是知道它是和实例无关的存在着就可以了,<a href="http://www.cnblogs.com/nbsofer/p/get_member_function_address_cpp.html" target="_blank" rel="noopener">查看成员函数地址的4种方法</a><br>然后我们试着输出一下p-&gt;x，发现只要运行到涉及p-&gt;x的操作就会出现异常然后结束程序。<br>再测试几种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">test()</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f4</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test *t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> r1 = t-&gt;f1();</span><br><span class="line">    <span class="keyword">int</span> r2 = t-&gt;f2();</span><br><span class="line">    <span class="keyword">int</span> r3 = t-&gt;f3();</span><br><span class="line">    <span class="keyword">int</span> r4 = t-&gt;f4();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>f1，f2可以正常运行，f3，f4运行出错。<br>f1已经分析过了；<br>f2是静态函数，本身就不属于类，所以跟类的指针没有关系，可以运行；<br>f3是虚函数，虚函数是通过虚函数表来实现的，而虚函数表是存在于对象中的，对象为null了，自然就无法访问了；<br>f4是调用了类的成员变量，而成员变量也同样是存在于类的对象中的，为null的对象没有了成员变量的存储空间，也无法访问。</p><p>再回到成员变量x无法访问上面来，我发现成员变量的地址是可以输出的，也就是说虽然这个类是null的，但是里面的成员变量还是有地址的，我这里就不大明白。<br>后来仔细考虑了一下nullptr的工作方式明白了。其实把这个类指针指向0是用来表示它不存在，但实际0也是一个地址，所以类里面int型的成员变量的地址就会是0x00,0x04…而为了表示指向0的指针不存在，所以系统对内存0x00设置了不能访问的权限。</p><p>以上为我的测试和猜想，如果有错误欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP练习题5.5和5.6的一个细节</title>
    <link href="http://www.winterfell30.com/2016/12/26/csappchapter5/"/>
    <id>http://www.winterfell30.com/2016/12/26/csappchapter5/</id>
    <published>2016-12-26T14:38:59.000Z</published>
    <updated>2016-12-28T15:59:52.989Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>练习题5.5 5.6<br>5.5写一个对多项式$a_0+a_1x+a_2x^2+a_3x^3…+a_nx^n$的函数，求这个函数的CPE<br>算法一<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">poly</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">double</span> x, <span class="keyword">int</span> degree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> xpwr = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= degree; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += a[i] * xpwr;</span><br><span class="line">        xpwr = x * xpwr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为处理器是多核心的，所以两个乘法可以并行计算，需要5个周期，在当前迭代可以只计算出a[i]*xpwr和x*xpwr，在下一次迭代中计算a[i+1]*xpwr时再计算result加上上一次迭代的值，这样加法就不占周期了。<br>5.6<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">polyh</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">double</span> x, <span class="keyword">int</span> degree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = a[degree];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = degree - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        result = a[i] + x * result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次迭代都需要求出result，而计算result中的每个计算都是和result相关的，完全用不到流水线，CPE是3+5=8。</p><p>这道题说明了最小化一个计算中的操作数量不一定会提高它的性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="系统" scheme="http://www.winterfell30.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《C++ primer》chapter14 程序练习题</title>
    <link href="http://www.winterfell30.com/2016/12/22/cppprimer14practice/"/>
    <id>http://www.winterfell30.com/2016/12/22/cppprimer14practice/</id>
    <published>2016-12-22T14:48:25.000Z</published>
    <updated>2016-12-22T14:52:04.829Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>第14章部分练习题答案，大都为后面一些的内容，有些练习题太重复就不写了<br>14.30<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr(): curr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, <span class="keyword">size_t</span> sz = <span class="number">0</span>):</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">deref</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">StrBlobPtr&amp; <span class="title">incr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);</span><br><span class="line">        ++curr;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;</span><br><span class="line">    check(<span class="built_in">std</span>::<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = wptr.lock();</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unbound StrBlobPtr"</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= ret-&gt;<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存一个weak_ptr,意味着底层vector可能会被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; wptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>14.35<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input_String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::istream&amp; in = <span class="built_in">std</span>::<span class="built_in">cin</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> t;</span><br><span class="line">        getline(in, t);</span><br><span class="line">        <span class="keyword">if</span> (in)</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>14.42<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">2000</span>, <span class="number">2333</span>, <span class="number">1</span>, <span class="number">1024</span>&#125;;</span><br><span class="line"><span class="comment">//统计大于1024的数的个数</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="built_in">std</span>::count_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">std</span>::bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, <span class="number">1024</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs&#123;<span class="string">"pooh"</span>, <span class="string">"pooh"</span>, <span class="string">"pooh"</span>, <span class="string">"2333"</span>, <span class="string">"pooh"</span>&#125;;</span><br><span class="line"><span class="comment">//找到第一个不是pooh的字符串</span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">std</span>::find_if(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">std</span>::bind(<span class="built_in">std</span>::not_equal_to&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, <span class="string">"pooh"</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vv&#123;<span class="number">2000</span>, <span class="number">2333</span>, <span class="number">1</span>, <span class="number">1024</span>&#125;;</span><br><span class="line"><span class="comment">//将所有的值乘以2</span></span><br><span class="line"><span class="built_in">std</span>::transform(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), vv.<span class="built_in">begin</span>(), <span class="built_in">std</span>::bind(<span class="built_in">std</span>::multiplies&lt;<span class="keyword">int</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : vv) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>14.44<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用function实现二元运算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">divide</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a % b; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; cal =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">"+"</span>, add&#125;,</span><br><span class="line">    &#123;<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">    &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a * b;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">"/"</span>, divide()&#125;,</span><br><span class="line">    &#123;<span class="string">"%"</span>, mod&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; ch &gt;&gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; ch &lt;&lt; b &lt;&lt; <span class="string">"="</span> &lt;&lt; cal[<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="number">1</span>, ch)](a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>14.45<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">std::string</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> bookNo;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//double  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> revenue;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>一些简单的Shell练习题</title>
    <link href="http://www.winterfell30.com/2016/12/20/shellpractice/"/>
    <id>http://www.winterfell30.com/2016/12/20/shellpractice/</id>
    <published>2016-12-20T15:38:18.000Z</published>
    <updated>2016-12-22T14:55:28.425Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>1、用sed修改test.txt的23行test为tset<br>直接搞<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i '23s/<span class="keyword">test</span>/<span class="keyword">tset</span>/<span class="keyword">g</span>' <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure></p><p>2、查看/web.log第25行第三列的内容。<br>用-F把分隔符改成空，这样就能得到第3个字符了<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">awk</span> -F <span class="string">""</span> <span class="string">'NR==25&#123;print <span class="variable">$3</span>&#125;'</span> /web.log</span><br></pre></td></tr></table></figure></p><p>3、删除每个临时文件的最初三行。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sed</span> -i <span class="string">'1, 3d'</span> <span class="regexp">*.tmp</span></span><br></pre></td></tr></table></figure></p><p>4、脚本编程：求100内的质数。<br>把文件中的内容存到clipboard:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename <span class="string">| xclip -selection clipboard</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#calculate all prime numbers between 1 and 100</span></span><br><span class="line"></span><br><span class="line">i=2</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 100 ]; <span class="keyword">do</span></span><br><span class="line">     flag=1</span><br><span class="line">     <span class="keyword">for</span> (( j=2;j&lt;<span class="variable">$i</span>;j++ )); <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">if</span> [ $(( <span class="variable">$i</span> % <span class="variable">$j</span> )) -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">             flag=0</span><br><span class="line">             <span class="built_in">break</span></span><br><span class="line">         <span class="keyword">fi</span></span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line">     <span class="keyword">if</span> [ <span class="variable">$flag</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">         <span class="built_in">echo</span> -ne <span class="string">"<span class="variable">$i</span>\n"</span></span><br><span class="line">     <span class="keyword">fi</span></span><br><span class="line">     i=$(( i + 1 ))</span><br><span class="line"> <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>5、晚上11点到早上8点之间每两个小时查看一次系统日期与时间，写出具体配置命令<br>crontab使用计划表<br>*　　*　　*　　*　　*　　command<br>分　时 日　月　周 命令<br>不设置的可以直接用*表示，||用逗号表示<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="number">0</span> <span class="number">23</span>,<span class="number">1</span><span class="number">-8</span>/<span class="number">2</span> * * * /bin/date &gt;&gt; /etc/time.log</span><br></pre></td></tr></table></figure></p><p>6、编写个shell脚本将当前目录下大于10K的文件转移到/tmp目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#remove all files which bigger than 10kb from current dir to current/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `ls -l | awk <span class="string">'&#123;if($5&gt;10240)&#123;print $9&#125;&#125;'</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mv <span class="variable">$i</span> /tmp</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>7、在shell环境如何杀死一个进程？<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> -<span class="keyword">s</span> <span class="number">9</span> <span class="string">`pgrep processname</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>将file.txt的制表符，即tab，全部替换成”|”<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/\t/\|/g"</span> <span class="built_in">file</span>.txt</span><br></pre></td></tr></table></figure></p><p>8、把当前目录（包含子目录）下所有后缀为“.sh”的文件后缀变更为“.shell”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#replace .sh to .shell</span></span><br><span class="line">str=`find ./ -name \*.sh`</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$str</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mv <span class="variable">$i</span> <span class="variable">$&#123;i%sh&#125;</span>shell</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>9、假设有一个脚本scan.sh，里面有1000行代码，并在vim模式下面，请按照如下要求写入对应的指令<br>1）将shutdown字符串全部替换成reboot<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:%s/shutdown/reboot/g</span></span><br></pre></td></tr></table></figure></p><p>2）清空所有字符<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:%d</span></span><br></pre></td></tr></table></figure></p><p>3）不保存退出<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:q!</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://www.winterfell30.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《C++ primer》chapter13 程序练习题</title>
    <link href="http://www.winterfell30.com/2016/12/12/cppprimerch13practice/"/>
    <id>http://www.winterfell30.com/2016/12/12/cppprimerch13practice/</id>
    <published>2016-12-12T15:12:41.000Z</published>
    <updated>2016-12-12T15:57:08.836Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br><del>从这章才开始做练习。。。没想到这些练习这么麻烦，写各种类写成傻逼了</del></p><p>13.5 13.8 13.11<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;rhs):</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*rhs.ps)), i(rhs.i) &#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">        i = rhs.i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~HasPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>13.13<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X&amp; x) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X(const X&amp;)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    X&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> X&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X&amp; operator=(const X&amp; rhs)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~X()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X *a = <span class="keyword">new</span> X;</span><br><span class="line">    X *c = a;</span><br><span class="line">    X b;</span><br><span class="line">    b = *c;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.17<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">numbered</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mysn;</span><br><span class="line">    numbered(): mysn(++num) &#123;&#125;</span><br><span class="line">    numbered(<span class="keyword">const</span> numbered&amp; rhs) : mysn(++num) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> numbered&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x.mysn &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    numbered a, b = a, c = b;</span><br><span class="line">    f(a), f(b), f(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.19<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee(): name(<span class="built_in">std</span>::<span class="built_in">string</span>()), id(++num) &#123;&#125;</span><br><span class="line">    Employee(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s): name(s), id(++num) &#123;&#125;</span><br><span class="line">    Employee(<span class="keyword">const</span> Employee&amp; e) = <span class="keyword">delete</span>;</span><br><span class="line">    Employee&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Employee&amp; e) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Employee::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee a;</span><br><span class="line">    <span class="function">Employee <span class="title">b</span><span class="params">(<span class="string">"2333"</span>)</span></span>;</span><br><span class="line">    <span class="function">Employee <span class="title">c</span><span class="params">(b.name)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.name &lt;&lt; <span class="string">" "</span> &lt;&lt; a.id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.name &lt;&lt; <span class="string">" "</span> &lt;&lt; b.id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.name &lt;&lt; <span class="string">" "</span> &lt;&lt; c.id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.26<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::size_type size_type;</span><br><span class="line">    StrBlob():</span><br><span class="line">        data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;()) &#123;&#125;</span><br><span class="line">    StrBlob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; il):</span><br><span class="line">        data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;(il)) &#123;&#125;</span><br><span class="line">    StrBlob(<span class="keyword">const</span> StrBlob&amp; rhs):</span><br><span class="line">        data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;(*rhs.data)) &#123;&#125;</span><br><span class="line">    StrBlob&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StrBlob&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        data = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;(*rhs.data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; t)</span> </span>&#123; data-&gt;push_back(t);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        check(<span class="number">0</span>, <span class="string">"pop_back failed.This StrBlob is empty."</span>);</span><br><span class="line">        data-&gt;pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        check(<span class="number">0</span>, <span class="string">"This StrBlob is empty."</span>);</span><br><span class="line">        <span class="keyword">return</span> data-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        check(<span class="number">0</span>, <span class="string">"This StrBlob is empty."</span>);</span><br><span class="line">        <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>13.27<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr():</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>()), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;rhs):</span><br><span class="line">        ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++*use; &#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ++*rhs.use;</span><br><span class="line">        <span class="keyword">if</span> (--*use == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">        ps = rhs.ps;</span><br><span class="line">        i = rhs.i;</span><br><span class="line">        use = rhs.use;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~HasPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (--*use == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>13.28<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>             //行为像指针的类，使用引用计数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode():</span><br><span class="line">        value(<span class="built_in">std</span>::<span class="built_in">string</span>()), count(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s):</span><br><span class="line">        value(s), count(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">const</span> TreeNode&amp; tn):</span><br><span class="line">        value(tn.value), count(tn.count), left(tn.left), right(tn.right) &#123; ++*count; &#125;</span><br><span class="line">    TreeNode&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TreeNode&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ++*rhs.count;</span><br><span class="line">        <span class="keyword">if</span> (--*count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">            <span class="keyword">delete</span> left;</span><br><span class="line">            <span class="keyword">delete</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        count = rhs.count;</span><br><span class="line">        left = rhs.left;</span><br><span class="line">        right = rhs.right;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~TreeNode()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (--*count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">            <span class="keyword">delete</span> left;</span><br><span class="line">            <span class="keyword">delete</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> *count;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinStrTree</span>          //行为像值的类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinStrTree():</span><br><span class="line">        root(<span class="keyword">new</span> TreeNode()) &#123;&#125;</span><br><span class="line">    BinStrTree(<span class="keyword">const</span> BinStrTree&amp; p):</span><br><span class="line">        root(p.root) &#123;&#125;</span><br><span class="line">    BinStrTree&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BinStrTree&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = <span class="keyword">new</span> TreeNode(*rhs.root);</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">        root = t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>13.30 13.31<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp; lhs, HasPtr&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2333"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        swap(lhs.ps, rhs.ps);</span><br><span class="line">        swap(lhs.i, rhs.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HasPtr&amp; lhs, <span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *lhs.ps &lt; *rhs.ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;rhs):</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*rhs.ps)), i(rhs.i) &#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">        i = rhs.i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~HasPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>13.36 13.37 13.38<br>这题的重点是两个类是怎么相互调用的，<a href>点击这里:两个类互相调用的方法</a>。<br>Folder.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOLDER_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLDER_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Folder() &#123;&#125;</span><br><span class="line">    Folder(Folder&amp;);</span><br><span class="line">    Folder&amp; <span class="keyword">operator</span>=(Folder&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line">    ~Folder();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Message*&gt; msgs;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_to_Messages</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_from_Messages</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOLDER_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure></p><p>Folder.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Message.h"</span></span></span><br><span class="line"></span><br><span class="line">Folder::Folder(Folder&amp; p):        <span class="comment">//不可以用const</span></span><br><span class="line">    msgs(p.msgs) &#123; add_to_Messages(p); &#125;</span><br><span class="line"></span><br><span class="line">Folder&amp; Folder::<span class="keyword">operator</span>=(Folder&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Messages();</span><br><span class="line">    msgs = rhs.msgs;</span><br><span class="line">    add_to_Messages(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::add_to_Messages</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : f.msgs)</span><br><span class="line">        i-&gt;addFol(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::remove_from_Messages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : msgs)</span><br><span class="line">        i-&gt;remFol(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder::~Folder()</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Messages();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::addMsg</span><span class="params">(Message* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    msgs.insert(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::remMsg</span><span class="params">(Message* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    msgs.erase(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Message.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MESSAGE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Folder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str = <span class="string">""</span>)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">contents</span><span class="params">(str)</span> </span>&#123;&#125;</span><br><span class="line">    Message(<span class="keyword">const</span> Message&amp;);</span><br><span class="line">    Message&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Message&amp;);</span><br><span class="line">    ~Message();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Message&amp;, Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFol</span><span class="params">(Folder*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remFol</span><span class="params">(Folder*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Folder*&gt; folders;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_to_Folders</span><span class="params">(<span class="keyword">const</span> Message&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_from_Folders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MESSAGE_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure></p><p>Message.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Message.h"</span></span></span><br><span class="line"></span><br><span class="line">Message::Message(<span class="keyword">const</span> Message&amp; p):</span><br><span class="line">    contents(p.contents), folders(p.folders) &#123; add_to_Folders(p); &#125;</span><br><span class="line"></span><br><span class="line">Message&amp; Message::<span class="keyword">operator</span>=(<span class="keyword">const</span> Message&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Folders();</span><br><span class="line">    contents = rhs.contents;</span><br><span class="line">    folders = rhs.folders;</span><br><span class="line">    add_to_Folders(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message::~Message()</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Folders();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::swap</span><span class="params">(Message&amp; lhs, Message&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;rhs);</span><br><span class="line">    swap(lhs.folders, rhs.folders);</span><br><span class="line">    swap(lhs.contents, rhs.contents);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;addMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;rhs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::save</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.insert(&amp;f);</span><br><span class="line">    f.addMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remove</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.erase(&amp;f);</span><br><span class="line">    f.remMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::addFol</span><span class="params">(Folder* f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.insert(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remFol</span><span class="params">(Folder* f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.erase(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::add_to_Folders</span><span class="params">(<span class="keyword">const</span> Message&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : msg.folders)</span><br><span class="line">        f-&gt;addMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remove_from_Folders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : folders)</span><br><span class="line">        f-&gt;remMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.39 13.40 13.41 13.42 13.43<br>StrVec.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STRVEC_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRVEC_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrVec(): elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    StrVec(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);  <span class="comment">//列表构造函数</span></span><br><span class="line">    StrVec(<span class="keyword">const</span> StrVec&amp;);                       <span class="comment">//拷贝构造函数</span></span><br><span class="line">    StrVec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp;);            <span class="comment">//拷贝复制运算符</span></span><br><span class="line">    ~StrVec() &#123; <span class="built_in">free</span>(); &#125;                        <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;          <span class="comment">//拷贝元素</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first_free - elements; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> cap - elements; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> elements; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first_free; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; alloc; <span class="comment">//分配元素,因为是static，不要忘记在别的文件定义一下</span></span><br><span class="line">    <span class="comment">//被添加元素的函数所使用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == capacity()) reallocate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//工具函数 被拷贝构造函数，赋值运算和析构函数所使用</span></span><br><span class="line">    std::pair&lt;std::string*, std::string*&gt; alloc_n_copy(const std::string*, const std::string*);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;                            <span class="comment">//销毁元素释放内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free2</span><span class="params">()</span></span>;                           <span class="comment">//for_each和lambda</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;                      <span class="comment">//获得更多内存并拷贝已有函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *elements;                  <span class="comment">//指向首元素的指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *first_free;                <span class="comment">//指向数组第一个空闲元素的指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *cap;                       <span class="comment">//指向数组尾后位置的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STRVEC_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure></p><p>StrVec.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"StrVec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; StrVec::alloc;</span><br><span class="line"></span><br><span class="line">StrVec::StrVec(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec::StrVec(<span class="keyword">const</span> StrVec&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = first_free; p != elements; )</span><br><span class="line">            alloc.destroy(--p);</span><br><span class="line">        alloc.deallocate(elements, cap - elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::pair&lt;std::string*, std::string*&gt; StrVec::alloc_n_copy(const std::string* bg, const std::string* ed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc.allocate(ed - bg);</span><br><span class="line">    <span class="keyword">return</span> &#123; data, <span class="built_in">std</span>::uninitialized_copy(bg, ed, data) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::free2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    for_each(elements, first_free, [](<span class="built_in">std</span>::<span class="built_in">string</span>&amp; r)&#123;alloc.destroy(&amp;r);&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newcapacity = <span class="built_in">size</span>() ? (<span class="built_in">size</span>() * <span class="number">2</span>) : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="keyword">auto</span> elem = elements;</span><br><span class="line">    <span class="keyword">auto</span> dest = newdata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="built_in">size</span>(); i++)</span><br><span class="line">        alloc.construct(dest++, <span class="built_in">std</span>::<span class="built_in">move</span>(*elem++));</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = newdata;</span><br><span class="line">    first_free = dest;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reserve</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; capacity())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> newcapacity = n;</span><br><span class="line">        <span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);</span><br><span class="line">        <span class="keyword">auto</span> elem = elements;</span><br><span class="line">        <span class="keyword">auto</span> dest = newdata;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++)</span><br><span class="line">            alloc.construct(dest++, <span class="built_in">std</span>::<span class="built_in">move</span>(*elem++));</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements = newdata;</span><br><span class="line">        first_free = dest;</span><br><span class="line">        cap = elements + newcapacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::resize</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dest = elements + n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (first_free != dest)</span><br><span class="line">            alloc.destroy(--first_free);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; capacity()) reallocate();</span><br><span class="line">        <span class="keyword">while</span> (first_free != dest)</span><br><span class="line">            alloc.construct(first_free++, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::resize</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    resize(n, <span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">StrVec <span class="title">a</span><span class="params">(&#123;<span class="string">"2"</span>, <span class="string">"3"</span>&#125;)</span></span>;</span><br><span class="line">    a.push_back(<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"大小"</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"容量"</span> &lt;&lt; a.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    a.push_back(<span class="string">"2"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"大小"</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"容量"</span> &lt;&lt; a.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.44<br>SString.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SSTRING_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSTRING_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SString(): elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    SString(<span class="keyword">const</span> <span class="keyword">char</span> *ch, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>);</span><br><span class="line">    SString(<span class="keyword">const</span> SString&amp;);</span><br><span class="line">    SString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SString&amp;);</span><br><span class="line">    ~SString() &#123; <span class="built_in">free</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cap - elements; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first_free - elements; &#125;</span><br><span class="line">    std::pair&lt;char*, char*&gt; alloc_n_copy(const char*, const char*);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; alloc;</span><br><span class="line">    <span class="keyword">char</span> *elements;</span><br><span class="line">    <span class="keyword">char</span> *first_free;</span><br><span class="line">    <span class="keyword">char</span> *cap;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SSTRING_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure></p><p>SString.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; SString::alloc;</span><br><span class="line"></span><br><span class="line">SString::SString(<span class="keyword">const</span> <span class="keyword">char</span> *ch, <span class="built_in">std</span>::<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(ch, ch + len);</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SString::SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(s.elements, s.cap);</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SString&amp; SString::<span class="keyword">operator</span>=(<span class="keyword">const</span> SString&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(rhs.elements, rhs.cap);</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::pair&lt;char*, char*&gt; SString::alloc_n_copy(const char *bg, const char *ed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc.allocate(ed - bg);</span><br><span class="line">    <span class="keyword">return</span> &#123; data, <span class="built_in">std</span>::uninitialized_copy(bg, ed, data) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SString::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>* p = elements; p != first_free; p++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SString::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::for_each(elements, first_free, [](<span class="keyword">char</span>&amp; ch)&#123;alloc.destroy(&amp;ch);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.48<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[] = <span class="string">"2333"</span>;</span><br><span class="line">    <span class="function">SString <span class="title">s</span><span class="params">(a, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SString&gt; v;</span><br><span class="line">    v.push_back(s);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(s);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(s);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(s);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(s);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line">解释：在<span class="built_in">vector</span>扩充的时候会把现有的都拷贝过去，所以每次<span class="built_in">vector</span>在capacity变大的时候都会拷贝之前所有的。</span><br></pre></td></tr></table></figure></p><p>13.49<br>StrVec<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec&amp;&amp; s) <span class="keyword">noexcept</span>:</span><br><span class="line">    elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">    &#123;</span><br><span class="line">        s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;    <span class="comment">//对s的析构函数是安全的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)       <span class="comment">//检测自赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SString<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SString::SString(SString&amp;&amp; s) <span class="keyword">noexcept</span>:</span><br><span class="line">    elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">    &#123;</span><br><span class="line">        s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">SString&amp; SString::<span class="keyword">operator</span>=(SString&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)       <span class="comment">//检测自赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Message<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::move_folder</span><span class="params">(Message* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders = <span class="built_in">std</span>::<span class="built_in">move</span>(msg-&gt;folders);    <span class="comment">//使用set的移动赋值运算符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : folders)</span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;remMsg(msg);                   <span class="comment">//从folder中删除旧的message</span></span><br><span class="line">        f-&gt;addMsg(<span class="keyword">this</span>);                  <span class="comment">//将这个message加入到folder</span></span><br><span class="line">    &#125;</span><br><span class="line">    (msg-&gt;folders).<span class="built_in">clear</span>();               <span class="comment">//确保销毁msg是无害的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message::Message(Message&amp;&amp; p) <span class="keyword">noexcept</span>:</span><br><span class="line">    contents(<span class="built_in">std</span>::<span class="built_in">move</span>(p.contents))</span><br><span class="line">    &#123;</span><br><span class="line">        move_folder(&amp;p);                       <span class="comment">//移动folder并更新folder指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Message&amp; Message::<span class="keyword">operator</span>=(Message&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        remove_from_Folders();</span><br><span class="line">        contents = <span class="built_in">std</span>::<span class="built_in">move</span>(rhs.contents);</span><br><span class="line">        move_folder(&amp;rhs);                     <span class="comment">//重置folder指向当前运算符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.50<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(SString&amp;&amp; s)</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(SString&amp;&amp; s)</span><br><span class="line">SString(SString&amp;&amp; s)</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line">SString(<span class="keyword">const</span> SString&amp; s)</span><br><span class="line">SString(SString&amp;&amp; s)</span><br><span class="line">SString(SString&amp;&amp; s)</span><br><span class="line">SString(SString&amp;&amp; s)</span><br><span class="line">SString(SString&amp;&amp; s)</span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line">解释：只有在push新的SString的时候才会调用拷贝构造函数，在<span class="built_in">vector</span>扩展空间的时候调用移动拷贝构造函数</span><br></pre></td></tr></table></figure></p><p>13.54<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp; lhs, HasPtr&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"swap(HasPtr&amp; lhs, HasPtr&amp; rhs)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        swap(lhs.ps, rhs.ps);</span><br><span class="line">        swap(lhs.i, rhs.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HasPtr&amp; lhs, <span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *lhs.ps &lt; *rhs.ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr(const std::string &amp;s = std::string())"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;rhs):</span><br><span class="line">        ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*rhs.ps)), i(rhs.i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr(const HasPtr &amp;rhs)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    HasPtr(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> :</span><br><span class="line">        ps(p.ps), i(p.i) &#123; p.ps=<span class="number">0</span>; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr(HasPtr &amp;&amp;p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr&amp; operator=(HasPtr rhs)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~HasPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>13.55<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; t)</span> </span>&#123; data-&gt;push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(t)); &#125;</span><br></pre></td></tr></table></figure></p><p>13.58<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo sorted() &amp;&amp;"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo sorted() const &amp;"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="function">Foo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(ret.data.<span class="built_in">begin</span>(), ret.data.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因为是整章看过一段时间才回头补的，有错误欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CCF考试2015年12月练习</title>
    <link href="http://www.winterfell30.com/2016/12/12/CCF201512/"/>
    <id>http://www.winterfell30.com/2016/12/12/CCF201512/</id>
    <published>2016-12-12T15:11:43.000Z</published>
    <updated>2016-12-12T15:50:51.602Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>不知道为什么脑子抽风报名了CCF，感觉都是模拟题，一副要挂的样子。<br>做了一下之前的题目，有两个感觉很稳的题第一次提交没拿到满分，考试基本也是GG的节奏。。。<br>第一题代码没找到，就是一个找折点的题就统计一遍就行了。<br>(顺便吐槽一下CCF这个做题系统提交过的题目竟然看不到代码<br>第二题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>][<span class="number">50</span>], b[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]), b[i][j] = a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now = a[i][j];</span><br><span class="line">            <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>, cnt3 = <span class="number">0</span>, cnt4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k1 = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k1 &gt;= <span class="number">1</span> &amp;&amp; a[k1][j] == now) cnt1++, k1--;</span><br><span class="line">            <span class="keyword">int</span> k2 = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k2 &lt;= n &amp;&amp; a[k2][j] == now) cnt2++, k2++;</span><br><span class="line">            <span class="keyword">if</span> (cnt1 + cnt2 &gt;= <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = k1 + <span class="number">1</span>; k &lt;= k2 - <span class="number">1</span>; k++)</span><br><span class="line">                    b[k][j] = <span class="number">0</span>;</span><br><span class="line">            k1 = j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k1 &gt;= <span class="number">1</span> &amp;&amp; a[i][k1] == now) cnt3++, k1--;</span><br><span class="line">            k2 = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k2 &lt;= m &amp;&amp; a[i][k2] == now) cnt4++, k2++;</span><br><span class="line">            <span class="keyword">if</span> (cnt3 + cnt4 &gt;= <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = k1 + <span class="number">1</span>; k &lt;= k2 - <span class="number">1</span>; k++)</span><br><span class="line">                    b[i][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (j == m) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[i][j]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三题要注意他的坐标系统和数组是不一样的，看好题再做以免浪费时间，刚开始只得到90分因为没考虑在+号上面覆盖的问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ud</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> <span class="comment">//|</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; d) swap(u, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt;= u; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i][x] == <span class="string">'-'</span> || s[i][x] == <span class="string">'+'</span>) s[i][x] = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">else</span> s[i][x] = <span class="string">'|'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lr</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">//-</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; l) swap(l, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[y][i] == <span class="string">'|'</span> || s[y][i] == <span class="string">'+'</span>) s[y][i] = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">else</span> s[y][i] = <span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(make_pair(x, y));</span><br><span class="line">    s[y][x] = ch;</span><br><span class="line">    vis[y][x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = u.first + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = u.second + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m || vis[yy][xx])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[yy][xx] == <span class="string">'-'</span> || s[yy][xx] == <span class="string">'+'</span> || s[yy][xx] == <span class="string">'|'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            s[yy][xx] = ch;</span><br><span class="line">            vis[yy][xx] = <span class="number">1</span>;</span><br><span class="line">            q.push(make_pair(xx, yy));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">105</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">105</span>; j++)</span><br><span class="line">            s[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;type);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            <span class="keyword">if</span> (x1 == x2) ud(x1, m - <span class="number">1</span> - y1, m - <span class="number">1</span> - y2);</span><br><span class="line">            <span class="keyword">else</span> lr(m - <span class="number">1</span> - y1, x1, x2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="keyword">char</span> ch[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;x, &amp;y, ch);</span><br><span class="line">            bfs(x, m - <span class="number">1</span> - y, ch[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (j == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, s[i][j]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四题<br>内存256MB很大，10000*10000都可以开，刚开始没注意到。<br>还有因为他这个数据不是满的大数据所以有些ICPC比赛的时候会T的操作这里不会。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> G[<span class="number">10005</span>][<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gg[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n, m, top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gg[s].<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[gg[s][i]]) dfs2(gg[s][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gg[s].<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G[s][gg[s][i]])</span><br><span class="line">        &#123;</span><br><span class="line">            G[s][gg[s][i]] = G[gg[s][i]][s] = <span class="number">0</span>;</span><br><span class="line">            dfs(gg[s][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    ans.push(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u][v] = <span class="number">1</span>;</span><br><span class="line">        G[v][u] = <span class="number">1</span>;</span><br><span class="line">        gg[u].push_back(v);</span><br><span class="line">        gg[v].push_back(u);</span><br><span class="line">        in[u]++, in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (in[i] &amp; <span class="number">1</span>) v.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">size</span>() == <span class="number">2</span> &amp;&amp; v[<span class="number">0</span>] != <span class="number">1</span> &amp;&amp; v[<span class="number">1</span>] != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        sort(gg[i].<span class="built_in">begin</span>(), gg[i].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)v.<span class="built_in">size</span>() == <span class="number">0</span> || (<span class="keyword">int</span>)v.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!ans.empty()) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans.top()), ans.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第五题<br>矩阵快速幂水了40分。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    LL a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">    Matrix()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) a[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp;B)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix C;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">                C.a[i][j] = (a[i][j] + B.a[i][j]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;B)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix C;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d; k++)</span><br><span class="line">                    C.a[i][j] = (C.a[i][j] ^ (a[i][k] &amp; B.a[k][j]));</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> ^ (<span class="keyword">const</span> <span class="keyword">int</span> &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix res, A = (*<span class="keyword">this</span>);</span><br><span class="line">        res.init();</span><br><span class="line">        <span class="keyword">int</span> p = t;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res = res * A;</span><br><span class="line">            A = A * A;</span><br><span class="line">            p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix A, B, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    d = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            A.a[i][j] = s[i][j] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        B.a[i][<span class="number">0</span>] = s[m][i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        t = (A ^ q) * B;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, t.a[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="题解" scheme="http://www.winterfell30.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++定义两个互相调用的类</title>
    <link href="http://www.winterfell30.com/2016/12/10/TwoClassWhichUseEachOther/"/>
    <id>http://www.winterfell30.com/2016/12/10/TwoClassWhichUseEachOther/</id>
    <published>2016-12-10T14:58:21.000Z</published>
    <updated>2016-12-11T02:16:10.224Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>在做《C++ primer》ch13习题的时候遇到了一个问题，感觉这个问题比较常见但是之前还没有遇到过。<br>要求是定义两个类，分别是Message和Folder。Folder是消息的目录，目录里面包含一些单独的Message。<br>一个消息可以出现在多个目录中，一个目录中包含多个消息：<br><img src="http://img.blog.csdn.net/20130713213202312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FycmluZ2FoMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>也就是说这两个类在其中一个改变的时候也要修改另外一个类。<br>因为函数代码量都比较小，所以刚开始我习惯性的都在类内定义了，然后发现上面的类在使用另一个类名的时候没有声明。于是我就在前面声明了一下变成了这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> B b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> A a; &#125;;</span><br></pre></td></tr></table></figure></p><p>这样虽然B不再是未声明的了但是出现了别的问题，说是invalid use of incomplete type B，然后我去查了一下，A在代码实现时候调用B的时候需要知道B的全部实现。那么问题来了，A需要知道B的全部实现才能实现，B也需要知道A的全部实现才能实现。<br>于是就肯定不能再写在一个文件里面了，解决方法是：<br>在A类的A.h文件里面使用B的前置声明不用包含B.h和B.cpp（因为A.h只是声明A类，所以也不需要B类的实现，只需要知道B是个类就可以，可以类比函数的前置声明）。<br>在B.h中包含A.h的头文件，不需要前置声明A，B可以通过头文件直接找到A的定义和实现，这样问题就解决了。<br>代码大约是这样（A.cpp和B.cpp可以合并不过这并不是重点）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> B b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"A.h"</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> A a; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"B.h"</span>;</span></span><br><span class="line"><span class="comment">//class A implement</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"B.h"</span>;</span></span><br><span class="line"><span class="comment">//class B implement</span></span><br></pre></td></tr></table></figure></p><p>附上最后那两个类的代码:<br>Folder.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOLDER_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLDER_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Folder() &#123;&#125;</span><br><span class="line">    Folder(Folder&amp;);</span><br><span class="line">    Folder&amp; <span class="keyword">operator</span>=(Folder&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line">    ~Folder();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Message*&gt; msgs;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_to_Messages</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_from_Messages</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOLDER_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure></p><p>Folder.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Message.h"</span></span></span><br><span class="line"></span><br><span class="line">Folder::Folder(Folder&amp; p):        <span class="comment">//不可以用const</span></span><br><span class="line">    msgs(p.msgs) &#123; add_to_Messages(p); &#125;</span><br><span class="line"></span><br><span class="line">Folder&amp; Folder::<span class="keyword">operator</span>=(Folder&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Messages();</span><br><span class="line">    msgs = rhs.msgs;</span><br><span class="line">    add_to_Messages(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::add_to_Messages</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : f.msgs)</span><br><span class="line">        i-&gt;addFol(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::remove_from_Messages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : msgs)</span><br><span class="line">        i-&gt;remFol(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder::~Folder()</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Messages();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::addMsg</span><span class="params">(Message* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    msgs.insert(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Folder::remMsg</span><span class="params">(Message* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    msgs.erase(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Message.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MESSAGE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Folder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str = <span class="string">""</span>)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">contents</span><span class="params">(str)</span> </span>&#123;&#125;</span><br><span class="line">    Message(<span class="keyword">const</span> Message&amp;);</span><br><span class="line">    Message&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Message&amp;);</span><br><span class="line">    ~Message();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Message&amp;, Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFol</span><span class="params">(Folder*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remFol</span><span class="params">(Folder*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Folder*&gt; folders;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_to_Folders</span><span class="params">(<span class="keyword">const</span> Message&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_from_Folders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MESSAGE_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure></p><p>Message.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Message.h"</span></span></span><br><span class="line"></span><br><span class="line">Message::Message(<span class="keyword">const</span> Message&amp; p):</span><br><span class="line">    contents(p.contents), folders(p.folders) &#123; add_to_Folders(p); &#125;</span><br><span class="line"></span><br><span class="line">Message&amp; Message::<span class="keyword">operator</span>=(<span class="keyword">const</span> Message&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Folders();</span><br><span class="line">    contents = rhs.contents;</span><br><span class="line">    folders = rhs.folders;</span><br><span class="line">    add_to_Folders(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message::~Message()</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Folders();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::swap</span><span class="params">(Message&amp; lhs, Message&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;rhs);</span><br><span class="line">    swap(lhs.folders, rhs.folders);</span><br><span class="line">    swap(lhs.contents, rhs.contents);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;addMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;rhs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::save</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.insert(&amp;f);</span><br><span class="line">    f.addMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remove</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.erase(&amp;f);</span><br><span class="line">    f.remMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::addFol</span><span class="params">(Folder* f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.insert(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remFol</span><span class="params">(Folder* f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.erase(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::add_to_Folders</span><span class="params">(<span class="keyword">const</span> Message&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : msg.folders)</span><br><span class="line">        f-&gt;addMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remove_from_Folders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : folders)</span><br><span class="line">        f-&gt;remMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Python Socket编程</title>
    <link href="http://www.winterfell30.com/2016/11/22/pythonsocketlearning/"/>
    <id>http://www.winterfell30.com/2016/11/22/pythonsocketlearning/</id>
    <published>2016-11-22T13:49:42.000Z</published>
    <updated>2017-01-22T03:13:05.057Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>粗略看了一下CSAPP的后面的几章，就很想试一下客户端服务端连接，但是像书里那种纯C的代码就有点麻烦什么都要写。<br>所以就选择了用python这么一个很抽象但是很方便的语言来写了。。。</p><p>首先来写客户端代码：<br>我们要用的套接字是socket,AF_INET是IPV4的套接字类型，SOCK_STREAM是TCP协议。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import sys;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">except (socket.error) as msg:</span><br><span class="line">    print(<span class="string">'Failed to creat socket.Error code: '</span> + str[msg[<span class="number">0</span>]] + <span class="string">', Error message : '</span> + msg[<span class="number">1</span>])</span><br><span class="line">    sys.<span class="keyword">exit</span>();</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Socket Created'</span>)</span><br></pre></td></tr></table></figure><p>这里我们用baidu来做测试<del>（听说百度主页的最大用处就是测试网络）</del><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">'www.baidu.com'</span></span><br><span class="line">port = 80</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    remote_ip = socket.gethostbyname(host)</span><br><span class="line">except socket.gaierror:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'Hostname could not be resolved. exiting'</span>)</span><br><span class="line">    sys.exit();</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'Ip address of '</span> + host + <span class="string">' is '</span> + remote_ip)</span><br></pre></td></tr></table></figure></p><p>连接网络<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.connect((remote_ip, port))</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'Socket Connected to '</span> + host + <span class="string">' on ip '</span> + remote_ip)</span></span></span><br></pre></td></tr></table></figure></p><p>发送GET并且观察返回值，然后关闭连接<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">"GET / HTTP/1.1\r\n\r\n"</span></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    s.sendall(message.encode())</span><br><span class="line">except socket.error:</span><br><span class="line">    print(<span class="string">'Send fail'</span>)</span><br><span class="line">    sys.<span class="keyword">exit</span>()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Message send successfully'</span>)</span><br><span class="line"></span><br><span class="line">reply = s.recv(<span class="number">4096</span>)</span><br><span class="line">print(reply)</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></p><p>然后是服务器端的代码<br>服务器端到工作流程大致就是先创建socket，然后绑定IP和端口，绑定之后开始监听，listen中的参数10代表最多可以有10个连接请求在队列中。<br>然后等待客户端连接（这里我们用telnet模拟测试，运行服务器端然后在终端输入telnet localhost 8888即可），accept之后接收客户端发来的信息，同时返回信息用于测试。</p><p>显然我们按照这个流程走一遍的话只能连接一个终端并且只能接收一次数据，于是我们可以用一个while不停的accept。<br>这样虽然解决了一次就结束到缺陷，但是依然每个终端只能接收一个数据就结束，然后不能同时两个终端一起发送，必须一个结束之后才能进行另外一个。<br>对于第一个问题，我们只需要在每次连接之后都在里面再设置一个while(1)的循环控制能接收多次数据即可，退出时按Ctrl+]然后close关闭。<br>对于第二个问题，自然而然的能想到用多线程来解决，对于每一个终端(端口)创建一个线程，这样就能互不干扰了。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"><span class="keyword">from</span> _thread import*</span><br><span class="line"></span><br><span class="line">host = <span class="string">''</span></span><br><span class="line">port = 8888</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'Socket created'</span>)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    s.bind((host, port))</span><br><span class="line">except (socket.error) as msg:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'Bind failed, Error Code: '</span> + str(msg[0]) + <span class="string">' Message '</span> + msg[1])</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'Socket bind complete'</span>)</span><br><span class="line"></span><br><span class="line">s.listen(10)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'Socket now listening'</span>)</span><br><span class="line"></span><br><span class="line">def clientthread(conn):</span><br><span class="line">    conn.send(<span class="string">"Welcome to the server. Type something and hit enter\n"</span>.encode())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(1024)</span><br><span class="line">        reply = <span class="string">'OK...'</span>.encode() + data</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            break</span><br><span class="line">        conn.sendall(reply)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (1):</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'Connected with '</span> + addr[0] + <span class="string">':'</span> + str(addr[1]))</span><br><span class="line"></span><br><span class="line">    start_new_thread(clientthread, (conn,))</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></p><p>这里面学到了一些py3的语法小知识。。。’OK…’和data这种在python3中是两种字符串类型，需要.encode转换一下。<br>在处理异常传递参数的时候python2可以socket.error, msg这样用逗号隔开,在python3中需要写成(socket.error) as msg<br>在import时有两种方法，用_thread举个例子，可以用常规的import _thread 这样import之后调用类的时候必须要先写上_thread.start_new_thread()<br>用from _thread import xxx方法的时候可以直接在下面调用start_new_thread()。这样虽然写起来更简单，但是有可能会导致命名混乱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://www.winterfell30.com/tags/Python/"/>
    
      <category term="网络" scheme="http://www.winterfell30.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《C++ primer》第十二章动态内存笔记</title>
    <link href="http://www.winterfell30.com/2016/11/19/cppprimer12/"/>
    <id>http://www.winterfell30.com/2016/11/19/cppprimer12/</id>
    <published>2016-11-19T06:19:19.000Z</published>
    <updated>2016-11-23T08:08:25.735Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a><br>p是个一个shared_ptr<t>的对象。<br>*p为解引用p，p-&gt;mem等价于(*p).mem。<br>p.get()返回p中保存的指针，要小心使用，如果智能指针释放了其对象，返回的指针所指向的对象也会消失。<br>shared_ptr拥有一个关联的计数器，我们称之为引用计数，拷贝时会增加，赋予新值或者一个局部的shared_ptr离开作用域时会减小。<br>shared_ptr会自动销毁所管理的对象，shared_ptr的析构函数会递减他所指向到对象到引用计数，当引用计数变为0的时候就会销毁对象释放内存。<br>由于在最后一个shared_ptr销毁前内存都不会释放，所以要记得shared_ptr无用的时候要记得用erase删掉。<br>使用动态内存的一个常见原因是允许多个对象共享相同到状态，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2 = &#123;<span class="string">"a"</span>, <span class="string">"aa"</span>, <span class="string">"aaa"</span>&#125;;</span><br><span class="line">    v1 = v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>v2离开作用域之后被销毁，中间的元素也被销毁，v1中的三个元素是v2中三个元素的拷贝，在销毁前这三个元素就是和v2中的三个元素相互独立的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="built_in">string</span>&gt; b1</span><br><span class="line">&#123;</span><br><span class="line">    Blob&lt;<span class="built_in">string</span>&gt; b2 = <span class="string">"a"</span>, <span class="string">"aa"</span>, <span class="string">"aaa"</span>&#125;;</span><br><span class="line">    b1 = b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>b2离开作用域之后被销毁，但是那三个元素被v1引用，所以被销毁到只是b2，那三个string依然存在，被b1指向。</p><p>括号中仅有单一初始化器时才可以使用auto.<br>内存耗尽时可以使用<code>int *p1 = new (nothrow) int;</code>的方法分配，如果内存不足会返回空指针。<br>使用new分配的动态对象到生存期直到被释放为止，即使离开作用域也不会被释放。<br>忘记delete会导致常说的内存泄漏，因为这种内存永远不可能归还给自由空间了。查找内存泄漏是很困难的，通过在释放内存之后将指针置为空，可以有效检测误用已经释放掉到对象的错误<br>坚持只使用智能指针就可以避免很多问题，对于一块内存只有保证没有任何智能指针指向他的时候，才会被自动释放掉。<br>接受指针参数的智能指针到构造函数时explicit的所以我们不能直接把一个内置指针隐式转化为智能指针，必须使用直接初始化形式。<br>不要混合使用普通指针和智能指针，也不要使用get初始化另一个智能指针或者为智能指针赋值（C++ primer P413-414）<br>使用普通指针的时候遇到异常时普通指针会结束而跳过delete，智能指针会自动释放空间。<br>在创建一个智能指针之后可以传递一个指向删除器函数的参数，当函数以异常退出时，connection会被正确关闭，内置指针不会，在unique_ptr使用删除器的时候需要在尖括号中提供删除器类型，可以使用decltype(delete_fun)来指名函数指针类型，然后我们可以用一个*来指出哦我们正在使用该类型到一个指针。<br>在weak_ptr<int> wp(p)时因为wp是弱类型，所以p到引用计数未改变。</int></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线段树扫描线 矩形面积并+矩形周长并</title>
    <link href="http://www.winterfell30.com/2015/12/28/segment-sweep/"/>
    <id>http://www.winterfell30.com/2015/12/28/segment-sweep/</id>
    <published>2015-12-28T08:03:34.000Z</published>
    <updated>2016-11-23T08:09:29.743Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>###HDU1542 Atlantis (离散化+面积并模板)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MD 1000000007</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2222</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> X[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> l, r, h;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    seg() &#123;&#125;</span><br><span class="line">    seg(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c, <span class="keyword">int</span> d) :</span><br><span class="line">        l(a), r(b), h(c), s(d) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> seg&amp; cmp) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; cmp.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ss[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[rt]) sum[rt] = X[r+<span class="number">1</span>] - X[l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l == r) sum[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> L, <span class="keyword">double</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[rt] += c;</span><br><span class="line">        PushUp(rt, l, r);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L, R, c, lson);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; m) update(L, R, c, rson);</span><br><span class="line">    PushUp(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, ncase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> a, b, c, d;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">            X[m] = a;</span><br><span class="line">            ss[m++] = seg(a, c, b, <span class="number">1</span>);        <span class="comment">//down 1</span></span><br><span class="line">            X[m] = c;</span><br><span class="line">            ss[m++] = seg(a, c, d, <span class="number">-1</span>);       <span class="comment">//up -1</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(X, X + m);</span><br><span class="line">        sort(ss, ss + m);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (X[i] != X[i<span class="number">-1</span>]) X[k++] = X[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = lower_bound(X, X + k, ss[i].l) - X;</span><br><span class="line">            <span class="keyword">int</span> r = lower_bound(X, X + k, ss[i].r) - X - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) update(l, r, ss[i].s, <span class="number">0</span>, k - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            ret += sum[<span class="number">1</span>] * (ss[i+<span class="number">1</span>].h - ss[i].h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2f\n\n"</span>, ncase++, ret); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###HDU1828 Picture (周长并模板)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MD 1000000007</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">22222</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, h, s;</span><br><span class="line">    seg() &#123;&#125;</span><br><span class="line">    seg(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d) :</span><br><span class="line">        l(a), r(b), h(c), s(d) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> seg&amp; cmp) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == cmp.h) <span class="keyword">return</span> s &gt; cmp.s;</span><br><span class="line">        <span class="keyword">return</span> h &lt; cmp.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ss[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> lbd[maxn&lt;&lt;<span class="number">2</span>], rbd[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> numseg[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> len[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[rt]) </span><br><span class="line">    &#123;</span><br><span class="line">        lbd[rt] = rbd[rt] = <span class="number">1</span>;</span><br><span class="line">        len[rt] = r - l + <span class="number">1</span>;</span><br><span class="line">        numseg[rt] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        len[rt] = numseg[rt] = lbd[rt] = rbd[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lbd[rt] = lbd[rt&lt;&lt;<span class="number">1</span>];</span><br><span class="line">        rbd[rt] = rbd[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        len[rt] = len[rt&lt;&lt;<span class="number">1</span>] + len[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        numseg[rt] = numseg[rt&lt;&lt;<span class="number">1</span>] + numseg[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (lbd[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] &amp;&amp; rbd[rt&lt;&lt;<span class="number">1</span>]) numseg[rt] -= <span class="number">2</span>;   <span class="comment">//重叠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[rt] += c;</span><br><span class="line">        PushUp(rt, l, r);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L, R, c, lson);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; m) update(L, R, c, rson);</span><br><span class="line">    PushUp(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lbd = INF, rbd = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">            lbd = <span class="built_in">min</span>(lbd, a);</span><br><span class="line">            rbd = <span class="built_in">max</span>(rbd, c);</span><br><span class="line">            ss[m++] = seg(a, c, b, <span class="number">1</span>);</span><br><span class="line">            ss[m++] = seg(a, c, d, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ss, ss + m);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss[i].l &lt; ss[i].r) </span><br><span class="line">                update(ss[i].l, ss[i].r - <span class="number">1</span>, ss[i].s, lbd, rbd - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            res += numseg[<span class="number">1</span>] * (ss[i+<span class="number">1</span>].h - ss[i].h);</span><br><span class="line">            res += <span class="built_in">abs</span>(len[<span class="number">1</span>] - last);</span><br><span class="line">            last = len[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="题解" scheme="http://www.winterfell30.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>GitHub备忘</title>
    <link href="http://www.winterfell30.com/2015/12/14/github-use/"/>
    <id>http://www.winterfell30.com/2015/12/14/github-use/</id>
    <published>2015-12-14T15:57:41.000Z</published>
    <updated>2016-11-23T08:08:53.167Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>这个博客一直是在GitHub上托管的，然而用了这么久我还是不怎么会用GitHub。<br>今天push了前几天的离散上机作业，就当练习一下了，记录一下出现的问题以免以后忘记。<br>1.建立仓库，这个是在GitHub上进行的。<br>2.在本地要push的文件夹的根目录进行<code>git init</code>，然后会出现一个叫.git的隐藏文件。<br>3.<code>git add .</code>加载所有文件。.可以代替所有，也可以改成文件名变成加载单个文件。<br>4.<code>git commit -m &quot;init commit</code>提交文件,创建时间点以后回到这个时间点（虽然还没用过）。<br>5.<code>git status</code>可以随时查看状态。<br>6.<code>git remote add origin git@github.com:winterfell30/DM_Practice.git</code>添加远程的代码库到配置。<br>7.<code>git push origin master</code>，提交代码<br>这一步出现错误了，是因为之前remote add的时候在origin的后面加上了master，在push这一步的时候会提示：<br>fatal: ‘origin’ does not appear to be a git repository<br>以及fatal: Could not read from remote repository.<br>然后去掉master之后就好了，但是又有了新的错误，error:failed to push som refs to …….<br>不过这个错误是个很常见的错误，是因为版本不一致的原因，解决方案：<br>先输入<code>git pull origin master</code>,先把远程服务器github上面的文件拉下来。<br>再输入<code>git push origin master</code>推送上去就可以了。<br>然后我又在网站上直接了edit了README.md，就这样推送完毕了。   </p><p>值得一提的是VS2013可以直接推送代码到Git上面，虽然我还没试过，但是也许会比较方便。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="备忘" scheme="http://www.winterfell30.com/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>一本满足的线段树专题</title>
    <link href="http://www.winterfell30.com/2015/12/13/segtree-hh/"/>
    <id>http://www.winterfell30.com/2015/12/13/segtree-hh/</id>
    <published>2015-12-13T13:34:06.000Z</published>
    <updated>2016-11-23T08:09:33.895Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>因为连着两场比赛坑了线段树，所以我打算好好补一下线段树，我线段树的代码风格一直是学习HH神犇的，感觉很简洁，飘逸。<br>以下题目有些是HH神犇的专题里面的，有些是我在VJ上找的，自我感觉都是些还不错的题目。<br>因为以前写专题总是一次做完再写要写很久。。。所以这次边做边更。。。</p><p>###1.单点更新<br>线段树的单点更新比较简单，比赛中大都是用来配合其他类型题目来使用的（比如DP）。<br>所以虽然题目都比较简单，但是熟练使用还是挺重要的。</p><p>####HDOJ 1166 敌兵布阵<br>单点增减，区间求和。<br><a href="http://paste.ubuntu.com/13989936/" target="_blank" rel="noopener">AC代码链接</a></p><p>####HDOJ 1754 I Hate It<br>单点修改，区间求最值。<br><a href="http://paste.ubuntu.com/13989951/" target="_blank" rel="noopener">AC代码链接</a></p><p>####HDOJ 1394 Minimum Inversion Number<br>先用线段树求一下逆序数，然后把所有情况递推一下找到最大值就行了。<br>单点修改，区间求和。<br><a href="http://paste.ubuntu.com/13989991/" target="_blank" rel="noopener">AC代码链接</a></p><p>####HDOJ 2795 Billboard<br>求区间最大值，然后减去L，可以直接在query里面update。<br>单点修改，区间查询。<br><a href="http://paste.ubuntu.com/13990061/" target="_blank" rel="noopener">AC代码链接</a></p><p>####POJ 2352 Stars<br>以前用树状数组AC过，思路相同，线段树的区间从左到右为1~32000，一个一个插入。<br>单点修改，区间查询。<br><a href="http://paste.ubuntu.com/13990095/" target="_blank" rel="noopener">AC代码链接</a></p><p>###2.区间更新<br>区间更新使用了懒惰标记，不更新到节点使得效率更高。<br>关于懒惰标记不再赘述，注意在线段树操作的时候总是要PushDown，只有update的时候才需要PushUp。<br>在query里面的PushDown是将父节点没有传递下去的部分传下去，这里不是更新，是之前懒惰标记的更正。<br>PushUp是将子节点传给父节点，子节点的值没有变化，所以不需要PushUp。</p><p>####HDOJ 1698 Just a Hook<br>屠夫的钩子是铜的，可以把一段钩子变成金的或者银的，问最后总价值是多少。<br>区间替换，查询直接输出sum[root]就行了。<br><a href="http://paste.ubuntu.com/13990495/" target="_blank" rel="noopener">AC代码链接</a></p><p>####POJ 3468 A Simple Problem with Integers<br>给出一些数，可以把一个区间里面的数都增加一个数，求给出区间的和。<br>区间增添，区间查询。<br><a href="http://paste.ubuntu.com/13990255/" target="_blank" rel="noopener">AC代码链接</a></p><p>###3.扫描线<br>有时候会用到离散化。</p><p>###HDU1542 Atlantis<br>求矩形的面积并，横轴建树按y轴扫描就行了，cnt数组记录下边比上边多的条数。<br><a href="http://paste.ubuntu.com/14239653/" target="_blank" rel="noopener">AC代码链接</a></p><p>###HDU1828 Picture<br>求矩形的周长并，和面积不同的是横轴方向也要维护边的条数，而且要注意重叠的边。<br><a href="http://paste.ubuntu.com/14239656/" target="_blank" rel="noopener">AC代码链接</a></p><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="题解" scheme="http://www.winterfell30.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》摘要备忘（二）构造/析构/赋值</title>
    <link href="http://www.winterfell30.com/2015/11/12/Effective-C-2/"/>
    <id>http://www.winterfell30.com/2015/11/12/Effective-C-2/</id>
    <published>2015-11-12T15:43:43.000Z</published>
    <updated>2016-11-23T08:08:39.791Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>####Item5.了解C++默默编写并调用哪些函数<br>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。<br>当class的数据类型为reference或者const或者base class里面是private的时候，如果没有手动定义copy assignment且给他们进行了赋值行为，编译器将无视赋值的那行不进行编译。</p><p>####Item6.若不想使用编译器自动生成的函数，就该明确拒绝<br>接着上面的item5来说，当执行一些不该进行拷贝赋值的行为的时候，因为C++会自动给class添加copy assignment，所以本不应该被允许的还是被允许了。<br>由上面知道把复制构造函数和赋值函数声明为private可以阻止调用，但是还是很不安全，因为friend和member函数还是可以调用。<br>所以我们可以“将成员函数生命为private并且故意不实现他们”，这样如果有人调用的时候会获得一个连接错误。<br>这个技巧被大家接受，标准程序库实现码中的ios_base，basic_ios和sentry，copy函数和copy assignment操作符都被声明为private并且没有定义， 这个技巧实现起来也很简单。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">HomeForSale</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">HomeForSale(<span class="keyword">const</span> HomeForSale&amp;);    <span class="comment">//只有声明没有实现</span></span><br><span class="line">HomeForSale&amp; operator=(<span class="keyword">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>至于参数为空，既然没有实现，指定了也没有用，空着也是可以的。</p><p>上面提到当被调用的时候显示的连接错误，把错误从连接器转到编译器也是可能的（而且更早的侦测到错误是好事）。<br>只需将copy构造函数和copy assignment操作符声明为private，但是不是在HomeForSale自身，而是在一个专门为了阻止copying动作而设计的base class内，这个class非常简单：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Uncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:                           <span class="comment">//允许derived对象构造和析构</span></span><br><span class="line">Uncopyable() &#123;&#125;</span><br><span class="line">~Uncopyable() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);  <span class="comment">//但阻止copying</span></span><br><span class="line">Uncopyable&amp; operator=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>为了阻止HomeForSale对象被拷贝，我们只需要让其继承Uncopyable:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">HomeForSale: <span class="symbol">private</span></span> <span class="symbol">Uncopyable</span> </span><br><span class="line">&#123;</span><br><span class="line">...                             <span class="comment">//不要再声明copy函数和操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Boost库里面有个class名为uncopyable，就可以实现上面的功能。</p><p>####Item7.为多态基类声明virtual析构函数<br>在使用Factory函数的的时候直接用一个指针指向对象，为了遵守factory函数的规矩，为了避免泄漏和其他资源，将factory函数返回的每一个对象适当的delete掉是很重要的。<br>问题是指针是derived class对象，但是销毁是通过base class指针，而目前的base class有个non-virtual析构函数，所以结果就是base class被销毁，derived class却没有被销毁。这种局部销毁会形成资源泄漏等很多问题。<br>解决方案是给base class一个virtual析构函数，之后删除derived class对象就会得到想要的结果，销毁整个对象。<br>如果没想让这个类作为base class，就不要令其析构函数为virtual。无端的把析构函数声明为virtual，就像从未声明他们为virtual一样，都是错误的（原因是些计算机体系结构的东西，不再展开），许多人的心得就是：只有当class内含至少一个virtual函数时，才将它声明为virtual析构函数。<br>综上，给base class一个virtual析构函数，这个规则只适用于带多态性质的base class身上。这种设计的目的是为了用来通过base class接口处理derived class对象。但是并非所有base class的设计目的都是为了多态，他们不需要virtual析构函数。</p><p>####Item8.别让异常逃离析构函数<br>尽量不要让析构函数吐出(emit)异常，比如以下代码：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Widght</span> </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">~<span class="type">Widght</span>() <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">void</span> doSomething()</span><br><span class="line">&#123;</span><br><span class="line">std::vector&lt;<span class="type">Widght</span>&gt; v;</span><br><span class="line">...                  //v在这里被销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当vector被销毁时，它有责任销毁销毁所有Widght。假设v中有10个Widght，析构第一个元素期间，有个异常被抛出，，其他的Widght还是应该被销毁（否则会发生泄漏），因此应该每一个Widght调用一下析构函数，然后还会抛出一个异常，这对于C++来说太多了。<br>在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确行为，上例中即属于不明确行为。同理在其他的容器中也会出现相同情况，简而言之，在C++中不要让析构函数吐出异常。<br>如果析构函数必须执行一个动作，而该动作可能会抛出异常，该怎么办？假设用一个class负责数据库连接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;                <span class="comment">//关闭联机：失败则抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了确保客户不忘记调用close()，一个合理的想法是创建一个管理DBConnection资源的class,用其析构函数调用close()。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">DBConn</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">...</span><br><span class="line">~<span class="built_in">DBConn</span>()                    //确保数据库关闭</span><br><span class="line">&#123;</span><br><span class="line">db.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">private</span>:</span><br><span class="line"><span class="selector-tag">DBConnection</span> <span class="selector-tag">db</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户需要这样写：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">DBConn dbc(DBConnection<span class="type">::create</span>);  <span class="comment">//建立一个对象并且交给DBConn对象管理</span></span><br><span class="line"><span class="params">...</span>                                <span class="comment">//DBConn被销毁，自动调用close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>close()调用成功的话，一切都很好，但是如果调用异常，DBConn会传播异常，也就是允许它离开析构函数。那会造成很大的麻烦。<br>两个办法可以解决这个问题：<br>1.如果close抛出异常就结束程序。通常通过调用abort来完成<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line"><span class="keyword">catch</span> (...) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//制作运转记录，记录异常</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果程序遭遇析构时的异常就无法执行，强迫结束是个合理选择，abort可以制“不明确行为”于死地，阻止异常被传播出去。<br>2.吞下因调用close而发生的异常<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line"><span class="keyword">catch</span> (...) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//制作运转记录，记录异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般而言，吞下异常是个坏主意，，因为他忽略了某些重要信息。但是有时候吞下也比“草率结束程序”或者“不明确行为带来的奉献”好。<br>这种情况适用于程序可以继续可靠地执行，即使在忽略了一个错误之后。</p><p>这两种方法都没有什么吸引力。都无法对“close抛出异常”做出反应。<br>一个较佳策略是重新设计DBConn接口，使用户有机会对可能出现的问题做出反应。例如本身提供一个close函数，富裕客户一个机会处理“有可能发生的异常”。DBConn也可以追踪并且管理，如果析构函数调用close我们还是用上面两种方法。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>             <span class="comment">//供用户使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">db.<span class="built_in">close</span>();</span><br><span class="line"><span class="built_in">close</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">~DBConn()                    </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!closed)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span>              <span class="comment">//如果用户没关闭，则自动关闭连接</span></span><br><span class="line">&#123;</span><br><span class="line">db.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//制作运转记录，记录异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">DBConnection db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样把调用close的责任交给客户，这并不是推卸责任，如果某个操作会在失败时抛出异常，而又存在某种需要必须处理的异常，那么这个异常必须来自析构函数外的某个函数。客户自己调用close并不会有负担，这给了他们一个处理错误的机会。如果他们自信不会有异常，就可以忽略它，通过析构函数自动调用close()。</p><p>总结一下。<br>不要让析构函数吐出异常，如果有可能抛出异常，应该及时捕捉，结束程序或者吞下他们。<br>如果客户需要某个操作对异常做出反应，class应该提供一个普通函数执行操作。</p><p>####Item9.绝不在构造或者析构函数中调用virtual函数<br>绝不在构造或者析构函数中调用virtual函数，这样不会得到预想中的结果。<br>假设有这样一个类，用来记录交易的买进卖出的订单，每交易一次就要在审计日志中创建一个日志记录：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Transaction</span>               //<span class="symbol">Base</span> <span class="symbol">class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Transaction();</span><br><span class="line">virtual <span class="built_in">void</span> logTransction() <span class="keyword">const</span> = <span class="number">0</span>;    <span class="comment">//做出一个因类型不同而不同的记录</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction()   </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">logTransaction();                          <span class="comment">//构造函数的最后动作是记录这笔交易</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">BuyTransaction: <span class="symbol">public</span></span> <span class="symbol">Transaction</span>       //<span class="symbol">derived</span> <span class="symbol">class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">virtual <span class="built_in">void</span> logTransction() <span class="keyword">const</span> = <span class="number">0</span>;    <span class="comment">//记录这笔交易</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">SellTransaction: <span class="symbol">public</span></span> <span class="symbol">Transaction</span>      //<span class="symbol">derived</span> <span class="symbol">class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">virtual <span class="built_in">void</span> logTransction() <span class="keyword">const</span> = <span class="number">0</span>;    <span class="comment">//记录这笔交易</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在执行 :<br><figure class="highlight plain"><figcaption><span>b```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">无疑会有一个BuyTransaction构造函数被调用，但首先Transaction构造函数会更早被调用。</span><br><span class="line">所以问题就出现了，最先产生的logTransction()版本是base class的。</span><br><span class="line">是的，base class构造期间virtual函数不会下降到derived classes阶层。用比较非正式的话来说,在base class构造期间，virtual函数不是virtual函数。</span><br><span class="line">其实更加本质的原因就是在derived class对象的Base class构造期间，对象的类型是base的，不只是virtual会被解析至base class，若使用运行期类型信息（runtime type information,例如dynamic_cast(条款27)和typeid）也会把对象视为base类型。</span><br><span class="line">而且这样也是最合理的因为derived class函数执行之前还不是一个derived class，编译器最好的处理方式就是视他为不存在的。</span><br><span class="line">当base class有多个构造函数时，每个都要执行相同的动作，最优秀的方法就是把共同的代码放到一个初始化函数(init)中：</span><br></pre></td></tr></table></figure></p><p>class Transaction               //Base class<br>{<br>public:<br>    Transaction();<br>    { init(); }                                //调用non-virtual<br>    virtual void logTransction() const = 0;    //做出一个因类型不同而不同的记录<br>    …<br>private:<br>    void init()<br>    {<br>        …<br>        logTransction();                      //调用virtual<br>    }<br>};<br>但是这样依旧没能解决上面的问题，而且更加麻烦，因为他不会引起编译器或者连接器的抱怨，程序会正常运行，只留下你百思不解为什么建立的是一个Transaction的记录。<br>唯一能够避免的方法只有一个，确定构造函数和析构函数都没有调用virtual函数，并且他们调用的函数也没有调用。<br>这样就必须把logTransction()改成non-virtual的了，，单后要求derived class构造函数传递必要信息给Transaction构造函数，然后安全的调用non-virtual的logTransaction。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">explicit <span class="constructor">Transaction(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">logInfo</span>)</span>;</span><br><span class="line"><span class="keyword">virtual</span> void log<span class="constructor">Transction(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">logInfo</span>)</span> const = <span class="number">0</span>;      <span class="comment">//如今是个non-virtual函数</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="constructor">Transaction(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">logInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">log<span class="constructor">Transaction(<span class="params">logInfo</span>)</span>;                                               <span class="comment">//如今是个non-virtual调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> BuyTransaction: public Transaction </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"><span class="constructor">BuyTransaction(<span class="params">parameter</span>)</span></span><br><span class="line">: <span class="constructor">Transaction(<span class="params">createLogString</span>(<span class="params">parameter</span>)</span>)                          <span class="comment">//将log信息传给base class构造函数</span></span><br><span class="line">&#123;<span class="operator"> ... </span>&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">static std::<span class="built_in">string</span> create<span class="constructor">LogString(<span class="params">parameters</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意本例中的createLogString函数。比起在成员初始列内金鱼base class数据，利用辅助函数往往更加方便（也更可读）。令其为static，也就不可能意外指向“初期未成熟的BuyTransaction对象内尚未初始化的成员变量“。这很重要，因为我们最开始的问题(base构造期间无法将virtual下降到derived)就是因为有些成员变量处于未定义状态。</p><p>####Item10.令operator=返回一个reference to *this<br>为了实现连锁赋值（a = b = c = 0)，赋值操作符必须返回一个reference指向操作符的左侧实参,这是为class实现操作符时要遵守的协议。<br>这个协议不仅适用于等号，+=等各种复制相关运算也适用。<br>不过这只是个协议没有强制性，即使不遵守也不影响编译。但是这份协议被所有内置类型和标准库所遵守，除非有别的好的理由，不然还是标准化一些吧。</p><p>####Item11.在operator=中处理自我赋值<br>也许猛然看起来没有什么必要处理自我赋值，毕竟没有人会写“a = a”这种代码。<br>事实上我们写程序时经常不经意的进行自我赋值，主要有以下两种情况：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span>[i] = <span class="keyword">a</span>[j] <span class="comment"> //潜在的自我赋值(i和j相等时)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">*px</span> = *py    <span class="comment">//潜在的自我赋值(px和py恰巧指向同一个位置时)</span></span><br></pre></td></tr></table></figure><p>如果遵循item13和item14的忠告，你会使用对象来管理资源，这种情况下不用额外操心自我赋值，然而如果你尝试手动管理资源(比如写一个管理资源的class)，就有可能掉入陷阱，假设建立了一个class用来保存一个指针指向一个动态分配的位图(bitmap)：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Widght</span> </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Bitmap* pd;           <span class="comment">//指针指向一个heap分配得到的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个看起来合理但是并不安全的operator=代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widght::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widght&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> pb;                   <span class="comment">//停止使用当前的bitmap</span></span><br><span class="line">pb = <span class="keyword">new</span> Bitmap(*rhs.pb);    <span class="comment">//使用rhs's bitmap的复件</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果函数内的*this和rhs是同一个对象的话，delete就同时销毁了复件，最后指针指向了一个已经被删除的对象。<br>传统解决方案是使用一个证同测试：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widght::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widght&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">delete pb;                   <span class="comment">//停止使用当前的bitmap</span></span><br><span class="line">pb = new Bitmap(*rhs.pb);    <span class="comment">//使用rhs's bitmap的复件</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面提到了,如果这里出现了异常（内存不足或者copy构造函数异常），Widght会指向被删除的Bitmap。这会引起很多麻烦。<br>不过在这里，让operator=具备异常安全性往往会带来自我赋值安全性的回报。所以我们只要专心实现异常安全性就行了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widght::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widght&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">Bitmap *pOrig = pb;          <span class="comment">//记住原来的pb</span></span><br><span class="line">pb = <span class="keyword">new</span> Bitmap(*rhs.pb);    <span class="comment">//令pb指向*pb的一个复件</span></span><br><span class="line"><span class="keyword">delete</span> pOrig;                <span class="comment">//删除原先的pb</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样如果new抛出异常，pb保持原状，不过牺牲了一点效率。如果很关心效率，可以把前面用到的证同测试再放到前面，不过实际上“自我赋值”发生的频率非常低。<br>像上面那样手动排列语句的一个代替方案是，使用”copy and swap”技术，这个技术和异常安全性有密切关系，会在item29详细指出。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;      <span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Widght::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widght&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">Widget temp(rhs);            <span class="comment">//为rhs做一个副本</span></span><br><span class="line">swap(temp);                  <span class="comment">//将*this数据和上述复件的数据交换</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为直接以值为参数传递会产生副本，所以也可以直接简写为：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widght::<span class="keyword">operator</span>=(Widght rhs)    <span class="comment">//重点是这里的传递,rhs是个副本</span></span><br><span class="line">&#123;</span><br><span class="line">swap(rhs);                  <span class="comment">//将*this数据和上述复件的数据交换</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####Item12.复制对象时勿忘其每一个成分<br>当你声明自己的copy函数时，意思就是告诉编译器你并不喜欢缺省实现中的某些行为，编译器就像被冒犯了一样，会以一种奇怪的方式回敬，当你出错的时候他不会给你提醒。。。<br>加入有一个类，本来是完美无缺的，后来加入了一个新的成员变量，但是copying函数执行的是局部拷贝，也就是当你加入一个成员变量，必须要同时修改copy函数以及各种形式的operator=(这个容易忘)。如果你忘记了，编译器不太可能提醒你。<br>有时候即使看起来已经在copy函数加入了新加入的变量，也可能会出现问题，比如修改了derived class的copy函数之后，他们可以复制所有的derived class的成员变量，但是base class的一些就被忽略了。<br>所以我们在修改copy函数时要修改base class的，但是因为有些数据是private的，所以我们要调用base class的copy函数。<br>因为两个copying函数有着近乎相同的实现本体，，这可能会诱使你直接用一个copy函数调用另一个。但是实际上这样是很荒谬的。。。构造一个已经存在的对象有什么意义呢。如果发现copy构造函数和copy assignment有着相近的代码，消除重复的代码的做法是建立一个函数(init)给他们共同调用，这个策略可以防止代码无谓的重复。<br>总而言之，要确保copy函数包含了所有成员变量，尤其是base class中的。不要尝试用某个copying函数调用另一个copying函数，应该把共同机能放到第三个函数中，有他们共同调用。</p><p>以上为条款5-12（第二章）的摘要和一些需要注意的地方，本章内容较多，如果有不正确或者模糊的地方欢迎指正。</p><p><del>要挖坑了</del>。。。暂时不会再更新了。。。没什么开发经验现在看这个水平还是差些。。。以后再看的时候会填上的。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》摘要备忘（一）让自己习惯C++</title>
    <link href="http://www.winterfell30.com/2015/11/06/Effective-C-1/"/>
    <id>http://www.winterfell30.com/2015/11/06/Effective-C-1/</id>
    <published>2015-11-06T15:05:57.000Z</published>
    <updated>2017-04-22T07:53:18.618Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>####Item2.尽量以const,enum,inline代替#define<br>一直都知道这种说法现在才知道了原因到底是什么。</p><p>#####1.const<br>这要从#define和const的原理说起：<br>#define实际上是用被define的内容来直接替换到代码中，可以直接看成是字符串的替换，#define的问题所在就是#define不被视为语言的一部分，当你这样做时：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure></p><p>记号名称ASPECT_RATIO也许从来未被编译器看见。也许在编译器开始处理源码之前他就被预处理器移走了。于是ASPECT_RATIO有可能没进入记号表(symbol table)内。于是当你运用此常量但获得一个编译错误信息时，也许这个错误会提到1.653而不是ASPECT_RATIO。如果ASPECT_RATIO被定义在一个不是你自己写的头文件内，你肯定对这个数字毫无概念，于是你将因为追踪它而浪费时间，这个问题也可能出现在symbolic debugger中，原因相同：你所使用的名称可能并未进入记号表(symbol table)。<br>解决方法就是用常量来替换上述的#define：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> ASPECT_RATIO = <span class="number">1.653</span></span><br></pre></td></tr></table></figure></p><p>作为一个语言常量，ASPECT_RATIO肯定会被编译器看到，当然就会进入记号表内。此外对浮点常量而言，使用常量可能比使用#define导致较少量的码，因此预处理器“盲目的将宏ASPECT_RATIO替换1.653”可能导致目标码(object code)出现多份1.653，若改用常量就绝不会出现这种情况。</p><p>PS：我还记得之前做题的时候#define maxn 1&lt;&lt;16的时候结果就是TLE，而换成const int maxn = 1&lt;&lt;16;就可以AC，现在明白了一些作用机理，就拓展一下这两者在内存和时间上的区别吧。被define的内容是不分配内存的，他只是等着运行到某个地方的时候再用字符串替换的方式代入，每次代入都会分配一个内存，所以如果调用很多次的话就会分配很多无用的内存。而const的内容是被写入symbol table的，在定义的时候就分配了内存并计算好了值，调用的时候就直接使用了。</p><p>关于const，这里有两种特殊用法。</p><p>第一是定义常量指针，由于常量定义式通常被放在头文件内，因此有必要将指针（注意不只是指针所指之物）声明为const。<br>例如若在头文件内定义一个常量的char字符串，必须要const两次：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"winterfell30"</span>;</span><br></pre></td></tr></table></figure></p><p>不过要提醒一下的是string对象通常比char更合宜，所以往往定义成这样更好些:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">"winterfel30"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>第二是class专属常量。为了将常量的作用域限制于class内，你必须让它成为class的一个成员，而为确保常量至多只有一个实体，你必须让它成为一个static成员:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">GamePlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    static <span class="keyword">const</span> <span class="built_in">int</span> NumTurns = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">int</span> score[NumTurns];</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>顺带一提，我们无法利用#define创建一个class专属常量，因为#define并不重视作用域，即不能提供任何封装性。</p><p>#####2.enum<br>也许看完上面你会想#define要比const功能强的多，所以这里要引入enum back，有很多理由enum值得我们认识它。<br>第一，enum back的行为某方面更像#define而不是const，这时候正是你想要的。比如#define不会非必要的分配地址，enum也是这样，如果你不想让别人获得一个pointer或reference指向你的整数常量，enum可以帮你实现这个约束。<br>第二，enum非常实用，实际上enum back是template metaprogramming（模板元编程，后面会讲到）的基础技术。</p><p>#####3.inline<br>#define可以是一个函数，但是通常会很危险。你必须为所有的实参加上小括号，不然你不知道它被替换到代码中会变成什么样。<br>比如下面这个例子:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define add(a, b) a + b</span></span><br><span class="line"><span class="attr">sum</span> = add(a, b) * c<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>我们的本意是计算(a + b) <em> c，但是他变成了a + b </em> c。如果这个宏的头文件不是你写的话会给程序带来极高的不安全性。<br>还有一个经典的例子：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以a+b的较大值调用f()函数</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">CALL_WITH_MAX</span>(a, b) <span class="selector-tag">f</span>((a) &gt; (b)) ? (a) : (b))</span><br></pre></td></tr></table></figure></p><p>且不说这个的括号写的有多麻烦，即使是这个宏写的没有缺陷了在调用的时候仍会招惹麻烦。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="constructor">CALL_WITH_MAX(<span class="operator">++</span><span class="params">a</span>, 0)</span>;   <span class="comment">//a被累加两次</span></span><br><span class="line"><span class="constructor">CALL_WITH_MAX(<span class="operator">++</span><span class="params">a</span>, 10)</span>； <span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure></p><p>a的递增次数竟然取决于和谁比较（因为大于的时候提到了a两次）。。。不过我们不必为这个烦恼，inline完美解决：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了解决上面的问题之外，由于callWithMax是个真正的函数，他遵守作用域和访问规则，可以写一个class里面的private函数，而宏不可以。</p><p>综上，有了这三个我们对#define的需求降低了，但并非完全消除。#ifdef/#ifndef继续扮演着控制编译的重要角色，目前还不到预处理器引退的时候，但你应该尽可能少的用他们。</p><p>####Item3.尽可能使用const</p><p>面对指针时可以指出指针自身、指针所指物，或两者都（或都不）是const。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">char</span>* p = greeting;                //non-<span class="keyword">const</span> <span class="built_in">pointer</span>,non-<span class="keyword">const</span> data</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span>* p = greeting;          //non-<span class="keyword">const</span> <span class="built_in">pointer</span>,<span class="keyword">const</span> data</span><br><span class="line"><span class="built_in">char</span>* <span class="keyword">const</span> p = greeting;          //<span class="keyword">const</span> <span class="built_in">pointer</span>,non-<span class="keyword">const</span> data</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span>* <span class="keyword">const</span> p = greeting;    //<span class="keyword">const</span> <span class="built_in">pointer</span>,<span class="keyword">const</span> data</span><br></pre></td></tr></table></figure></p><p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性，举个例子：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Rational</span> <span class="meta">&#123;...&#125;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">Rational</span> operator* (<span class="keyword">const</span> <span class="type">Rational</span>&amp; lhs, <span class="keyword">const</span> <span class="type">Rational</span>&amp; rhs);</span><br></pre></td></tr></table></figure></p><p>我当初也不明白这个const的意义是什么，原因是防止客户这样做：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Rational</span> a, <span class="keyword">b, </span>c<span class="comment">;</span></span><br><span class="line">(a * <span class="keyword">b) </span>= c<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>一般不会有人这样给一个乘积赋值，但是实际编程中会经常出现的就是把==打成=,比如：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c) <span class="meta">&#123;...&#125;</span>         //其实本意只是比较</span><br></pre></td></tr></table></figure></p><p>如果a和b是内置类型，这样的代码就是不合法的，良好的用户自定义类型的特征就是避免无端的与内置类型不兼容（以后会讲），因此这个赋值操作也就没什么意义了，声明为const可以预防那个无意义的赋值动作。<br>两个成员函数如果只是常量性不同可以被重载。这是一个很重要的C++特性，在调用时选择是否加上const即可分别调用。</p><p>成员函数如果是const意味着什么？这有两个流行概念：bitwise constness和logical constness。<br>bitwise constness阵营的人相信成员函数要在不更改任何成员变量时才是const。<br>logical constness是由bitness constness的缺陷导出的，即一个成员函数可以修改它所处理的对象内的某些bits。<br>在const成员函数里面不能直接赋值给成员变量，这时候就需要引入与C++相关的摆动场：mutable（可变的），mutable释放掉non-static成员变量的bitwise constness约束。<br>关于bitwise constness和logical constness还有很多内容不再展开，感兴趣可以到网上查找相关资料。</p><p>当const和non-const成员函数有着实质相同的实现时，令non-const版本调用const版本可避免代码重复，两者之间可以通过转型(casting)完成。</p><p>const是个奇妙且非比寻常的东西，是个强大的助手，尽可能的多使用它。</p><p>####Item4.确认对象在被使用之前已经被初始化</p><p>这个条款在JAVA里面是被明确要求的，而在C++里面却没有，所以就加大了C++的不安全性。<br>在C++里面是否自动初始化也是不确定的，记住所有规则是不现实的，为了减少不愉快的调试过程我们应该永远在使用对象之前将它初始化。</p><p>重点是内置类型之外的东西，初始化的责任就要落在构造函数上面了。<br>初始化看起来很容易执行，重要的是别混淆了赋值和初始化。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">std::<span class="built_in">string</span> s;</span><br><span class="line">public:</span><br><span class="line"><span class="constructor">A(<span class="params">const</span> <span class="params">int</span>&amp; <span class="params">_a</span>, <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">_s</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="constructor">A(<span class="params">const</span> <span class="params">int</span>&amp; <span class="params">_a</span>, <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">_s</span>)</span>     <span class="comment">//这些都是赋值</span></span><br><span class="line">&#123;                                        <span class="comment">//而非初始化</span></span><br><span class="line">a = _a;</span><br><span class="line">s = _s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这样做的结果是正确的，但不是最佳做法。最好是使用成员初值列，通常这样效率会高很多。<br>C++有着十分固定的“成员初始化次序”。class的成员变量总是以其声明次序被初始化，虽然打乱顺序的初始化是合法的，但是为了避免出现一些可能存在的晦涩的错误，当你在成员初值列中条列各个成员时，最好总是以声明次序为次序。<br>（晦涩错误指的是一些需要初始化带有次序的情况，比如array需要先指定大小再赋值。）</p><p>为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</p><p>以上为前4个条款（第一章）的摘要和一些需要注意的地方，如果有不正确或者模糊的地方欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>常用代码</title>
    <link href="http://www.winterfell30.com/2015/10/24/usefrequently/"/>
    <id>http://www.winterfell30.com/2015/10/24/usefrequently/</id>
    <published>2015-10-24T02:12:50.000Z</published>
    <updated>2016-11-23T08:09:47.671Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>####输入输出外挂<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适用于正负数,(int,long long,float,double)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Read</span>(<span class="title">T</span> &amp;<span class="title">ret</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="keyword">int</span> sgn; T <span class="built_in">bit</span>=<span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">if</span>(c=getchar(),c==EOF) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'-'</span>&amp;&amp;c!=<span class="string">'.'</span>&amp;&amp;(!<span class="built_in">isdigit</span>(c))) c=getchar();</span><br><span class="line">sgn=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">ret=(c==<span class="string">'-'</span>)?<span class="number">0</span>:(c-<span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">while</span>(c=getchar(),<span class="built_in">isdigit</span>(c)) ret=ret*<span class="number">10</span>+(c-<span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">' '</span>||c==<span class="string">'\n'</span>)&#123; ret*=sgn; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">while</span>(c=getchar(),<span class="built_in">isdigit</span>(c)) ret+=(c-<span class="string">'0'</span>)*<span class="built_in">bit</span>,<span class="built_in">bit</span>/=<span class="number">10</span>;</span><br><span class="line">ret*=sgn;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####java的快速输入流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner cin = <span class="keyword">new</span> Scanner (<span class="keyword">new</span> BufferedInputStream(System.in));</span><br></pre></td></tr></table></figure></p><p>####手动加栈(慎用)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 放在头文件前面</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/STACK:1024000000,1024000000"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//G++ 放在主函数里面(汇编开栈不一定适用，和系统有关,需谨慎)</span></span><br><span class="line"><span class="keyword">int</span> __size__ = <span class="number">256</span>&lt;&lt;<span class="number">20</span>;     <span class="comment">//256MB</span></span><br><span class="line"><span class="keyword">char</span> *__p__ = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(__size__)+__size__;</span><br><span class="line">__asm__(<span class="string">"movl %0, %%esp\n"</span>::<span class="string">"r"</span>(__p__));</span><br></pre></td></tr></table></figure></p><p>####读取一行空格分割的整数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gets(buf);</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">char</span> *p = strtok(buf, <span class="string">" "</span>);</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(p, <span class="string">"%d"</span>, &amp;v);</span><br><span class="line">p = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####现场赛vim的简易配置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax on</span><br><span class="line"><span class="builtin-name">set</span> nu</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">tabstop</span>=4</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">shiftwidth</span>=4</span><br><span class="line">colo evening</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">mouse</span>=a</span><br><span class="line"><span class="builtin-name">set</span> cin</span><br></pre></td></tr></table></figure></p><p>####输出调试的模板<br><a href="http://paste.ubuntu.com/14024198/" target="_blank" rel="noopener">从quora上碰巧看到的输出调试模板</a></p><p>####数论常用定理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>素数定理:素数个数$\frac&#123;n&#125;&#123;ln(n)&#125;$</span><br><span class="line"><span class="number">2.</span>定理:设a &gt; <span class="number">1</span>, m,n &gt; <span class="number">0</span>,那么有$gcd(a^&#123;m<span class="number">-1</span>&#125;,a^&#123;n<span class="number">-1</span>&#125;) = a^&#123;gcd(m,n)&#125; - <span class="number">1</span>$</span><br><span class="line"><span class="number">3.</span>定理:设a &gt; b, gcd(a,b) = <span class="number">1</span>, 那么$gcd(a^m - b^m,a^n - b^n) = a^&#123;gcd(m,n)&#125; - b^&#123;gcd(m,n)&#125;$</span><br><span class="line"><span class="number">4.</span>定理:设$G(n) = gcd(C_&#123;(n,<span class="number">1</span>)&#125;,C_&#123;(n,<span class="number">2</span>)&#125;,....C_&#123;(n,n<span class="number">-1</span>)&#125;)$,那么</span><br><span class="line">    (<span class="number">1</span>)n为素数,那么G(n)是n</span><br><span class="line">    (<span class="number">2</span>)n为多个素因子,那么G(n)是<span class="number">1</span></span><br><span class="line">    (<span class="number">3</span>)n只有一个素因子,那么G(n)是该素因子</span><br><span class="line"><span class="number">5.</span>定理:设$F_n$为Fib数,那么有$gcd(F_m,F_n) = F_&#123;gcd(m,n)&#125;$</span><br><span class="line"><span class="number">6.</span>定理:给定两个互素的正整数A和B,那么它们最大不能组合的数为A*B-A-B,不能组合的数的个数为</span><br><span class="line">num = (A - <span class="number">1</span>)*(B - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="number">7.</span>定理:$\sum _&#123;i = <span class="number">1</span>&#125;gcd(i, N) = \sum _&#123;d|N&#125;phi[N/d]$</span><br><span class="line"><span class="number">8.</span>定理:$(n+<span class="number">1</span>)*lcm(C_&#123;(n,<span class="number">0</span>)&#125;,C_&#123;(n,<span class="number">1</span>)&#125;,...,C_&#123;(n,n<span class="number">-1</span>)&#125;,C_&#123;(n,n)&#125;) = lcm(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...,n+<span class="number">1</span>)$</span><br><span class="line"><span class="number">9.</span>定理:任何n个连续的正整数的乘积均可被n!整除</span><br><span class="line">两个推广结论:</span><br><span class="line">(<span class="number">1</span>)如果p是素数,那么$C_&#123;(p,<span class="number">1</span>)&#125;,C_&#123;(p,<span class="number">2</span>)&#125;...C_&#123;(p,p<span class="number">-1</span>)&#125;$均可被p整除</span><br><span class="line">(<span class="number">2</span>)如果p是素数,那么有$(x+y...+w) = (x^p + y^p + ... w^p)(mod p)$</span><br></pre></td></tr></table></figure></p><p>####常用矩阵运算<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">    Matrix()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) a[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp;B)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix C;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">                C.a[i][j] = (a[i][j] + B.a[i][j]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;B)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix C;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d; k++)</span><br><span class="line">                    C.a[i][j] = (C.a[i][j] + a[i][k] * B.a[k][j]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> ^ (<span class="keyword">const</span> <span class="keyword">int</span> &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix res, A = (*<span class="keyword">this</span>);</span><br><span class="line">        res.init();</span><br><span class="line">        <span class="keyword">int</span> p = t;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res = res * A;</span><br><span class="line">            A = A * A;</span><br><span class="line">            p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">sum</span><span class="params">(Matrix A, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> A;</span><br><span class="line">    Matrix res;</span><br><span class="line">    res.init();</span><br><span class="line">    res = res + (A ^ (k / <span class="number">2</span>));</span><br><span class="line">    res = res * sum(A, k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res + (A ^ k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####自适应辛普森<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r1, r2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span>                  <span class="comment">//计算x处的函数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> * <span class="built_in">sqrt</span>(r1 * r1 - x * x) * <span class="built_in">sqrt</span>(r2 * r2 - x * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><span class="comment">//三点Simpson法，这里要求F是一个全局函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c = a + (b - a) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (f(a) + <span class="number">4</span> * f(c) + f(b))*(b - a) / <span class="number">6.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asr</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> eps, <span class="keyword">double</span> A)</span><span class="comment">//自适应Simpson公式（递归过程）。已知整个区间[a,b]上的三点Simpson值A</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c = a + (b - a) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> L = simpson(a, c), R = simpson(c, b);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(L + R - A) &lt;= <span class="number">15</span> * eps)<span class="keyword">return</span> L + R + (L + R - A) / <span class="number">15.0</span>;</span><br><span class="line">    <span class="keyword">return</span> asr(a, c, eps / <span class="number">2</span>, L) + asr(c, b, eps / <span class="number">2</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asr</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> eps)</span> <span class="comment">//自适应Simpson公式（主过程）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asr(a, b, eps, simpson(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####高斯消元整数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];<span class="comment">//增广矩阵</span></span><br><span class="line"><span class="keyword">int</span> x[MAXN];<span class="comment">//解集</span></span><br><span class="line"><span class="keyword">bool</span> free_x[MAXN];<span class="comment">//标记是否是不确定的变元</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / gcd(a, b) * b;<span class="comment">//先除后乘防溢出</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，</span></span><br><span class="line"><span class="comment">//-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)</span></span><br><span class="line"><span class="comment">//有equ个方程，var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> equ,<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">int</span> max_r;<span class="comment">// 当前这列绝对值最大的行.</span></span><br><span class="line">    <span class="keyword">int</span> col;<span class="comment">//当前处理的列</span></span><br><span class="line">    <span class="keyword">int</span> ta,tb;</span><br><span class="line">    <span class="keyword">int</span> LCM;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> free_x_num;</span><br><span class="line">    <span class="keyword">int</span> free_index;</span><br><span class="line">    <span class="keyword">for</span>　(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= var; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] =<span class="number">0</span>;</span><br><span class="line">        free_x[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换为阶梯阵.</span></span><br><span class="line">    col = <span class="number">0</span>; <span class="comment">// 当前处理的列</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; equ &amp;&amp; col &lt;　var; k++, col++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 枚举当前处理的行.</span></span><br><span class="line"><span class="comment">// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)</span></span><br><span class="line">        max_r = k;</span><br><span class="line">        <span class="keyword">for</span> (i = k + <span class="number">1</span>; i &lt; equ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][col]) &gt; <span class="built_in">abs</span>(a[max_r][col])) max_r = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_r != k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 与第k行交换.</span></span><br><span class="line">            <span class="keyword">for</span>(j = col; j &lt; var + <span class="number">1</span>; j++) swap(a[k][j], a[max_r][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[k][col] == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 说明该col列第k行以下全是0了，则处理当前行的下一列.</span></span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = k + <span class="number">1</span>; i &lt; equ; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 枚举要删去的行.</span></span><br><span class="line">            <span class="keyword">if</span> (a[i][col] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LCM = lcm(<span class="built_in">abs</span>(a[i][col]), <span class="built_in">abs</span>(a[k][col]));</span><br><span class="line">                ta = LCM / <span class="built_in">abs</span>(a[i][col]);</span><br><span class="line">                tb = LCM / <span class="built_in">abs</span>(a[k][col]);</span><br><span class="line">                <span class="keyword">if</span>　(a[i][col] * a[k][col] &lt; <span class="number">0</span>) tb = -tb;<span class="comment">//异号的情况是相加</span></span><br><span class="line">                <span class="keyword">for</span>　(j = col; j &lt; var + <span class="number">1</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i][j] = a[i][j] * ta- a[k][j] * tb;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).</span></span><br><span class="line">    <span class="keyword">for</span> (i = k; i &lt; equ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i][col] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.</span></span><br><span class="line">    <span class="comment">// 且出现的行数即为自由变元的个数.</span></span><br><span class="line">    <span class="comment">// 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;var)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 首先，自由变元有var - k个，即不确定的变元至少有var - k个.</span></span><br><span class="line">        <span class="keyword">for</span> (i = k - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.</span></span><br><span class="line">            <span class="comment">// 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.</span></span><br><span class="line">            free_x_num = <span class="number">0</span>; <span class="comment">// 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;var; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] != <span class="number">0</span> &amp;&amp;free_x[j]) free_x_num++, free_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (free_x_num&gt; <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 无法求解出确定的变元.</span></span><br><span class="line">            <span class="comment">// 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.</span></span><br><span class="line">            temp = a[i][var];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; var; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] != <span class="number">0</span> &amp;&amp; j != free_index) temp -= a[i][j] * x[j];</span><br><span class="line">            &#125;</span><br><span class="line">            x[free_index] = temp / a[i][free_index]; <span class="comment">// 求出该变元.</span></span><br><span class="line">            free_x[free_index] = <span class="number">0</span>; <span class="comment">// 该变元是确定的.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var - k; <span class="comment">// 自由变元有var - k个.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.</span></span><br><span class="line">    <span class="comment">// 计算出Xn-1, Xn-2 ... X0.</span></span><br><span class="line">    <span class="keyword">for</span> (i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i][var];</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;var; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != <span class="number">0</span>) temp -= a[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp % a[i][i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// 说明有浮点数解，但无整数解.</span></span><br><span class="line">        x[i] = temp / a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####高斯消元浮点数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">double</span> a[MAXN][MAXN], x[MAXN];</span><br><span class="line"><span class="comment">//方程的左边的矩阵存在a中和等式右边的值存在x中，求解之后x存的就是结果</span></span><br><span class="line"><span class="keyword">int</span> equ, var;<span class="comment">//方程数和未知数个数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回-1无解</span></span><br><span class="line"><span class="comment">返回0唯一解</span></span><br><span class="line"><span class="comment">大于0多解，且返回自由变元个数</span></span><br><span class="line"><span class="comment">可以用free_x判断不确定的解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, col, max_r;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, col = <span class="number">0</span>; k &lt; equ &amp;&amp; col &lt; var; k++, col++)</span><br><span class="line">    &#123;</span><br><span class="line">        max_r = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; equ; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][col]) &gt; <span class="built_in">fabs</span>(a[max_r][col]))</span><br><span class="line">                max_r = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[max_r][col]) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != max_r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt;= var; j++)</span><br><span class="line">                swap(a[k][j], a[max_r][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[k][col]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = k + <span class="number">1</span>; i &lt; equ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][col]) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">double</span> temp = a[i][col] / a[k][col];</span><br><span class="line">            <span class="keyword">for</span> (j = col; j &lt;= var; j++)</span><br><span class="line">                a[i][j] -= a[k][j] * temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无解</span></span><br><span class="line">    <span class="keyword">for</span> (i = k; i &lt; equ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][col]) &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无穷解</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; var)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> free_num = <span class="number">0</span>;      <span class="comment">//变元个数</span></span><br><span class="line">            <span class="keyword">int</span> free_index;        <span class="comment">//变元</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][j]) &amp;&amp; free_x[j])</span><br><span class="line">                    free_num++, free_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (free_num &gt; <span class="number">1</span>)      <span class="comment">//有两个以上的变元无法确定</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">double</span> temp = a[i][n];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][j]) &amp;&amp; j != free_index)</span><br><span class="line">                    temp -= a[i][j] * x[j];</span><br><span class="line">            &#125;</span><br><span class="line">            x[free_index] = temp / a[i][free_index];</span><br><span class="line">            free_x[free_index] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var - k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = equ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> temp = a[i][n];</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; var; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][j]) != <span class="number">0</span>)</span><br><span class="line">                temp -= a[i][j] * x[j];</span><br><span class="line">        x[i] = temp / a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####高斯消元01方程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//有equ个方程，var个变元。增广矩阵行数为equ,列数为var+1,分别为0到var</span></span><br><span class="line"><span class="keyword">int</span> equ, var;</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN]; <span class="comment">//增广矩阵</span></span><br><span class="line"><span class="keyword">int</span> x[MAXN]; <span class="comment">//解集</span></span><br><span class="line"><span class="keyword">int</span> free_x[MAXN];<span class="comment">//用来存储自由变元（多解枚举自由变元可以使用）</span></span><br><span class="line"><span class="keyword">int</span> free_num;<span class="comment">//自由变元的个数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回值为-1表示无解，为0是唯一解，否则返回自由变元个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gauss</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_r, col, k;</span><br><span class="line">    free_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, col = <span class="number">0</span> ; k &lt; equ &amp;&amp; col &lt; var ; k++, col++)</span><br><span class="line">    &#123;</span><br><span class="line">        max_r = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; equ; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i][col]) &gt; <span class="built_in">abs</span>(a[max_r][col]))</span><br><span class="line">                max_r = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[max_r][col] == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            k--;</span><br><span class="line">            free_x[free_num++] = col;<span class="comment">//这个是自由变元</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_r != k) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col; j &lt; var + <span class="number">1</span>; j++)</span><br><span class="line">                swap(a[k][j], a[max_r][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; equ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][col] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = col; j &lt; var + <span class="number">1</span>; j++)</span><br><span class="line">                    a[i][j] ^= a[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; equ; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i][col] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无解</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; var) <span class="keyword">return</span> var - k;<span class="comment">//自由变元个数</span></span><br><span class="line">    <span class="comment">//唯一解，回代</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = a[i][var];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; var; j++)</span><br><span class="line">            x[i] ^= (a[i][j] &amp;&amp; x[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####组合数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n - m) m = n - m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans *= n - i;</span><br><span class="line">        ans /= i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####Lucas定理及逆元<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p;</span><br><span class="line">LL fact[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= p; i++)</span><br><span class="line">        fact[i] = fact[i<span class="number">-1</span>] * i % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex_gcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;d = a, x = <span class="number">1</span>, y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ex_gcd(b, a % b, y, x, d);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x, y, d;</span><br><span class="line">    ex_gcd(a, p, x, y, d);</span><br><span class="line">    <span class="keyword">return</span> d == <span class="number">1</span> ? (x % p + p) % p : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">q_mul</span><span class="params">(LL x, LL n, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    LL temp = x % p;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = (res + temp) % p;</span><br><span class="line">        temp = (temp + temp) % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">q_pow</span><span class="params">(LL x, LL n, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    LL temp = x % p;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * temp % p;</span><br><span class="line">        temp = temp * temp % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q_pow(x, p - <span class="number">2</span>);    <span class="comment">//只有p是质数时才能用快速幂求逆元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>　　　　　　　　　　　　　　<span class="comment">//递推预处理逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">        inv[i] = (mod - mod / i) * <span class="number">1L</span>L * inv[mod % i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fact[n] * inv(fact[m] * fact[n-m]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Lucas</span><span class="params">(LL n, LL m, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (C(n % p, m % p) * Lucas(n / p, m / p, p)) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####中国剩余定理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n个方程：x=a[i](mod m[i]) (0&lt;=i&lt;n)</span></span><br><span class="line"><span class="function">LL <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> n, LL a[], LL m[])</span>  <span class="comment">//互质</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL M = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL w = M / m[i];</span><br><span class="line">        ret = (ret + w * inv(w, m[i]) * a[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ret + M) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; pll;</span><br><span class="line"><span class="function">pll <span class="title">CRT2</span><span class="params">(LL A[], LL B[], LL M[], <span class="keyword">int</span> n)</span>      <span class="comment">//求解A[i]或x = B[i](mod M[i]),总共n个线性方程组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x = <span class="number">0</span>, m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a = A[i] * m;</span><br><span class="line">        LL b = B[i] - A[i]*x;</span><br><span class="line">        LL d = __gcd(M[i], a);</span><br><span class="line">        <span class="keyword">if</span>(b % d != <span class="number">0</span>)  <span class="keyword">return</span> MP(<span class="number">0</span>, <span class="number">-1</span>);      <span class="comment">//答案不存在，返回-1</span></span><br><span class="line">        LL t = b / d * inv(a / d, M[i] / d) % (M[i] / d);</span><br><span class="line">        x = x + m * t;</span><br><span class="line">        m *= M[i] / d;</span><br><span class="line">    &#125;</span><br><span class="line">    x = (x % m + m) % m;</span><br><span class="line">    <span class="keyword">return</span> MP(x, m);                           <span class="comment">//返回的x就是答案，m是最后的lcm值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####FFT<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i;</span><br><span class="line">    Complex() &#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) : r(r), i(i) &#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(r + t.r, i + t.i);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(r - t.r, i - t.i);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(r * t.r - i * t.i, r * t.i + i * t.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex y[], <span class="keyword">int</span> n, <span class="keyword">int</span> op)</span>                      <span class="comment">//op为1求DFT,op为-1求IDFT</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, k, t; i &lt; n; i++)                  <span class="comment">//rader二进制翻转</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, k = n &gt;&gt; <span class="number">1</span>, t = i; k; k &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">            j = j &lt;&lt; <span class="number">1</span> | t &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(y[i], y[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">2</span>, ds = <span class="number">1</span>; s &lt;= n; ds = s, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex wn = Complex(<span class="built_in">cos</span>(op * <span class="number">2</span> * PI / s), <span class="built_in">sin</span>(op * <span class="number">2</span> * PI / s));</span><br><span class="line">        Complex w = Complex(<span class="number">1</span>, <span class="number">0</span>), t;                     <span class="comment">//蝴蝶操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ds; k++, w = w * wn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i += s)</span><br><span class="line">            &#123;</span><br><span class="line">                y[i+ds] = y[i] - (t = w * y[i+ds]);</span><br><span class="line">                y[i] = y[i] + t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>)                                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            y[i].r /= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conv</span><span class="params">(Complex x1[], Complex x2[], <span class="keyword">int</span> n)</span>              <span class="comment">//求卷积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFT(x1, n, <span class="number">1</span>);</span><br><span class="line">    FFT(x2, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) x1[i] = x1[i] * x2[i];</span><br><span class="line">    FFT(x1, n, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####KMP<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> n, <span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; p[j] != p[i])</span><br><span class="line">            j = next[j];</span><br><span class="line">        i++, j++;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= n)</span><br><span class="line">            next[i] = next[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> n, <span class="keyword">char</span> *s, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">10005</span>];</span><br><span class="line">    getnext(p, n, next);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; p[j] != s[i])</span><br><span class="line">            j = next[j];</span><br><span class="line">        i++, j++;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####ST表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RMQ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> RMQ_size = maxn;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> MAX[RMQ_size][<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> MIN[RMQ_size][<span class="number">21</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = sz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            MAX[i][<span class="number">0</span>] = MIN[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        build_rmq();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_rmq</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX[i][j] = <span class="built_in">max</span>(MAX[i][j<span class="number">-1</span>], MAX[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">                MIN[i][j] = <span class="built_in">min</span>(MIN[i][j<span class="number">-1</span>], MIN[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">QueryMax</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= R - L + <span class="number">1</span>) k++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(MAX[L][k], MAX[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">QueryMin</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= R - L + <span class="number">1</span>) k++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(MIN[L][k], MIN[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s1, s2;</span><br></pre></td></tr></table></figure></p><p>####01Trie<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sigma_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line">    <span class="keyword">int</span> val[maxnode];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = ((x &amp; (<span class="number">1L</span>L &lt;&lt; i)) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!ch[<span class="built_in">step</span>][num])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(ch[tot], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[tot]));</span><br><span class="line">                val[tot] = <span class="number">0</span>;</span><br><span class="line">                ch[<span class="built_in">step</span>][num] = tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">step</span> = ch[<span class="built_in">step</span>][num];</span><br><span class="line">            val[<span class="built_in">step</span>] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">query</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = ((x &amp; (<span class="number">1L</span>L &lt;&lt; i)) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!ch[<span class="built_in">step</span>][num] || !val[ch[<span class="built_in">step</span>][num]]) num ^= <span class="number">1</span>;</span><br><span class="line">            res = res * <span class="number">2L</span>L + (LL)num;</span><br><span class="line">            <span class="built_in">step</span> = ch[<span class="built_in">step</span>][num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;trie;</span><br></pre></td></tr></table></figure></p><p>####Dinic网络流<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="keyword">int</span> dis[maxn];</span><br><span class="line">    <span class="keyword">int</span> cur[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; n = n;</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.push_back((Edge)&#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">        edges.push_back((Edge)&#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        m = edges.<span class="built_in">size</span>();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(s);</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge &amp;e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    dis[e.to] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                    q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge &amp;e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + <span class="number">1</span> == dis[e.to] &amp;&amp; (f = dfs(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[u][i]^<span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s; <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bfs())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += dfs(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>####二分图匹配<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i], w = match[v];</span><br><span class="line">        <span class="keyword">if</span> (w &lt; <span class="number">0</span> || (!vis[w] &amp;&amp; dfs(w)))</span><br><span class="line">        &#123;</span><br><span class="line">            match[v] = u;</span><br><span class="line">            match[u] = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit_match</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[v] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (dfs(v)) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####KM二分图最大权匹配(最小权取反即可)//n不等于m的时候要取max(n,m)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> Lx[maxn], Ly[maxn], slack[maxn];</span><br><span class="line">    <span class="keyword">int</span> left[maxn], right[maxn];</span><br><span class="line">    <span class="keyword">bool</span> S[maxn], T[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        g[u][v] += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        S[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = Lx[i] + Ly[j] - g[i][j];</span><br><span class="line">            <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">                T[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (left[j] == <span class="number">-1</span> || dfs(left[j])) &#123;</span><br><span class="line">                    left[j] = i;</span><br><span class="line">                    right[i] = j;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> slack[j] = <span class="built_in">min</span>(slack[j], tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (!T[i]) a = <span class="built_in">min</span>(a, slack[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (S[i]) Lx[i] -= a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (T[i]) Ly[i] += a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">km</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(left, <span class="number">-1</span>, <span class="keyword">sizeof</span>(left));</span><br><span class="line">        <span class="built_in">memset</span>(right, <span class="number">-1</span>, <span class="keyword">sizeof</span>(right));</span><br><span class="line">        <span class="built_in">memset</span>(Ly, <span class="number">0</span>, <span class="keyword">sizeof</span>(Ly));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Lx[i] = -INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                Lx[i] = <span class="built_in">max</span>(Lx[i], g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) slack[j] = INF;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(S, <span class="literal">false</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">                <span class="built_in">memset</span>(T, <span class="literal">false</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">                <span class="keyword">if</span> (dfs(i)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans += g[i][right[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>####最小费用流Dijkstra<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cap, cost, rev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[<span class="number">55</span>*<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">55</span>*<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">55</span>*<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> prevv[<span class="number">55</span>*<span class="number">55</span>], preve[<span class="number">55</span>*<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">55</span> * <span class="number">55</span>; i++)</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[u].push_back((Edge)&#123;v, cap, cost, G[v].<span class="built_in">size</span>()&#125;);</span><br><span class="line">    G[v].push_back((Edge)&#123;u, <span class="number">0</span>, -cost, G[u].<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span> (f &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        priority_queue&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, greater&lt;pii&gt; &gt; q;</span><br><span class="line">        <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        q.push(MP(<span class="number">0</span>, s));</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pii p = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> u = p.second;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &lt; p.first) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge &amp;e = G[u][i];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; <span class="number">0</span> &amp;&amp; dis[e.to] &gt; dis[u] + e.cost + h[u] - h[e.to])</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[e.to] = dis[u] + e.cost + h[u] - h[e.to];</span><br><span class="line">                    prevv[e.to] = u;</span><br><span class="line">                    preve[e.to] = i;</span><br><span class="line">                    q.push(MP(dis[e.to], e.to));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[t] == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++)</span><br><span class="line">            h[u] += dis[u];</span><br><span class="line">        <span class="keyword">int</span> d = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = prevv[u])</span><br><span class="line">            d = <span class="built_in">min</span>(d, G[prevv[u]][preve[u]].cap);</span><br><span class="line">        f -= d;</span><br><span class="line">        res += d * h[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = prevv[u])</span><br><span class="line">        &#123;</span><br><span class="line">            Edge &amp;e = G[prevv[u]][preve[u]];</span><br><span class="line">            e.cap -= d;</span><br><span class="line">            G[u][e.rev].cap += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####最小费用流SPFA<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cap, cost, rev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, V;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn], vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prevv[maxn], preve[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[from].push_back((Edge)&#123;to, cap, cost, G[to].<span class="built_in">size</span>()&#125;);</span><br><span class="line">    G[to].push_back((Edge)&#123;from, <span class="number">0</span>, -cost, G[from].<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (f &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        q.push(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            vis[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = G[u][i].to;</span><br><span class="line">                <span class="keyword">if</span> (G[u][i].cap &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u] + G[u][i].cost)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[v] = dis[u] + G[u][i].cost;</span><br><span class="line">                    prevv[v] = u;</span><br><span class="line">                    preve[v] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                    &#123;</span><br><span class="line">                        vis[v] = <span class="number">1</span>;</span><br><span class="line">                        q.push(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[t] == INF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = t; v != s; v = prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="built_in">min</span>(d, G[prevv[v]][preve[v]].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f -= d;</span><br><span class="line">        res += d * dis[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = t; v != s; v = prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            Edge &amp;e = G[prevv[v]][preve[v]];</span><br><span class="line">            e.cap -= d;</span><br><span class="line">            G[v][e.rev].cap += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####manacher<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[maxn], str[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx &gt; i) p[i] = <span class="built_in">min</span>(p[<span class="number">2</span>*id-i], mx - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i-p[i]] == str[i+p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; mx)</span><br><span class="line">            mx = i + p[i], id = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    str[l++] = <span class="string">'$'</span>;</span><br><span class="line">    str[l++] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[l++] = s[i];</span><br><span class="line">        str[l++] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str[l] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####后缀数组基排版<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[maxn], rk[maxn], <span class="built_in">height</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> c[maxn], t[<span class="number">2</span>][maxn], s[maxn];</span><br><span class="line"><span class="comment">//sa[0]是空的,注意s[n]要有值</span></span><br><span class="line"><span class="comment">//height是sa[i-1]和sa[i]的</span></span><br><span class="line"><span class="comment">//字符值在0-m-1之间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k, p, *x = t[<span class="number">0</span>], *y = t[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; m; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) sa[--c[x[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = n - k; i &lt; n; ++i) y[p++] = i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span>(sa[i] &gt;= k) y[p++] = sa[i] - k;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) ++c[x[y[i]]];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; m; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">        swap(x, y); p = <span class="number">1</span>; x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            x[sa[i]] = (y[sa[i - <span class="number">1</span>]] == y[sa[i]] &amp;&amp;</span><br><span class="line">                        y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k]) ? p - <span class="number">1</span> : p++;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= n) <span class="keyword">break</span>; m = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k--;</span><br><span class="line">        <span class="keyword">if</span>(!rk[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s[i + k] == s[j + k]) k++;</span><br><span class="line">        <span class="built_in">height</span>[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####后缀数组快排版<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> sa[maxn*<span class="number">2</span>], rk[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> temp[maxn*<span class="number">2</span>], lcp[maxn*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rk[i] != rk[j]) <span class="keyword">return</span> rk[i] &lt; rk[j];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ri = i + k &lt;= n ? rk[i+k] : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rj = j + k &lt;= n ? rk[j+k] : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ri &lt; rj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> *s, <span class="keyword">int</span> *sa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sa[i] = i;</span><br><span class="line">        rk[i] = i &lt; n ? s[i] : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(sa, sa + n + <span class="number">1</span>, compare_sa);</span><br><span class="line">        temp[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            temp[sa[i]] = temp[sa[i<span class="number">-1</span>]] + (compare_sa(sa[i<span class="number">-1</span>], sa[i]) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            rk[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lcp[i]是sa[i]和sa[i+1]的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> *s, <span class="keyword">int</span> *sa, <span class="keyword">int</span> *lcp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">0</span>) h--;</span><br><span class="line">        <span class="keyword">for</span> (; j + h &lt; n &amp;&amp; i + h &lt; n; h++)</span><br><span class="line">            <span class="keyword">if</span> (s[j+h] != s[i+h]) <span class="keyword">break</span>;</span><br><span class="line">        lcp[rk[i] - <span class="number">1</span>] = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####Splay<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Key_value ch[ch[root][1]][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], ch[maxn][<span class="number">2</span>], root, tot1;</span><br><span class="line"><span class="keyword">int</span> s[maxn], tot2;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> key[maxn];</span><br><span class="line"><span class="keyword">int</span> add[maxn];</span><br><span class="line"><span class="keyword">int</span> Min[maxn];</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//&lt;debug&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Treavel</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        Treavel(ch[x][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结点：%2d: 左儿子 %2d 右儿子 %2d 父结点 %2d size = %2d\n"</span>,x,ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>],pre[x],<span class="built_in">size</span>[x]);</span><br><span class="line">        Treavel(ch[x][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"root:%d\n"</span>, root);</span><br><span class="line">    Treavel(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&lt;/debug&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> &amp;r, <span class="keyword">int</span> fa, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tot2) r = s[tot2--];</span><br><span class="line">    <span class="keyword">else</span> r = ++tot1;</span><br><span class="line">    pre[r] = fa;</span><br><span class="line">    ch[r][<span class="number">0</span>] = ch[r][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Min[r] = k;</span><br><span class="line">    key[r] = k;</span><br><span class="line">    rev[r] = add[r] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">size</span>[r] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update_rev</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    swap(ch[r][<span class="number">0</span>], ch[r][<span class="number">1</span>]);</span><br><span class="line">    rev[r] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update_add</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    add[r] += val;</span><br><span class="line">    key[r] += val;</span><br><span class="line">    Min[r] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">size</span>[r] = <span class="built_in">size</span>[ch[r][<span class="number">0</span>]] + <span class="built_in">size</span>[ch[r][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">    Min[r] = <span class="built_in">min</span>(key[r], <span class="built_in">min</span>(Min[ch[r][<span class="number">0</span>]], Min[ch[r][<span class="number">1</span>]]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[r])</span><br><span class="line">    &#123;</span><br><span class="line">        Update_rev(ch[r][<span class="number">0</span>]);</span><br><span class="line">        Update_rev(ch[r][<span class="number">1</span>]);</span><br><span class="line">        rev[r] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (add[r])</span><br><span class="line">    &#123;</span><br><span class="line">        Update_add(ch[r][<span class="number">0</span>], add[r]);</span><br><span class="line">        Update_add(ch[r][<span class="number">1</span>], add[r]);</span><br><span class="line">        add[r] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    NewNode(x, fa, a[mid]);</span><br><span class="line">    Build(ch[x][<span class="number">0</span>], l, mid - <span class="number">1</span>, x);</span><br><span class="line">    Build(ch[x][<span class="number">1</span>], mid + <span class="number">1</span>, r, x);</span><br><span class="line">    PushUp(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root = tot1 = tot2 = <span class="number">0</span>;</span><br><span class="line">    ch[root][<span class="number">1</span>] = ch[root][<span class="number">0</span>] = pre[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">size</span>[root] = <span class="number">0</span>;</span><br><span class="line">    rev[root] = add[root] = <span class="number">0</span>;</span><br><span class="line">    Min[root] = INF;</span><br><span class="line">    NewNode(root, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    NewNode(ch[root][<span class="number">1</span>], root, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    Build(Key_value, <span class="number">0</span>, n - <span class="number">1</span>, ch[root][<span class="number">1</span>]);</span><br><span class="line">    PushUp(ch[root][<span class="number">1</span>]);</span><br><span class="line">    PushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> kind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = pre[x];</span><br><span class="line">    PushDown(y);</span><br><span class="line">    PushDown(x);  <span class="comment">//注意x和y的顺序</span></span><br><span class="line">    ch[y][!kind] = ch[x][   kind];</span><br><span class="line">    pre[ch[x][kind]] = y;</span><br><span class="line">    <span class="keyword">if</span> (pre[y])</span><br><span class="line">        ch[pre[y]][ch[pre[y]][<span class="number">1</span>] == y] = x;</span><br><span class="line">    pre[x] = pre[y];</span><br><span class="line">    ch[x][kind] = y;</span><br><span class="line">    pre[y] = x;</span><br><span class="line">    PushUp(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PushDown(r);</span><br><span class="line">    <span class="keyword">while</span> (pre[r] != goal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[pre[r]] == goal)</span><br><span class="line">        &#123;</span><br><span class="line">            PushDown(pre[r]);        <span class="comment">//有翻转操作需要先pushdown</span></span><br><span class="line">            PushDown(r);</span><br><span class="line">            Rotate(r, ch[pre[r]][<span class="number">0</span>] == r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            PushDown(pre[pre[r]]);   <span class="comment">//pushdown</span></span><br><span class="line">            PushDown(pre[r]);</span><br><span class="line">            PushDown(r);</span><br><span class="line">            <span class="keyword">int</span> y = pre[r];</span><br><span class="line">            <span class="keyword">int</span> kind = ch[pre[y]][<span class="number">0</span>] == y;</span><br><span class="line">            <span class="keyword">if</span> (ch[y][kind] == r)</span><br><span class="line">            &#123;</span><br><span class="line">                Rotate(r, !kind);</span><br><span class="line">                Rotate(r, kind);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Rotate(y, kind);</span><br><span class="line">                Rotate(r, kind);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PushUp(r);</span><br><span class="line">    <span class="keyword">if</span> (goal == <span class="number">0</span>) root = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_kth</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PushDown(r);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">size</span>[ch[r][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == k) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; k) <span class="keyword">return</span> Get_kth(ch[r][<span class="number">0</span>], k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Get_kth(ch[r][<span class="number">1</span>], k - t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_pre</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PushDown(r);</span><br><span class="line">    <span class="keyword">if</span> (ch[r][<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = ch[r][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (ch[r][<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        r = ch[r][<span class="number">1</span>];</span><br><span class="line">        PushDown(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_next</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PushDown(r);</span><br><span class="line">    <span class="keyword">if</span> (ch[r][<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = ch[r][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (ch[r][<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        r = ch[r][<span class="number">0</span>];</span><br><span class="line">        PushDown(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.ADD x y D </span></span><br><span class="line"><span class="comment">//2.REVERSE x y </span></span><br><span class="line"><span class="comment">//3.REVOLVE x y T </span></span><br><span class="line"><span class="comment">//4.INSERT x P </span></span><br><span class="line"><span class="comment">//5.DELETE x </span></span><br><span class="line"><span class="comment">//6.MIN x y </span></span><br><span class="line"><span class="comment">//x,y 为 区间[x,y]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Splay(Get_kth(root, l), <span class="number">0</span>);</span><br><span class="line">    Splay(Get_kth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    Update_add(Key_value, val);</span><br><span class="line">    PushUp(ch[root][<span class="number">1</span>]);</span><br><span class="line">    PushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">REVERSE</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Splay(Get_kth(root, l), <span class="number">0</span>);</span><br><span class="line">    Splay(Get_kth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    Update_rev(Key_value);</span><br><span class="line">    PushUp(ch[root][<span class="number">1</span>]);</span><br><span class="line">    PushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">REVOLVE</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    T = (T % len + len) % len;</span><br><span class="line">    Splay(Get_kth(root, r - T + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    Splay(Get_kth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    <span class="keyword">int</span> temp = Key_value;</span><br><span class="line">    Key_value = <span class="number">0</span>;</span><br><span class="line">    PushUp(ch[root][<span class="number">0</span>]);</span><br><span class="line">    PushUp(root);</span><br><span class="line">    Splay(Get_kth(root, l), <span class="number">0</span>);</span><br><span class="line">    Splay(Get_kth(root, l + <span class="number">1</span>), root);</span><br><span class="line">    Key_value = temp;</span><br><span class="line">    pre[temp] = ch[root][<span class="number">1</span>];</span><br><span class="line">    PushUp(ch[root][<span class="number">1</span>]);</span><br><span class="line">    PushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INSERT</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Splay(Get_kth(root, x + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    Splay(Get_kth(root, x + <span class="number">2</span>), root);</span><br><span class="line">    NewNode(Key_value, ch[root][<span class="number">1</span>], P);</span><br><span class="line">    PushUp(ch[root][<span class="number">1</span>]);</span><br><span class="line">    PushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> ;</span><br><span class="line">    s[++tot2] = r;</span><br><span class="line">    erase(ch[r][<span class="number">0</span>]);</span><br><span class="line">    erase(ch[r][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DELETE</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Splay(Get_kth(root, x), <span class="number">0</span>);</span><br><span class="line">    Splay(Get_kth(root, x + <span class="number">2</span>), root);</span><br><span class="line">    erase(Key_value);</span><br><span class="line">    pre[Key_value] = <span class="number">0</span>;</span><br><span class="line">    Key_value = <span class="number">0</span>;</span><br><span class="line">    PushUp(ch[root][<span class="number">1</span>]);</span><br><span class="line">    PushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Splay(Get_kth(root, l), <span class="number">0</span>);</span><br><span class="line">    Splay(Get_kth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    <span class="keyword">return</span> Min[Key_value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="模板" scheme="http://www.winterfell30.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>每周做题记录</title>
    <link href="http://www.winterfell30.com/2015/09/25/shuatijilu/"/>
    <id>http://www.winterfell30.com/2015/09/25/shuatijilu/</id>
    <published>2015-09-25T14:57:29.000Z</published>
    <updated>2017-01-22T03:29:13.767Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>仅供记录，每周五的晚上为两周之间的分隔线。</p><hr><p>退役了</p><p>#2016-11-11<br>各种DP过一遍<br>后缀数组<br>网络流费用流等<br>一些多校中等难度的题</p><p>#2016-09-23<br>网络赛什么的+补题<br>过于怠惰没有记录<br>POJ 3686 The Windy’s (最小费用流)<br>POJ 2175 Evacuation Plan (消负圈定理)<br>POJ 2135 Farm Tour (最小费用流)<br>POJ 3281 Dining (最小流)<br>POJ 3057 Evacuation (二分图匹配)<br>51Nod 1537 分解 (找规律)</p><p>#2016-08-26<br>ZOJ 2975 Kinds of Fuwas<br>Codeforces 707D - Persistent Bookcase<br>Codeforces 707A - Brain’s Photos<br>Codeforces 707C - Pythagorean Triples<br>Codeforces 707B - Bakery<br>Codeforces 703C - Chris and Road<br>703B - Mishka and trip</p><p>#2016-08-19<br>HDOJ 5867 Water problem<br>HDOJ 5862 Counting Intersections<br>HDOJ 5858 Hard problem<br>HDOJ 2196 Computer (树形DP)<br>HDOJ 5842 Lweb and String<br>HDOJ 5835 Danganronpa<br>HDOJ 5833 Zhu and 772002 (01高斯消元)<br>HDOJ 5832 A water problem<br>Codeforces 706D Vasiliy’s Multiset<br>Codeforces 706C Hard problem<br>P1039 最小差距<br>P1021 Victoria的舞会1</p><p>#2016-08-12<br>HDOJ 3094 A tree game (树上博弈)<br>Codeforces 705C - Thor<br>Codeforces 705A - Hulk<br>HDOJ 5807 Keep In Touch<br>HDOJ 5806 NanoApe Loves Sequence Ⅱ<br>HDOJ 5805 NanoApe Loves Sequence<br>HDOJ 5804 Price List</p><p>#2016-08-05<br>HDOJ 5754 Life Winner Bo<br>HDOJ 5795 A Simple Nim<br>HDOJ 5793 A Boring Question<br>HDOJ 5791 Two<br>HDOJ3537 Daizhenyang’s Coin<br>HDOJ3032 Nim or not Nim? (对SG打表找规律)<br>HDOJ2516 取石子游戏 (斐波那契模型)<br>HDOJ2147 kiki’s game<br>HDOJ1847 Good Luck in CET-4 Everybody!<br>HDOJ1846 Brave Game<br>HDOJ1564 Play a game (暴力打表找规律)<br>HDOJ1525 Euclid’s Game (YY)<br>HDOJ 1079 Calendar Game (考虑怎么让对面面临必输)<br>Codeforces 702C - Cellular Network<br>Codeforces 702E - Analysis of Pathes in Functional Graph<br>HDOJ 5768 Lucky7 (中国剩余定理+容斥)<br>HDOJ 5778 abs (注意细节处理)<br>HDOJ 5777 domino<br>HDOJ 5776 sum<br>HDOJ 5773 The All-purpose Zero (类似减下标的经典方法)</p><p>#2016-07-29<br>HDOJ 5763 Another Meaning<br>Codeforces 702B - Powers of Two<br>Codeforces 702A - Maximum Increase<br>HDOJ 5775 Bubble Sort<br>HDOJ 5774 Where Amazing Happens<br>Codeforces 701 E - Connecting Universities<br>HDOJ 5762 Teacher Bo (鸽巢原理)<br>HDOJ 5753 Permutation Bo (YY)<br>HDOJ 5752 Sqrt Bo (简单打表)<br>Codeforces 701 C - They Are Everywhere (two pointer)<br>Codeforces 701 B - Cells Not Under Attack (容斥要细心)<br>Codeforces 701 A - Cards<br>HDOJ 5750 Dertouzos<br>HDOJ 5748 Bellovin<br>HDOJ 5747 Aaronson</p><p>#2016-07-22<br>Codeforces 699C - Vacations<br>Codeforces 699B - One Bomb<br>Codeforces 699A - Launch of Collider<br>Topcoder 695 500<br>Topcoder 695 250<br>MultiUniversity 1011 Keep On Movin<br>MultiUniversity 1009 It’s All In The Mind<br>MultiUniversity 1004 GCD<br>MultiUniversity 1001 Abandoned country<br>Codeforces 689E - Mike and Geometry Problem (扫描)<br>Codeforces 689D - Friends and Subsequences (RMQ+二分)<br>Codeforces 697D - Puzzles (树形DP)<br>Codeforces 697C - Lorenzo Von Matterhorn<br>Codeforces 697B - Barnicle<br>Codeforces 697A - Pineapple Incident</p><p>#2016-07-16<br>HDOJ 2473 Junk-Mail Filter (并查集删除)<br>HDOJ 1558 Segment set<br>NYOJ 119 士兵杀敌（三） (RMQ)<br>Codeforces 691B - s-palindrome<br>Codeforces 691A - Fashion in Berland<br>Codeforces 689C - Mike and Chocolate Thieves<br>Codeforces 689B - Mike and Shortcuts<br>Codeforces 689A - Mike and Cellphone<br>HDOJ 3938 Portal (离线并查集)<br>HDOJ 1811 Rank of Tetris (并查集+topo)<br>HDOJ xxxx A Bug’s Life (种类并查集)</p><p>#2016-07-08<br>Codeforces 688 E - The Values You Can Make<br>Codeforces 688 D - Remainders Game<br>Codeforces 688 C - NP-Hard Problem<br>Codeforces 688 B - Lovely Palindromes<br>Codeforces 688 A - Opponents<br>POJ 1717 Dominoes (DP)<br>UVa 10014 Simple calculations (高中数学)<br>HDOJ 4911 Inversion (归并排序求逆序)<br>Codeforces 686 D Kay and Snowflake (树的重心)<br>Codeforces 686 C Robbers’ watch (枚举)<br>Codeforces 686 B Little Robber Girl’s Zoo<br>Codeforces 686 A Free Ice Cream</p><p>#2016-06-24<br>Topcoder 693 500<br>Topcoder 693 250<br>LightOJ 1056 Olympics<br>LightOJ 1053 Higher Math<br>51Nod 1672 区间交</p><p>#2016-06-17<br>Codeforces 681A A Good Contest<br>LightOJ 1051 Good or Bad (不错的DP)<br>LightOJ 1050 Marbles<br>LightOJ 1049 One Way Roads<br>Codeforces 678 E - Another Sith Tournament<br>Codeforces 678 D - Iterated Linear Function<br>Codeforces 678 C - Joty and Chocolate<br>Codeforces 678 B - The Same Calendar<br>Codeforces 678 A - Johny Likes Numbers<br>LightOJ 1036 A Refining Company<br>蜜汁没有记录= =</p><p>#2016-06-10<br>51Nod 1259 整数划分 V2<br>HDOJ 4651 Partition (五边形定理)<br>POJ 1273 Drainage Ditches (最大流)<br>省赛正式赛<br>省赛热身赛</p><p>#2016-06-03<br>HDOJ 2457 DNA repair (AC自动机+DP)<br>HDOJ 1757 A Simple Math Problem<br>POJ 3580 SuperMemo (Splay)<br>Codeforces 677 C Vanya and Label<br>Codeforces 677 A Vanya and Fence<br>LightOJ 1319 Monkey Tradition (裸CRT)<br>HDOJ 5411 CRB and Puzzle (矩阵加一维求和！！！)<br>POJ 3420 Quad Tiling (瓷砖问题+矩阵快速幂)<br>POJ 2663 Tri Tiling<br>POJ 2411 Mondriaan’s Dream (瓷砖问题)<br>POJ 2486 Apple Tree (树形背包)<br>POJ 3140 Contestants Division<br>POJ 1655 Balancing Act<br>POJ 2378 Tree Cutting (和上题差不多)<br>POJ 3107 Godfather (树形DP两次dfs)<br>HDOJ 3586 Information Disturbing  (二分树形DP)<br>HDOJ 4003 Find Metal Mineral (树形背包)<br>ZOJ 3947 Very Happy Great BG<br>ZOJ 3946 Highway Project (SPFA)<br>ZOJ 3944 People Counting (yy)<br>ZOJ 3939 The Lucky Week (找周期+周期内模拟)<br>ZOJ 3938 Defuse the Bomb (写模拟的时候不要走神= =)<br>ZOJ 3936 Apples and Ideas</p><p>#2016-05-27<br>Codeforces 676 E - The Last Fight Between Human and AI (数学)<br>Codeforces 676 D - Theseus and labyrinth (bfs)<br>Codefroces 676 C - Vasya and String<br>Codeforces 676 B - Pyramid of Glasses<br>Codeforces 676 A - Nicholas and Permutation<br>POJ 1155 TELE (树形背包)<br>HDOJ 2196 Computer (经典题)<br>HDOJ 2476 String painter (问题的转换)<br>Codeforces 149D Coloring Brackets (很细节的区间DP)<br>ZOJ 3469 Food Delivery (区间DP)<br>HDOJ 2955 Brackets (区间DP)<br>HDOJ 2520 Anniversary party (树形DP)<br>ZOJ 3537 Cake (凸包＋最优三角剖分)<br>HDOJ Cake (YY容斥)<br>CDOJ 594 我要长高 (单调队列优化DP)<br>CDOJ 1353 柱爷与子序列<br>百度之星 Gym Class<br>百度之星 BD String<br>百度之星 D Game<br>百度之星 Sitting in Line<br>百度之星 All X<br>HDOJ 5255 魔法因子 (枚举)</p><p>#2016-05-20<br>CDOJ 1347 柱爷的矩阵<br>CDOJ 1345 柱爷抢银行II<br>CDOJ 1349 柱爷大战滑稽王<br>CDOJ 1323 柱爷的下凡<br>CDOJ 1357 柱爷与最大区间和<br>CDOJ 1348 柱爷与咸鱼神功<br>HDOJ 1430 魔板 (bfs+映射)<br>CDOJ Problem　E 吴队长征婚 (剪枝)<br>POJ 2891 Strange Way to Express Integers (CRT2)<br>Codeforces 675D Tree Construction (splay)<br>Codeforces 675C Money Transfers　(贪心)<br>Codeforces 675B Restoring Painting　<br>Codeforces 675A Infinite Sequence ()<br>HDOJ 1573 X问题 (余数不互质的中国剩余定理)<br>POJ 1006 Biorhythms (中国剩余定理)<br>数学建模比赛真是太麻烦了QAQ<br>百度之星 资格赛</p><p>#2016-05-13<br>Codeforces 672D Robin Hood　(二分姿势不熟练)<br>Codeforces 672C Recycling Bottles　(想清楚了再写)<br>Codeforces 672B Different is Good　<br>Codeforces 672A Summer Camp (不要自己加难度)<br>POJ 1811 Prime Test (Miller-Robin+Pollard_rho模板题)<br>HDOJ 1792 A New Change Problem (定理题)<br>HDOJ 2582 f(n) (YY+找规律)<br>HDOJ 4349 Xiao Ming’s Hope (Lucas的证明过程)<br>BZOJ 1798 [Ahoi2009]维护序列seq (两个标记的线段树)<br>CDOJ 1325 卿学姐与基本法 (离散化区间修改)<br>HDOJ 3037 Saving Beans (Lucas定理)<br>Codeforces 451D - Count Good Substrings (简单组合数)<br>Codeforces 451C - Predict Outcome of the Game (枚举+YY)<br>Codeforces 451B - Sort the Array<br>Codeforces 451A - Game With Sticks<br>Codeforces 673D - Bear and Two Paths (贪心构造)<br>Codeforces 673C - Bear and Colors　(草草草傻逼题)<br>Codeforces 673B - Problems for Round<br>Codeforces 673A - Bear and Game<br>Codeforces 11D - A Simple Task (状压DP)<br>Codeforces 16E - Fish　(状压dp)<br>Codeforces 114B    - PFAST Inc.　(枚举)<br>Codeforces 27B - Tournament　(dfs)</p><p>#2016-05-06<br>Codeforces 635D - Factory Repairs (树状数组)<br>Codeforces 635C - XOR Equation (数学+YY)<br>Codeforces 635A - Orchestra (不要犯弱智错误)<br>Codeforces 670E - Correct Bracket Sequence Editor (双向链表)<br>Codeforces 670D2 - Magic Powder - 2 (同上题)<br>Codeforces 670D1 - Magic Powder - 1 (小数据也要注意爆ll!!!)<br>Codeforces 670C - Cinema<br>Codeforces 670B - Game of Robots (注意边界)<br>Codeforces 670A - Holidays ()<br>POJ 2722 Angle and Squares (中学数学)<br>URAL 1091 Tmutarakan Exams (DP和容斥都可做)<br>HDOJ 1796 How many integers can you find (简单容斥)<br>Codeforces 664B - Rebus (贪心构造)<br>BZOJ 2342 双回文串　(manacher+YY)<br>Codeforces 667D - World Tour (最短路枚举)<br>Codeforces 667C - Reberland Linguistics　(DP)<br>Codeforces 667B - Coat of Anticubism ()<br>Codeforces 667A - Pouring Rain ()<br>HDOJ 5677  ztr loves substring    (manacher+dp)<br>HDOJ 5676  ztr loves lucky numbers (dfs)<br>POJ XXX Sunscreen (优先队列+贪心)<br>POJ XXX Stall Reservations (优先队列+贪心)<br>POJ XXX Radar Installation　(最少点覆盖区间)<br>POJ XXX　Cleaning Shifts (最小区间覆盖) </p><p>#2016-04-29<br>POJ 3233 Matrix Power Series (经典递归)<br>Codeforces 148D Bag of mice (概率DP)<br>POJ 3071 Football (概率dp)<br>Codeforces 669E Little Artem and Time Machine (离散化树状数组)<br>Codeforces 669D Little Artem and Dance (脑洞)<br>Codeforces 669C Little Artem and Matrix (模拟)<br>SDUT 2878 Circle (高斯消元)<br>SGU 275 To xor or not to xor (贪心＋高斯消元)<br>POJ 1681 Painter’s Problem (高斯消元枚举变元)<br>POJ 1222 EXTENDED LIGHTS OUT (枚举)<br>POJ 1830 开关问题 (01高斯消元)<br>Codeforces 282E - Sausage Maximization (Trie)<br>UJN校赛 I Missing Pages<br>UJN校赛 H Round Robin<br>UJN校赛 E Letter<br>UJN校赛 D Stamps<br>UJN校赛 C A Game<br>UJN校赛 B 果园<br>UJN校赛 A BALL<br>BNU校赛 A Check In </p><p>#2016-04-22<br>HDOJ 5672 String (two point)<br>HDOJ 5671 Matrix (YY)<br>HDOJ 5670 Machine (YY)<br>SDUT 2622 最短路径 (二维dis数组的SPFA)<br>～SDUT 一整套大水题。。。～<br>CDOJ 秋实大哥搞算数<br>CDOJ 卿学姐与公主<br>SDUT Devour Magic (线段树区间增加和修改)<br>ZOJ 3329 One Person Game (有回路的概率DP)<br>ZOJ 3240 Help Me Escape (概率DP记忆化搜索)<br>HDOJ 3853 LOOPS (注意无解的情况)<br>POJ 2096 Collecting Bugs (概率DP)<br>HDOJ 4405 Aeroplane chess (朴素概率dp)<br>NJUST校赛 G 琪露诺的算术教室 (模拟加法)<br>NJUST校赛 F sequence (STL)<br>NJUST校赛 C count_prime    (容斥)<br>NJUST校赛 J water1<br>NJUST校赛 A 偷吃糖果 (签到)<br>HDOJ 5666  Segment (高精度或者快速加)<br>HDOJ 5665  Lucky (YY)<br>PKU Coins (多重背包，跑了2985ms。。。)<br>HDOJ 饭卡 (简单01背包＋特判！！！)</p><p>#2016-04-15<br>HDOJ Advanced Fruits (LCS加简单方案输出)<br>PKU Alignment　(LIS)<br>ZOJ 2050 Flip Game (状态压缩暴力搞的，上次做这个是用的dfs枚举步数)<br>Codeforces 430D Working out (预处理然后搞搞搞)<br>Codeforces 430C Xor-tree (想清楚性质然后dfs)<br>Codeforces 430B Balls Game (扫描注意细节)<br>Codeforces 276D Little Girl and Maximum XOR (上周bc几乎是这个的原题= =)<br>HDU 1172 猜数字　(枚举数字+check)<br>GDUT校赛 F.我是好人4 (dfs＋容斥)<br>GDUT校赛 C.wintermelon的魔界寻路之旅 (最短路＋dp求方案数)<br>GDUT校赛 B.Sward Art Online (枚举)<br>GDUT校赛 A.Krito的讨伐　(优先队列模拟)<br>Vijos 1037 搭建双塔　(枚举背包大小判断可行或者DP)<br>Vijos 1314 开心的金明<br>GDUT校赛 E.积木积水　(栈维护)<br>GDUT校赛 D.二叉树的中序遍历　(YY一下就行了)<br>GDUT校赛 G.我是水题 (确实是水题)<br>Codeforces 290A - Mysterious strings (逗比题)<br>COJ 1213 二叉树结点公共祖先<br>COJ 1212 中位数<br>HDOJ 5661 Claris and XOR (按位贪心)<br>HDOJ 5660 jrMz and angles (水)<br>GCJ Problem A. Counting Sheep (模拟＋set判重)<br>Vijos 1071 新年趣事之打牌　(01背包记录路径)<br>Codeforces 660 D - Number of Parallelograms (简单统计)<br>Codeforces 660 C - Hard Process　(双指针加前缀和找区间)<br>Codeforces 660 B - Seating On Bus　<br>Codeforces 660 A - Co-prime Array </p><p>#2016-04-08<br>HDOJ 1712　ACboy needs your help (简单分组背包)<br>POJ 1787　Charlie’s Change　(多重背包记录路径)<br>HDOJ 2712　The Cow Lineup　(机智的扫描)<br>HDOJ 2191　珍惜现在，感恩生活　(多重背包)<br>HDOJ 2159　FATE　(二维费用完全背包)<br>LightOJ 1062 N Queen Again (状压DP+八皇后预处理)<br>LightOJ 1061 Crossed Ladders (二分答案注意上界)<br>POJ 2063 Investment (离散化(伪)完全背包)<br>HDOJ 1114 Piggy-Bank (简单完全背包)<br>POJ 3624 Charm Bracelet (简单01背包)<br>HDOJ 2602 Bone Collector (简单01背包)<br>HDOJ 2955 Robberies (01背包)<br>LightOJ 1046 Rider (bfs)<br>LightOJ 1047 Neighbor House (水递推)<br>LightOJ 1045 Digits of Factorial (数学)<br>HDOJ 5655 CA Loves Stick (很坑的一题)<br>HDOJ 5656 CA Loves GCD (DP)</p><p>#2015-04-01<br>LightOJ 1044 Palindrome Partitioning (暴力DP)<br>LightOJ 1043 Triangle Partitioning (简单数学)<br>LightOJ 1042 Secret Origins (乱搞，其实直接在原数上操作写起来要更简单)<br>LightOJ 1041 Road Construction (最小生成树)<br>Codeforces 658D - Bear and Polynomials (YY+枚举)<br>Codeforces 658C - Bear and Forgotten Tree 3 (坑死了。。)<br>Codeforces 658B - Bear and Displayed Friends<br>Codeforces 658A - Bear and Reverse Radewoosh<br>Codeforces 652B - z-sort<br>Codeforces 652A - Gabriel and Caterpillar<br>NJUPT 1039 加分二叉树 (树上DP转化为区间DP)<br>HDOJ 5652  India and China Origins (二分答案bfs判断 ps:模拟要谨慎。。。)<br>HDOJ 5651  xiaoxin juju needs help (求逆元)<br>HDOJ 5650  so easy<br>POJ 1463 Strategic game (简单树形DP)</p><p>#2015-3-25<br>HDOJ 2412 Party at Hali-Bula (树形DP好题)<br>LightOJ 1037 Agent 47 (状压DP+记忆化搜索)<br>LightOJ 1039 A Toy Company (bfs)<br>LightOJ 1038 Race to 1 Again (简单期望递推)<br>LightOJ 1035　Intelligent Factorial Factorization (简单质因数分解)<br>LightOJ 1034 Hit the Light Switches (最小点基注意dfs的遍历)<br>队内训练 第八届河南省程序设计比赛<br>CodeForces 580C    Kefa and Park　(dfs就好了)<br>CodeForces 115A    Party　(找树的最长链)<br>CodeForces 445A    DZY Loves Chessboard (二分图染色)<br>CodeForces 500A    New Year Transportation　(shui)<br>POJ 1426 Find The Multiple (dfs)<br>HDOJ 1241 Oil Deposits (水)<br>51Nod 1232 完美数 (数位DP)<br>Codeforces 55D　(数位DP好题)<br>LightOJ 1140 (和上个差不多)<br>LightOJ 1032 Fast Bit Calculations (数位DP)<br>HDOJ 3709 Balanced Number<br>HDOJ 3652 &amp;&amp; POJ 某题 (数位DP)<br>HDOJ 3555　<br>HDOJ 2089<br>HDOJ 5<br>HDOJ 5</p><p>#2015-3-18<br>LightOJ 1033 Generating Palindromes (区间DP)<br>BNUOJ 4048 地大的楼梯 (裸斐波那契，DP水过)<br>LightOJ 1031 Easy Game (区间DP)<br>LightOJ 1030 Discovering Gold (期望DP)<br>LightOJ 1029 Civil and Evil Engineer (最小&amp;最大生成树)<br>LightOJ 1028 Trailing Zeroes (I) (唯一素数分解定理)<br>LightOJ 1027 A Dangerous Maze (解方程求期望)<br>LightOJ 1026 Critical Links (找森林的割边注意序号)<br>LightOJ 1025 The Specials Menu (经典区间DP，注意用好可以得到的)<br>Codeforces #344 C　Report　(同时间戳＋贪心)<br>Codeforces #344 B　Print Check　(时间戳的运用)<br>Codeforces #344 A Interview (水)<br>LightOJ 1024 Eid (高精度＋枚举质因子求LCM)<br>LightOJ 1023 Discovering Permutations (简单DFS)<br>LightOJ 1022 Circle in Square (简单几何)<br>LightOJ 1021 Painful Bases (状压数位DP)<br>LightOJ 1020 A Childhood Game (简单博弈)<br>HDOJ 5643 King’s Game (递推或者打表)<br>HDOJ 5642 King’s Order (四个状态滚动的DP)<br>HDOJ 5641 King’s Phone (模拟)<br>HDOJ 5640 King’s Cake (水)</p><p>#2015-03-11<br>LightOJ 1019 Brush (V)     (裸最短路)<br>LightOJ 1018 Brush (IV) (带有预处理的状压DP)<br>LightOJ 1017 Brush (III) (带有预处理的DP)<br>LightOJ 1016 Brush (II) (set硬搞)<br>LightOJ 1015 Brush (I)<br>LightOJ 1014 Ifter Party (枚举因子)<br>LightOJ 1013 Love Calculator (不错的DP)<br>LightOJ 1012 Guilty Prince (BFS)<br>LightOJ 1011 Marriage Ceremonies (状压DP)<br>LightOJ 1010 Knights in Chessboard (YY+特殊情况处理)<br>Codeforces #345E Table Compression (YY+并查集维护)<br>Codeforces #345D Image Preview (二分答案判断)<br>Codeforces #345C Watchmen (容斥)<br>Codeforces #345B Beautiful Paintings (YY)<br>Codeforces #345A Joysticks （注意细节)<br>HDOJ 5638 Toposort (拓扑变形)<br>HDOJ 5637 Transform (观察+bfs)<br>HDOJ 5636 Shortest Path (枚举)<br>HDOJ 5635 LCP Array (YY)<br>LightOJ 1009 Back to Underworld (二分图染色)<br>LightOJ 1008 Fibsieve`s Fantabulous Birthday (找规律)<br>LightOJ 1007 Mathematically Hard (欧拉函数)<br>LightOJ 1006 Hex-a-bonacci (矩阵快速幂)<br>LightOJ 1005 Rooks (组合数)<br>LightOJ 1004 Monkey Banana Problem (数塔)<br>LightOJ 1003 Drunk (拓扑排序)<br>LightOJ 1002 Country Roads (dijkstra改一下)<br>LightOJ 1001 Opposite Task (水)<br>LightOJ 1000 Greetings from LightOJ</p><p>#2015-03-04<br>POJ 2686 Traveling by Stagecoach (状态压缩DP)<br>POJ 2627 Gopher and hawks (最短路)<br>POJ 2488 A Knight’s Journey (字典序输出bfs路径)<br>POJ 1639 Picnic Planning (最小k限度生成树)<br>POJ 3723 Conscription (Kruskal求最大生成树)<br>POJ 3255 Roadblocks (dijkstra求次短路)</p><p>#2015-02-26<br>POJ 3320 Jessica’s Reading Problem (two point)<br>POJ Subsequence (two point)<br>POJ 1308 Is It A Tree? (并查集)<br>POJ 1703 Find them, Catch them (类别并查集)<br>Experimental Educational Round (13/18不想做了。。。)<br>HDU 1890 Robotic Sort (Splay区间翻转)<br>POJ 3468 A Simple Problem with Integers (Splay区间更新)<br>51Nod 1254 最大子段和 V2 (利用前缀后缀的DP)<br>51Nod 1461 稳定桌 (滑窗枚举+multiset维护最大值)<br>[HNOI2002]BZOJ1588 营业额统计 (splay找前驱后继)<br>HDOJ 5631 Rikka with Graph (并查集判联通)<br>HDOJ 5630 Rikka with Chess</p><p>#2015-02-19<br>51Nod 1732 51nod婚姻介绍所 (递推一下就行了)<br>51Nod 1376 最长递增子序列的数量 (DP+统计)<br>51Nod 1451 合法三角形 (极角排序+扫描)<br>51Nod 1126 求递推序列的第N项 (矩阵快速幂水过)<br>51Nod 1487 占领资源 (预处理+YY)<br>51Nod 1201 整数划分 (YY+DP)<br>51Nod 1460 连接小岛 (贪心+multiset)<br>~Codeforces 8VC Venture Cup F Group Projects (DP)~<br>Codeforces 8VC Venture Cup E Simple Skewness (三分+YY)<br>Codeforces 8VC Venture Cup D Jerry’s Protest (枚举)<br>Codeforces 8VC Venture Cup C Block Towers (YY)<br>Codeforces 8VC Venture Cup B Cards (枚举)<br>Codeforces 8VC Venture Cup A Robot Sequence<br>NYOJ 571 整数划分 (集合版)<br>51Nod 1084 矩阵取数问题 V2 (多线程DP)<br>NYOJ 61 传纸条（一）(多线程DP)<br>HDOJ 5627 Clarke and MST<br>HDOJ 5626 Clarke and points<br>HDOJ 5625 Clarke and chemistry</p><p>#2015-02-12<br>vijos P1112 小胖的奇偶 (并查集+哈希)<br>vijos P1083 小白逛公园 (线段树)<br>vijos P1132 求二叉树的先序序列 (构造)<br>vijos P1114 FBI树 (建树)<br>vijos P1066 弱弱的战壕 (BIT)<br>HDOJ 5622 KK’s Number (YY)<br>HDOJ 5621 KK’s Point (机智的转换)<br>HDOJ 5620 KK’s Steel</p><p>#2015-02-05<br>vijos P1062 迎春舞会之交谊舞<br>vijos P1034 家族 (裸并查集)<br>Codeforces 624C - Graph and String (构造)<br>Codeforces 624B - Making a String<br>Codeforces 624A - Save Luke<br>PKU 3295 Tautology (枚举)<br>PKU 2139 Six Degrees of Cowvin Bacon (floyd)<br>UVa 10870 Recurrences (构造矩阵加速递推)<br>UVa 11077 Find the Permutations (置换)<br>UVa 10294 Arif in Dhaka (First Love Part 2) (Polya)<br>Codeforces 621E Wet Shark and Blocks (数位DP矩阵快速幂加速)<br>Codeforces 621C Wet Shark and Flowers (逗比了)<br>Codeforces 621B Wet Shark and Bishops (递推)<br>Codeforces 621A Wet Shark and Odd and Even<br>51Nod 1405 树的距离之和 (树形DP)<br>HDU 1215 七夕节 (枚举因子因为大意傻逼了好几发)<br>PKU 2181 Jumping Cows (递推，分治思想简化问题)<br>HDU 5617 Jam’s maze (DP)<br>HDU 5616 Jam’s balance (01背包)<br>HDU 5615 Jam’s math problem (枚举)<br>Codeforces 618C - Constellation (被网上随便找的代码板坑哭了)<br>Codeforces 618B - Guess the Permutation<br>Codeforces 618A - Slime Combining</p><p>#2015-01-29<br>Topcoder 680 div2 500 (扫描)<br>Topcoder 680 div2 250<br>POJ 1503 Integer Inquiry<br>POJ 2262 Goldbach’s Conjecture<br>POJ 1083 Moving Tables (注意输入不一定是理想化的)<br>POJ 2739 Sum of Consecutive Prime Numbers<br>POJ 2159 Ancient Cipher<br>POJ 3299 Humidex<br>//需要暂时的离开数论了<br>HDOJ 1695 GCD (莫比乌斯反演入门)<br>UVa 10692 Huge Mods (欧拉定理+递归)<br>UVa 11728 Alternate Task (暴力枚举因子打表)<br>HDOJ 1576 A/B (公式变形+拓展欧几里得)<br>ZOJ 3593 One Person Game (拓展欧几里得+YY)<br>ZOJ 3609 Modular Inverse (拓展欧几里得求乘法逆元)<br>UVa 10763 Play with Floor and Ceil (拓展欧几里得)<br>LA 5092 Permutation Counting (DP)<br>Codeforces 617D - Polyline (各种细节)<br>Codeforces 617C - Watering Flowers (枚举)<br>Codeforces 617B - Chocolate (贪心注意特殊数据)<br>Codeforces 617A - Elephant<br>HDOJ 5612 Baby Ming and Matrix games<br>HDOJ 5611 Baby Ming and phone number<br>HDOJ 5610 Baby Ming and Weight lifting<br>UVa 11481 Arrange the Numbers (枚举+错排)</p><p>#2015-01-22<br>PKU 3321 Apple Tree (DFS序+树状数组)<br>Codeforces 620E    New Year Tree (DFS序+线段树)<br>Codeforces 620C    Pearls in a Row (贪心)<br>Codeforces 620B Grandfather Dovlet’s calculator<br>Codeforces 620A    Professor GukiZ’s Robot<br>NYOJ 524 A-B problem (水字符串)<br>NYOJ 128 前缀式计算 (stringstream练习)<br>Topcoder 679 div2 250 (论临时数组的好用)<br>HDU xxxx 胜利大逃亡(续) (状态压缩bfs)<br>POJ xxxx Flip Game (dfs)<br>51Nod 1639 系鞋带<br>POJ 2309 BST<br>HDU 2117 Just a Numble<br>HDU 3711 Binary Number<br>HDU 3006 The Number of set<br>POJ 2453 An Easy Problem<br>UVa 11645 Bits (位运算)<br>LA 3357 Pinary (递推)<br>LA 4094 Magnetic Train Tracks (和上题相似，注意精度)<br>UVa 11529 Strange Tax Calculation (极角排序+滑窗)<br>LA 3295 Counting Triangles (容斥+递推)<br>LA 5846 Neon Sign (组合数学)<br>UVa 3720 Highways (递推)<br>UVa 10883 Supermean (组合数+对数防溢出)<br>UVa 10253 Series-Parallel Networks (树上的递推)<br>UVa 11361 Investigating Div-Sum Property (数位DP)<br>UVa 1362 Exploring Pyramids (区间DP)<br>UVa 11137 Ingenuous Cubrency (递推)</p><p>#2015-01-15<br>Codeforces 614C Peter and Snow Blower<br>Codeforces 614B Gena’s Code<br>Codeforces 614A Link/Cut Tree<br>Codeforces 616C The Labyrinth<br>Codeforces 616B Dinner with Emma<br>Codeforces 616A Comparing Two Long Integers<br>FaceBook Hackcup Qualification<br>HDU 1285 确定最短路径<br>HDU 2544 最短路<br>HDU 1408 盐水的故事 </p><p>#2015-01-08<br>ZJU 1002 Fire Net (暴力搜索)<br>GitHug 前三十题2333<br>Codeforces xB Letter A (有点麻烦的几何，考完试整理一下所有几何模板)<br>Codeforces xB Correct Solution? (水，写麻烦了，很多时候swap能好用)<br>Codeforces xB Cinema Cashier (枚举)<br>Codeforces xB Obsession with Robots (YY)<br>HDU 1565 方格取数(1) (状态压缩DP)<br>PKU 3714 Error Curves (三分裸题)<br>PKU 3311 Hie with the Pie (经典状态压缩DP)<br>PKU 3984 迷宫问题 (BFS记录路径)<br>HDU 2553 N皇后 (…额)<br>HDU 4091 Zombie’s Treasure Chest (带LCM剪枝的枚举)<br>HDU 5606 tree (并查集)<br>HDU 5605 geometry (YY)</p><p>#2015-01-01<br>Codeforces GoodBye2015<br>51Nod 博弈论专题的一些小题<br>51Nod的一些简单题<br>HDU 1828 Picture (扫描线求矩形周长交)<br>HDU 1542 Atlantis (扫描线求矩形面积交)<br>Codeforces 610C Harmony Analysis (有意思的构造)<br>Codeforces 610B Vika and Squares (long long！)<br>Codeforces 610A Pasha and Stick (英语捉急)<br>Codeforces 500C New Year Book Reading (贪心)<br>Codeforces 500B New Year Permutation (Floyd找可达矩阵)<br>Codeforces 500A New Year Transportation<br>Codeforces 612D The Union of k-Segments (扫描线)<br>Codeforces 612C Replace To Make Regular Bracket Sequence<br>Codeforces 610C HDD is Outdated Technology<br>Codeforces 612A The Text Splitting<br>Codeforces 146C Lucky Conversion (贪心)<br>Codeforces 110C Lucky Sum of Digits (贪心)<br>51Nod 1449 砝码称重 (进制思想)<br>51Nod 1182 完美字符串 (水)<br>51Nod 1435 位数阶乘 (枚举+机智)<br>51Nod 1414 冰雕 (YY)<br>51Nod 1421 最大MOD值 (类似筛法的DP)<br>51Nod 1043 幸运号码 (数位DP)<br>51Nod 1456 小K的技术 (连通图个数+拓扑判环)</p><p>#2015-12-25<br>Codeforces 607B Zuma (区间DP)<br>Codeforces 607A Chain Reaction (简单DP)<br>Codeforces 608B Hamming Distance Sum (前缀)<br>Codeforces 608A    Saitama Destroys Hotel (贪心)<br>51Nod 数袋鼠好有趣 (贪心)<br>51Nod 最小公倍数挑战 (YY)<br>51Nod 0和5<br>51Nod 权势二进制<br>51Nod 最大M字段和 (简单滑窗DP)<br>电路课程设计GG。。。<br>Codeforces 609C - Load Balancing (考虑要周全)<br>Codeforces 609B - The Best Gift<br>Codeforces 609A - USB Flash Drives<br>四级要挂了<br>Codeforces 102CHomework (pair)<br>Codeforces 102B Sum of Digits (暴力即可)<br>Codeforces 102A Clothes</p><p>#2015-12-18<br>Codeforces 5C Longest Regular Bracket Sequence (经典栈模拟+DP)<br>Codeforces 5B Center Alignment<br>Codeforces 5A Chat Server’s Outgoing Traffic<br>51nod 1052 最大M字段和 (DP)<br>POJ 3667 Hotel (区间合并)<br>斐波那契递推+二进制一的个数+翻转链表<br>POJ 3225 Help with Intervals (线段树区间修改)<br>POJ 2528 Mayor’s posters (有点特殊的离散化+线段树区间修改)<br>POJ 1984 Navigation Nightmare (二维带权并查集)<br>POJ 1308 Is It A Tree? (简单并查集)<br>POJ 3468 A Simple Problem with Integers (区间添加求和)<br>HDOJ 1698 Just a Hook (区间替换求和)<br>POJ 2352 Stars (水线段树)<br>HDOJ 2795 Billboard (把update和query集合起来了)<br>HDOJ 1394 Minimum Inversion Number<br>HDOJ 1754 I Hate It (简单RMQ)<br>HDOJ 1166 敌兵布阵 (开线段树！！！)<br>POJ 1182 食物链 (并查集，元素之间的关系)<br>POJ 2236 Wireless Network (并查集)<br>HDOJ 5597 GTW likes function (打表找规律)<br>HDOJ 5596 GTW likes gt (YY题)<br>HDOJ 5595 GTW likes math (逗比题)<br>HDOJ 5524 Subtrees (递归分治)<br>Codeforces 4D Mysterious Present (暴力)<br>Codeforces 4C Registration system (交题不能太随意= =)<br>Codeforces 4B Before an Exam (刚开始题意理解错了，后来修修补补WA了八次才过。。。)<br>Codeforces 3D Least Cost Bracket Sequence (贪心+优先队列模拟)<br>Codeforces 3B Lorry (贪心枚举，花式WA。。。)<br>BNUOJ 字幕旋转游戏 (蛇形填数升级版)</p><p>#2015-12-11<br>CodeForces 3A Shortest path of the king （水构造）<br>POJ 2069 Super Star (模拟退火)<br>CodeForces 2B The least round way (感觉这个DP不错，注意0，注意细节)<br>CodeForces 2A Winner (map水题，要仔细考虑好再做)<br>Codeforces 335D Lazy Student (构造+最小生成树)<br>Codeforces 335C Sorting Railway Cars (见过好多次的经典题)<br>Codeforces 335A Magic Spheres (水题)<br>CodeForces 270C Magical Boxes (二分+基础数学)<br>CodeForces 270B Multithreading (水题，见过几次了)<br>CodeForces 270A Fancy Fence (考验基础尝试的数学)<br>Codeforces 1C Ancient Berland Circus (计算几何)<br>UVa 11426 GCD - Extreme (II) (欧拉函数+筛法)<br>LA 4119 Always an integer (模拟+差分数列)<br>Codeforces 1B Spreadsheets (模拟，注意细节)<br>UVa 11375 Matches (递推+高精度)<br>UVa 11806 Cheerleaders (容斥+位运算)<br>UVa 11538 Chess Queen (加法原理)<br>HDU 4497 GCD LCM<br>UVa 11461 Square Numbers<br>UVa 10791 Minimum Sum LCM<br>UVa 11489 Integer Game<br>UVa 2889 Palindrome Numbers<br>UVa 11609 Teams<br>UVa 11076 Add Again<br>UVa 11752 The Super Powers<br>UVa 10892 LCM Cardinality<br>LA 3305 Tour (经典DP,dp[i][j]表示走得快的走了i，走得慢的走了j)<br>HDU 5592 ZYB’s Premutation (区间修改点统计)<br>HDU 5591 ZYB’s Game (简单博弈的变形)<br>HDU 5590 ZYB’s Biology (水题)<br>LA 4726 Average (斜率优化+单调队列)<br>UVa 11054 Wine trading in Gergovia (扫描水题)<br>HDU 1043 Eight (A*寻路+Contor展开)<br>UVa 10391 Compound Words (STL水过，注意有重复的单词)</p><p>#2015-12-4<br>UVa 19181 Foreign Exchange (水检索)<br>HDU 1043 Eight (Contor展开+BFS)<br>HDU 1800 Flying to the Mars (简单字符串hash)<br>POJ 3349 Snowflake (hash，或者整体排序)<br>HDU 1496 Equations (简单Hash)<br>HDU 1425 sort (简单Hash)<br>LA 10827 Maximum sum on a torus (降维+前缀和)<br>LA 3963 Hypertransmission (扫描+YY)<br>LA 3621 Power Calculus (DFSID+剪枝)<br>UVa 10825 Anagram and Multiplication (YY+爆搜)<br>LA 3507 Keep the Customer Satisfied (贪心+优先队列,上一题的变形)<br>LA 2757 Supermarket (贪心+并查集,fa[i]为截止为i时最靠后的日期,用!=EOF超时,用==1就过了)<br>LA 3303 Songs (贪心，相邻比较法证明)<br>LA 4636 Cubist Artwork (经典，水贪心)<br>LA 4094 Wonder Team (构造,贪心)<br>UVa 10943 How do you add? (DP)<br>UVa 19198 Again Prime? No Time. (分解质因子)<br>UVa 11889 Benefit (枚举)<br>UVa 11389 The Bus Driver Problem (贪心)<br>UVa 1450 Airport (二分+贪心)<br>UVa 11388 GCD LCM (水)<br>LA 2965 Jurassic Remains (位运算的集合运算，中途相遇法降低复杂度)<br>UVa 10755 Garbage Heap (降维,扫描，机智的二进制运用)<br>LA 3695 Distant Galaxy (枚举，线性扫描)<br>HDOJ 5587 (递推，一定要把递推的每个过程都想清楚)<br>HDOJ 5586 (傻逼了。。。不要盲目相信经验。。就因为随手的改动卡了一场比赛)<br>HDOJ 5585 (水)<br>LA 3029 City Game (也是扫描法，偏DP的思维)</p><p>###2015-11-27<br>LA 2678 Subsequence (常见的两个指针的O(n)循环)<br>LA 3905 Meteor (扫描法，找到什么有用什么没用才能真正简化题目)<br>UVa 11549 Calculator Conundrum (Set判重556ms, Floyd判圈216ms)<br>ZJU 1007 Numerical Summation of a Series (纯数学题。。。实在做不动。。。看题解过的)<br>UVa 11078 Open Credit System (想清楚要的是什么，有些东西就算求出来也是多余的)<br>UVa 11462 Age Sort (水)<br>POJ 2774 Long Long Message (后缀数组入门题，求最长公共子串)<br>POJ 1625 Censored! (AC自动机+高精度+DP)<br>QUT 1042 A Pretty Girl (KMP被我用substr水过去了。。。)<br>QUT 1040 Board (YY)<br>QUT 1037 XiaoCai (水)<br>HDOJ 2243 HDOJ 2243 考研路茫茫——单词情结 (AC自动机+矩阵快速幂，矩阵加一维求和真是机智)<br>HDOJ 5504 GT and sequence (WA到死，细节题)<br>HDOJ 5569 matrix (简单DP)<br>HDOJ 5568 sequence2 (简单DP+高精度)<br>HDOJ 5567 sequence1 (大水题，因为手快多交了一发QAQ)<br>POJ 2778 DNA Sequence (AC自动机+矩阵快速幂(注意爆int问题))<br>ZOJ 3430 Detect the Virus (重在解码过程，注意数组大小和char数组要用unsigned)</p><p>###2015-11-20<br>HDU 3065 病毒侵袭持续中 (上一题再稍微修改一下)<br>HDU 2896 病毒侵袭  (上一题稍微修改一下end数组)<br>HDU 2222 Keywords Search (AC自动机入门题)<br>Topcoder Single Round Match 673<br>51Nod 1351 吃点心 (不错的贪心)<br>Ural 1018 Binary Apple Tree (经典树形DP)<br>ZJU 3278 8G Island (真傻逼。。。逗比的错了一下午)<br>HDOJ 1546 Idiomatic Phrases Game (简单最短路)<br>Codeforces 598E Chocolate Bar (DP预处理)<br>Codeforces 598D Igor In the Museum (DFS预处理)<br>Codeforces 598B Queries on a String (水)<br>Codeforces 598A Tricky Sum (水)<br>LA 3667 Ruler (不错的搜索)<br>LA 4253 Archery （二分+贪心）<br>HDOJ 5563 Clarke and five-pointed star (水)<br>HDOJ 5562 Clarke and food (经典水贪心)<br>HDOJ 2632 Samuel’s NOKIA N73 (水题)<br>HDOJ 1571 下沙小面的(1) (模拟)</p><p>###2015-11-13<br>Codeforces 597C Subsequences (CCPC原题，树状数组维护，注意细节)<br>Codeforces 597B Restaurant (贪心，又卡了= =思路还是不够开阔)<br>Codeforces 597A Divisibility (水题，但是打了很多次补丁才AC，第一次敲的时候就要注意考虑所有情况)<br>LA 3266 田忌赛马 (贪心)<br>Codeforces 594C    Edo and Magnets (暴力+小技巧)<br>Codeforces 594A    Warrior and Archer (贪心+机智)<br>Codeforces 595B    Pasha and Phone (数位运算，不是很擅长)<br>Codeforces 595A    Vitaly and Night (水)<br>HDOJ 1418 抱歉 (水)</p><p>###2015-11-06<br>UVa 11100 The Trip, 2007 (贪心,机智)<br>51Nod 1403 有趣的堆栈 (模拟水题)<br>UVa 11134 Fabled Rooks (分治，状态简单化)<br>LA 4254 Processor (二分答案用优先队列贪心判断，不(WA)错(很久)的题)<br>UVa 10905 Children’s Game (排序函数的神奇用法)<br>UVa 10382 Watering Grass (区间覆盖最小，经典贪心)<br>UVa 10340 All in All (水)<br>UVa 10970 Big Chocolate (水)<br>LA 3602 DNA Consensus String (水)<br>LA 3213 Ancient Cipher (水)<br>UVa 11039 Building designing (水)<br>UVa 11636 Hello World! (水)<br>LA 3177 Beijing Guards (二分答案贪心判断)<br>LA 3902 Network (树上的贪心)<br>Codeforces Round #328 (Div. 2)<br>BestCoder Round #61 (div.2)</p><p>###2015-10-30<br>UVa 11520 Fill the Square (构造)<br>LA 3635 Pie (二分答案)<br>LA 3971 Assemble (贪心)<br>UVa 10795 A Different Task (YY，递归)<br>UVa 11384 Help is needed for Dexter (YY，状态简单化)<br>UVa 11464 Even Parity (枚举，构造)<br>LA 2995 Image Is Everything (枚举，要有耐心。。。)<br>UVa 10881 Piotr’s Ants (状态简单化)<br>UVa 11300 Spreading the Wealth (中位数的运用)<br>UVa 11729 Commando War (水)<br>UVa 11292 The Dragon of Loowater (水)<br>Codeforces Round #327 (Div. 2) A B C D<br>Codeforces Round #326 (Div. 2) A B C D<br>51Nod 1441 士兵的数字游戏 (筛)<br>51Nod 1459 迷宫游戏 (使用小技巧的flyod和dijk模板两种做法)<br>51Nod 1019 逆序数 (水树状数组)<br>51Nod 1000 1005 1011 1018(水的丧心病狂。。。)</p><p>###2015-10-23<br>这周光弄博客和Ubuntu了颓了一周<br>Topcoder Single Round Match 669<br>CCPC正式赛<br>CCPC热身赛</p><p>###2015-10-16<br>HDOJ 1078 FatMouse and Cheese (记忆化搜索)<br>HDOJ 1074 Doing Homework (状态压缩DP)<br>HDOJ 1069 Monkey and Banana (简单DP)<br>HDOJ 1024 Max Sum Plus Plus (普通DP)<br>Codeforces Round #325 A.B.C (肯定自己做法没错的时候一定要再仔细看一下题目！！！)<br>Codeforces Round 478D<br>Codeforces Round 478C<br>Codeforces Round 478B<br>Codeforces Round 478A<br>LA 4818<br>LA 3491<br>UV11978<br>UVa 11177<br>UVa 10969<br>LA 2402 Fishnet (求交点和面积)<br>Topcoder Single Round Match 700<br>BestCoder Round #59 (div 2)</p><p>###2015-10-09<br>UVa 11178 Morley’s Theorem (射线求交点及旋转)<br><del>UVa 11731 Ex-Circles</del><br><del>UVa 11524 In-Circle</del><br>UVa Live 4986 Dome of Circus (三分+YY)<br>UVa 11817 Tunnelling the Earth (圆表面的距离)<br>UVa 11646 Athletics Track (水)<br>UVa 11800 Determine the Shape (凸包)<br>UVa 11437 Triangle Fun (基础几何)<br>Codeforces Round #324 (Div. 2) (打+补)<br>51nod 1105 第K大的数 (二分答案+YYCheck)<br>51Nod 1434 区间LCM (YY)<br>51Nod 1241 特殊的排序 (贪心+DP)<br>Codeforces Round #323 (Div. 2) (补)<br>BestCoder Round #58<br>SDUT 训练赛 (蹭)<br>最短路练习 L Subway (dijkstra)<br>最短路练习 K Candies (差分约束+优先队列优化dijkstra)</p><p>###2015-10-02<br>最短路练习 I Arbitrage (传递闭包Floyd)<br>最短路练习 H Cow Contest (传递闭包Floyd)<br>最短路练习 G MPI Maelstrom (Floyd最短路)<br>最短路练习 F Wormholes (SPFA判环)<br>最短路练习 E Currency Exchange (SPFA判环)<br>最短路练习 D Silver Cow Party (SPFA)<br>最短路练习 C Heavy Transportation (dijkstra)<br>最短路练习 B Frogger (floyd)<br>最短路练习 A Til the Cows Come Home (dijkstra)<br>HDOJ 3415 Max Sum of Max-K-sub-sequence (单调队列)<br>POJ 2823 Sliding Window (单调队列)<br>POJ 1269 Intersecting Lines (判断线段关系求交点)<br>POJ 3304 Segments (判断线段相交)<br>POJ 2398 Toy Storage (近似上题)<br>POJ 2318 TOYS (点和线段位置)<br>Topcoder Single Round Match 669 (。。这几天比赛好多=。=)<br>Codeforces Round #322 (Div. 2)<br>HDOJ 5489 Removed Interval (DP+线段树)<br>ZOJ 1081 Points Within (几何)<br>2015合肥赛区网络赛 (未出线)<br>POJ 1584 A Round Peg in a Ground Hole (几何)<br>BestCoder Round #57 ()<br>2015上海赛区网络赛 (未出线)<br>POJ 2663 Tri Tiling (递推)</p><p>###2015-09-25<br>之前的没有记录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="杂记" scheme="http://www.winterfell30.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>防吊打技能入门与进阶 - 动态规划总结</title>
    <link href="http://www.winterfell30.com/2015/07/31/dpzongjie/"/>
    <id>http://www.winterfell30.com/2015/07/31/dpzongjie/</id>
    <published>2015-07-31T03:28:12.000Z</published>
    <updated>2016-11-23T08:08:29.943Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><hr><p>###DP真的是很思维性的东西而且总能有很多题目可以出。</p><p>###这次的动态规划专题全是POJ的题目,但是POJ的评测机总是抽风啊。。。总是504</p><p>###全面的两个专题因为把代码都贴出来了感觉又长又乱，但是没有查到Markdown怎么折叠全部代码(就是博客园的那种ViewCode)</p><h2 id="所以为了看起来舒服一点，只能贴在网站上，如果有巨巨知道Markdown怎么实现代码折叠请教我一下。。。"><a href="#所以为了看起来舒服一点，只能贴在网站上，如果有巨巨知道Markdown怎么实现代码折叠请教我一下。。。" class="headerlink" title="###所以为了看起来舒服一点，只能贴在网站上，如果有巨巨知道Markdown怎么实现代码折叠请教我一下。。。"></a>###所以为了看起来舒服一点，只能贴在网站上，如果有巨巨知道Markdown怎么实现代码折叠请教我一下。。。</h2><p>##POJ 1848    Tree</p><p>给出一个树的一些节点，问最少需要添加多少边能让所有的节点都在一个三元环里面，实际上这是做的第一个树形DP。。。于是就去学习了一下树形DP，做了一道最基础的树形DP(poj2342)有了一些了解，然后这题还是不会= =。去看了题解才勉强A了。<br>转态方程如下(参考原题解)<br>树形dp：dp[now][0]为以now为根的子树完成题目要求添加的最少边。<br>　　　　　　　 dp[now][1]为除开now这个结点后它的子树满足题目要求所需要的最少边。<br>　　　　　　　 dp[now][2]为now和它的某一个孩子形成至少长度为2的链所需要添加的最少边，未涉及到的点均已满足题目要求。<br>　　 转移方程：dp[now][1]=sum(dp[k][0])，k为now的孩子。</p><p>　　　　　　　 dp[now][2]=sum(dp[k][0])-dp[i][0]+min(dp[i][1],dp[i][2])，即从孩子中找一个，now会与它组成长度大于等于2的链<br>　　　　　　　 dp[now][0]=sum(dp[k][0])-dp[i][0]+dp[i][2]+1或sum(dp[k][0])-dp[i][0]-dp[j][0]+min(dp[i][1],dp[i][2])+min(dp[j][1],dp[j][2])，前者是找一个有长度至少为2的链的孩子，后者是找两个没有形成环的孩子。<br><a href="http://paste.ubuntu.com/11971098/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 1925    Spiderman</p><p>这题的思路还是比较好想的，因为荡过去之后是对称的，所以这里y是一直不变的，但是y也不是没有用的，就是根据现在的柱子高度求出来能允许连接蛛丝的区间，然后维护这个区间,然后DP就可以了。<br><a href="http://paste.ubuntu.com/11971104/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 1946    Cow Cycling</p><p>很经典的题，题意搞半天，就是所有牛绕操场跑步，领头的耗费能量为E*E，其他的都是E，问最后能不能跑完。<br>DP[i][j][k]代表第i只牛跑了j圈时耗费了j能量花费的时间<br>最后求出来的dp[N][D][]求最大值就可以了，做起来很像Floyd算法。<br><a href="http://paste.ubuntu.com/11971110/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 1985    Cow Marathon</p><p>实际上就是求树的直径，先随便找一个点求出来最远的点，然后再用这个点求出来最远的点，那么距离就是直径了。<br><a href="http://paste.ubuntu.com/11971117/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2057    The Lost House</p><p>树形DP，这题做了挺久的，在这篇论文里面是个例题：<a href="http://wenku.baidu.com/link?url=oeChDMyE1s1azI4BLUNrq1Mgy0UDiuk7XP-2rc2bB0Qm0PSiM3c0cHbIpxBr8EVvNzu8ples2SiW5Cq7dfJg9ywVdXk6LkdQLW745Uqisua" target="_blank" rel="noopener">浅谈贪心思想在动态规划中的应用</a><br>这里要想让期望最大，要通过排序找出重复步数最少的走法，再具体的证明什么的还是论文里面讲的更详细就不再赘述了。<br><a href="http://paste.ubuntu.com/11971518/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2137    Cowties</p><p>显示枚举每头牛，然后枚举开头的牛的位置，枚举现在枚举到的牛的位置，枚举现在枚举到的牛的前一头牛的位置，最后枚举最后一头牛和第一头牛的位置。反正就是欺负他数据小各种枚举就是了2333<br>DP[i][j][k]代表第一头牛在j位置时第i头牛在k位置时的最短绳子长度。<br><a href="http://paste.ubuntu.com/11971513/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2181    Jumping Cows</p><p>从给出的数列选择一些相加，按顺序奇数加偶数减问结果最大是多少。<br>因为是交叉相加的，所以搞一个偶数和奇数数组分别维护最后取较大者就可以了。<br><a href="http://paste.ubuntu.com/11971522/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2184    Cow Exhibition</p><p>这题就是个变形的01背包，不过因为有负数的出现，所以这里要整体平移100000防止负数，然后背包的最内层也要分别从前往后推和从后往前推，之前对这个不是很了解，一是防止负数使dp数组越界，二是滚动数组对前面dp的值有要求，推的顺序是有要求的。<br>然后就是题目中的要求单项的和是正数最后求答案的时候判断一下就可以了。<br><a href="http://paste.ubuntu.com/11971528/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2192    Zipper</p><p>额。。这题我的代码是DFS的。。我算了一下DP的话复杂度会超(实际上要超都会超了。。。<br>实际上DFS和DP思路上差别不大都是直接比较的。<br><a href="http://paste.ubuntu.com/11971532/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2231    Moo Volume</p><p>这题之前写过，但是当时的写法复杂度有点超，稍微优化一下变成递推形式就从500ms变成32毫秒了。<br>所以说！！！有的时候你的思路可能是没错的，只是你还没找到最好的写法！！！<br><a href="http://paste.ubuntu.com/11973999/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2241    The Tower of Babylon</p><p>传统的DP，只是这里用了一点贪心思想先按l拍一下序，还有这个a[]的读入的写法是我参考别人的，感觉很优雅<br>这里min，max的使用为后面省了很多代码。<br><a href="http://paste.ubuntu.com/11971542/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2250    Compromise</p><p>就是个字符串版的最长公共子串，用string存上，注意维护一个数组打印路径就行了。<br><a href="http://paste.ubuntu.com/11971552/" target="_blank" rel="noopener">AC代码链接</a></p><p>##POJ 2385    Apple Catching</p><p>次奶牛只有两种决策，在某一分钟的时候转移或者不转移，我们只要知道前面分钟两者之间的最大值，继而可以得到当前状态的最大值<br>动态规划设dp[T][W]代表第T分钟的时候移动W次的所得到的最大苹果数<br>状态转移方程:dp[T][W] = max(dp[T-1][W] + (a[T] == W%2+1), dp[T-1][W-1] + (a[T] == W%2 + 1))<br>a[T] == W%2 + 1,是看当前转移了W次后在哪棵树下，当前能不能得到这个苹果<br><a href="http://paste.ubuntu.com/11971554/" target="_blank" rel="noopener">AC代码链接</a></p><p>###大致这些，如有错误欢迎留言指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="题解" scheme="http://www.winterfell30.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>关于printf()中的%lf和%f</title>
    <link href="http://www.winterfell30.com/2015/07/28/lfand-f/"/>
    <id>http://www.winterfell30.com/2015/07/28/lfand-f/</id>
    <published>2015-07-28T04:21:18.000Z</published>
    <updated>2016-11-23T08:09:12.559Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>今天碰到了一个很奇怪的事<br><code>printf(&quot;%.4lf\n&quot;, (double)1.0 * node[1].stepy / node[1].leaf);</code><br>stepy和leaf都是非零的int型数值，但是变成double之后就被变成0.00了，刚开始一直以为是程序不对，后来发现怎么改都是<br>0.00，然后我到网上看相似代码发现正确姿势是%.4f，然后改了一下果然对了，我就到网上查了点相关资料，查到了这个：</p><p>%f和%lf对于printf()和scanf()的效果是不同的。</p><p>事实上，对于printf()，无论是%f还是%lf，效果都是一样的。(TMD哪相同了</p><p>因为，遇到float，printf()会将float类型自动提升到double，所以不会有什么问题。</p><p>而且严格地讲，printf()并没有对于%lf的定义，虽然很多编译器会接受，所以最好使用%f。</p><p>而对于scanf()，由于接受的是指针，并没有类型提升的说法，所以对于double就应该用%lf，float就是%f。</p><p>所以只是语言和Mingw的问题，总结一下就是printf尽量用%f，scanf就要对号入座。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>防吊打技能入门与进阶 - 二分哈希总结</title>
    <link href="http://www.winterfell30.com/2015/07/23/erfenhash/"/>
    <id>http://www.winterfell30.com/2015/07/23/erfenhash/</id>
    <published>2015-07-23T11:03:46.000Z</published>
    <updated>2016-11-23T08:08:44.635Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><hr><p>###虽然名义上是二分哈希专题，但是实际上多数是二分。</p><p>###和贪心专题不一样的是这里面的题之前都没做过，所以这篇总结可能有点长。</p><p>###有少数的字符串哈希题目都用map水过去了。。。</p><h2 id="因为二分答案的有些题思想比较重复就不多余的贴出来了。"><a href="#因为二分答案的有些题思想比较重复就不多余的贴出来了。" class="headerlink" title="###因为二分答案的有些题思想比较重复就不多余的贴出来了。"></a>###因为二分答案的有些题思想比较重复就不多余的贴出来了。</h2><p>##HDU 3833 YY’s new problem</p><p>把公式变形一下，然后枚举P[1]和P[3]求P[2]，这样复杂度会超，但是A掉了。<br>到网上找了一些代码也都是O(N^2)的，最后找到了一个线段树维护Hash值O(nlogn)的。<br>代码就只贴一下我的吧，<a href="http://blog.csdn.net/jxy859/article/details/6604652" target="_blank" rel="noopener">正解地址点这里</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">int</span> Hash[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(Hash, <span class="number">0</span>, <span class="keyword">sizeof</span>(Hash));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            Hash[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i + j) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (i + j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((Hash[mid] &gt; Hash[i] &amp;&amp; Hash[mid] &lt; Hash[j]) || (Hash[mid] &lt; Hash[i] &amp;&amp; Hash[mid] &gt; Hash[j]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Y\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"N\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##PKU 2002 Squares</p><p>这题之前写过题解了，但我觉得这是道不错的题，就再啰嗦一下。<br>原题解地址:<a href="http://www.winterfell30.com/2015/07/15/poj2002/">PKU 2002 Squares (二分)</a>。<br>首先是坐标的计算使用相似三角形加减计算比较方便，关于求另外两个边，我这里避开了复杂的哈希选择了二分。<br>第一次写这种包含两个元素的二分，实际上相比一个的思维上没什么新的难度，注意细节就好。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;star[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.x == b.x)</span><br><span class="line"><span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (star[mid].x &gt; x)</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (star[mid].x &lt; x)</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (star[mid].y &gt; y)</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (star[mid].y &lt; y)</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;star[i].x, &amp;star[i].y);</span><br><span class="line">sort(star, star + n, cmp);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> x3 = (star[i].x + star[j].x) * <span class="number">0.5</span> - (star[j].y - star[i].y) * <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">double</span> y3 = (star[i].y + star[j].y) * <span class="number">0.5</span> - (star[i].x - star[j].x) * <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">double</span> x4 = (star[i].x + star[j].x) * <span class="number">0.5</span> - (star[i].y - star[j].y) * <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">double</span> y4 = (star[i].y + star[j].y) * <span class="number">0.5</span> - (star[j].x - star[i].x) * <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">if</span> (x3 != <span class="built_in">floor</span>(x3) || y3 != <span class="built_in">floor</span>(y3) || x4 != <span class="built_in">floor</span>(x4) || y4 != <span class="built_in">floor</span>(y4))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(x3, y3) &amp;&amp; <span class="built_in">find</span>(x4, y4))</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##HDU 4287 Intelligent IME</p><p>在读入这些字符串的时候把他们转化为相应的数字形式，map存好数字的字符串，直接统计即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">string</span> a[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> tab[<span class="number">30</span>] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">mp.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++)</span><br><span class="line">&#123;</span><br><span class="line">s[j] = tab[s[j] - <span class="string">'a'</span>] + <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">mp[s]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mp[a[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##HDU 1014 Uniform Generator</p><p>感觉这题和Hash的关系不大，实际上是在介绍哈希，虽然题目很长实际上就是纯模拟题，按照题目说的来就行。<br>代码是很久之前写的了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> seed[<span class="number">100010</span>],ans[<span class="number">100010</span>],i,mod,<span class="built_in">step</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;<span class="built_in">step</span>,&amp;mod)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(seed,<span class="number">0</span>,<span class="keyword">sizeof</span>(seed));</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%10d%10d    "</span>,<span class="built_in">step</span>,mod);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;mod;i++)</span><br><span class="line">            ans[i]=<span class="number">2</span>;</span><br><span class="line">        seed[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;mod;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            seed[i+<span class="number">1</span>]=(seed[i]+<span class="built_in">step</span>)%mod;</span><br><span class="line">            ans[seed[i+<span class="number">1</span>]]--;</span><br><span class="line">            <span class="keyword">if</span>(!ans[seed[i+<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Good Choice\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Bad Choice\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##HDU 2136 Largest prime factor</p><p>这个题实际上就是筛法，不知道和这个专题有什么关系，但是筛法也是不错的题，而且下面还会有一些类似的题目。<br>刚开始先筛素数再找因子什么的果断TLE了，然后用了这种方法直接晒出来结果，恩，就应该这样想要什么求什么，不走弯路。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000001</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = k++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; N; j += i)</span><br><span class="line">                a[j] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##HDU 1128 Self Numbers</p><p>和上一道一样，想要什么就求什么。<br>题目比较水但是发现一个问题就是数组设为int类型就超时，改为bool就A了。<br>应该是因为int占内存太大而bool占内存相对较小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">bool</span> Hash[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="built_in">memset</span>(Hash, <span class="literal">false</span>, <span class="keyword">sizeof</span>(Hash));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = i;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += j % <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Hash[sum] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Hash[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##PKU 2785 4 Values whose Sum is 0</p><p>这题的思想很不错，这个貌似是个经典问题，每一列拿出一个数，求有多少组相加等于0。<br>数据是4000，算了一下复杂度差不多我就枚举前两列的和及后两列的和，然后排序二分出答案。<br>这里求答案用的是upper_bound() - lower_bound()，这中间的数都是相等的，所以求出来都是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4010</span>], b[<span class="number">4010</span>], c[<span class="number">4010</span>], d[<span class="number">4010</span>], sum1[<span class="number">4010</span> * <span class="number">4010</span>], sum2[<span class="number">4010</span> * <span class="number">4010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;a[i], &amp;b[i], &amp;c[i], &amp;d[i]);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">sum1[k] = a[i] + b[j];</span><br><span class="line">sum2[k++] = -(c[i] + d[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(sum2, sum2 + k);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp1 = upper_bound(sum2, sum2 + k, sum1[i]) - sum2;</span><br><span class="line"><span class="keyword">int</span> temp2 = lower_bound(sum2, sum2 + k, sum1[i]) - sum2;</span><br><span class="line">ans += (temp1 - temp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##PKU 3258 River Hopscotch</p><p>应该是从这题开始下面大都是二分答案的题型了。<br>这题是最小值最大化，二分的就是最大的距离，动态维护石子个数二分出符合要求的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, L;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = N - M;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = last + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= N &amp;&amp; dis[cur] - dis[last] &lt; x)</span><br><span class="line">cur++;</span><br><span class="line"><span class="keyword">if</span> (cur &gt; N)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">last = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;L, &amp;N, &amp;M))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dis[i]);</span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dis[N + <span class="number">1</span>] = L;</span><br><span class="line">sort(dis, dis + N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (M == N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = L;</span><br><span class="line"><span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (Check(mid))</span><br><span class="line">l = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##PKU 3104 Drying</p><p>衣服放着不动一分钟可以干一点，烘干可以干k点，我们可以二分出分钟然后判断能否全部烘干。<br>判断的时候是用每件衣服烘干所需要的时间加起来和所给时间比较，这样就不用考虑自然干的时间了。<br>因为这题所需时间就是(a[i] - mid) * 1.0 / (k - 1)，所以当k == 1的时候分母为0会RE，要注意。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line">ll a[<span class="number">100010</span>], k, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">ll mmax = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a[i]);</span><br><span class="line">mmax = <span class="built_in">max</span>(a[i], mmax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;k);</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, mmax);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll l = <span class="number">0</span>, r = mmax, ans;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; mid)</span><br><span class="line">&#123;</span><br><span class="line">ll temp = <span class="built_in">ceil</span>((a[i] - mid) * <span class="number">1.0</span> / (k - <span class="number">1</span>));</span><br><span class="line">sum += temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt;= mid)</span><br><span class="line">r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##PKU 2503 Babelfish</p><p>还是用map水过去的。。。但是这题水是水，输入的处理让我纠结了很长时间。。。<br>一直想只用String，后来还是放弃了用了char。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; d;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">12</span>],str2[<span class="number">12</span>],str[<span class="number">30</span>];</span><br><span class="line">       <span class="keyword">while</span>(gets(str))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">strlen</span>(str)==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="built_in">sscanf</span>(str,<span class="string">"%s %s"</span>,str1,str2);</span><br><span class="line">           d[str2]=str1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">string</span> str3,p_out;</span><br><span class="line">       <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str3)</span><br><span class="line">       &#123;</span><br><span class="line">           p_out=d[<span class="built_in">string</span>(str3)];</span><br><span class="line">           <span class="keyword">if</span>(p_out.length()==<span class="number">0</span>)</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"eh"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;p_out&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##HDU 4786 Flyer</p><p>找到最大的A+k*C使其小于B。因为奇数只有一个，而奇数后面的和都是奇数，前面的和都是偶数，所以二分出这个学生就可以了。<br>刚开始一直看不懂题，原来这个是按学生每个社团都给他，求和函数里面模拟就行，还学会了1LL&lt;&lt;32的新用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a, b, c;</span><br><span class="line">&#125;stu[<span class="number">20020</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">Check</span><span class="params">(ll mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll k = <span class="built_in">min</span>(stu[i].b, mid);</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= stu[i].a)</span><br><span class="line">            sum += (k - stu[i].a) / stu[i].c + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%I64d %I64d %I64d"</span>, &amp;stu[i].a, &amp;stu[i].b, &amp;stu[i].c);</span><br><span class="line">        ll l = <span class="number">0</span>, r = <span class="number">1L</span>L &lt;&lt; <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (Check(mid) % <span class="number">2</span>)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">1L</span>L &lt;&lt; <span class="number">32</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"DC Qiang is unhappy.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (Check(l) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                l--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%I64d %I64d\n"</span>, l, Check(l) - Check(l - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##HDU 1969 Pie</p><p>又是一道读题就卡住的题。。。要求每个人分到相同数量的蛋糕，但是蛋糕不管怎么切，必须不能是两块蛋糕拼起来的。<br>求最大每个人能获得多少蛋糕。<br>还是老思路，二分答案然后判断可行性。坑点是这题卡精度，1e-4就WA，改成1e-7就过了。<br>有浮点数的时候一定要注意精度！！！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">double</span> ss[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="built_in">floor</span>(ss[i] / x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        m++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ri;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ri);</span><br><span class="line">            ss[i] = ri * <span class="number">1.0</span> * PI * ri;</span><br><span class="line">            sum += ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> l = <span class="number">0</span>, r = sum / m;</span><br><span class="line">        <span class="keyword">while</span> ((r - l) &gt; eps)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (Check(mid))</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###大致这些，如有错误欢迎留言指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="题解" scheme="http://www.winterfell30.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++游戏编程入门</title>
    <link href="http://www.winterfell30.com/2015/07/21/winC/"/>
    <id>http://www.winterfell30.com/2015/07/21/winC/</id>
    <published>2015-07-21T12:38:54.000Z</published>
    <updated>2016-11-23T08:10:40.183Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>记得高中时开始学编程就是为了做游戏，不过国内的游戏行业好像不尽人意。但是不管怎样，还是想稍微完成以下那时候的想法。<br>暑假前借了这本游戏编程入门，没有选unity或者cocos2d也是想用通过自己写引擎的方法更深入学习C++，编程语言学太多感觉并不好。<br>本书里面都是些简单的例子，学的也都是写基础的东西，引擎也是初级引擎，重在学习。。。<br>看了一下书里面的代码，感觉大体上理解起来是挺简单的，但是有很多关键词从来就没见过。。。<br>后来百度了一下发现这些都是Windows编程里面约定好的一些宏定义。<br>比如WORD类型，竟然是typedef unsigned short WORD;从来没见过这种东西。。。。<br>书上明明写的只需要C++基础！！！原来他说的的C++基础和我们学的不是一回事。。。<br>下了一些关于Windows编程的视频看了一点，了解了一些这些windows编程的东西。。。<br>感觉这样都要学的话任务就不一定能完成了啊，蛋疼。</p><h2 id="看完了前两章游戏引擎的开发了，明天把引擎写一下，写一下第一个游戏Blizzard。"><a href="#看完了前两章游戏引擎的开发了，明天把引擎写一下，写一下第一个游戏Blizzard。" class="headerlink" title="看完了前两章游戏引擎的开发了，明天把引擎写一下，写一下第一个游戏Blizzard。"></a>看完了前两章游戏引擎的开发了，明天把引擎写一下，写一下第一个游戏Blizzard。</h2><p>写完了游戏引擎和一个小游戏“滑稽”，但是最终挂在了一个函数上导致一个功能一直不能实现，找了一天错之后没发现什么地方不对就姑且先认为是书的版本太老了吧=。=。。。不过书也的确是老了点已经十几年了。。。<br>整个项目的开源代码<a href="https://github.com/winterfell30/GameEngine_Practice/tree/master/GameEngine" target="_blank" rel="noopener">戳这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>防吊打技能入门与进阶 - 贪心专题总结</title>
    <link href="http://www.winterfell30.com/2015/07/15/greedy/"/>
    <id>http://www.winterfell30.com/2015/07/15/greedy/</id>
    <published>2015-07-15T14:59:56.000Z</published>
    <updated>2016-11-23T08:11:15.207Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><hr><p>###这是这个系列的第一个专题，贪心相对来说算是比较基础的东西。</p><p>###HDOJ的相关题目之前都做过了，题解都在<a href="http://blog.csdn.net/dreamon3/article/category/2929521" target="_blank" rel="noopener">我的CSDN博客贪心专题</a>上。</p><p>###做完POJ之后感觉一直做这个做的有点。。。就还剩下几个ZOJ的没做，以后做其他专题的有空再补上。</p><h2 id="做了感觉没什么作用的就不贴了。"><a href="#做了感觉没什么作用的就不贴了。" class="headerlink" title="###做了感觉没什么作用的就不贴了。"></a>###做了感觉没什么作用的就不贴了。</h2><p>##PKU 1017 Packets</p><p>我第一个想到的竟然是模拟。。。下面这个方法很机智。<br>印象中很久之前就做过这题但是在博客上没找到什么记录就再写一遍。<br>可以插到别人里面的只有尺寸为2和尺寸为1的(这句话好奇怪。。。<br>只需前面正常计算这俩先插再计算就可以保证占用空间最下了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d, e, f;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d %d"</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e &amp;&amp; !f)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> n = f + e + d + (c + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">5</span> * d + num[c % <span class="number">4</span>];          <span class="comment">//插2</span></span><br><span class="line"><span class="keyword">if</span> (n2 &lt; b)</span><br><span class="line">n += (b - n2 + <span class="number">8</span>) / <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">36</span> * n - <span class="number">36</span> * f - <span class="number">25</span> * e - <span class="number">16</span> * d - <span class="number">9</span> * c - <span class="number">4</span> * b; <span class="comment">//这里的36 * n挺巧妙的</span></span><br><span class="line"><span class="keyword">if</span> (n1 &lt; a)                                                 <span class="comment">//避开了很多运算</span></span><br><span class="line">n += (a - n1 + <span class="number">35</span>) / <span class="number">36</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##PKU 2231 Moo Volume</p><p>YY了一下形成一个矩阵的话是哪个叫什么的a[i][j] == a[j][i]的矩阵所以有一半的加法是多余的，且对角线是0。<br>所以最坏的情况是O(1+2+…n-1)，但是算一下也有五千万了，水了一下500ms过了，但是我总感觉这个方法不靠谱。<br>肯定有更小复杂度的方法，问了一下PF果然有，然后到网上找了一下找到了DP的方法，复杂度O(nlogn),32ms。<br>两个代码都贴一下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">sort(a, a + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">ans += (a[j] - a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line">ll dp[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + (i - <span class="number">1</span>) * ll(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">ans += dp[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##PKU 1456 Supermarket</p><p>这个就像之前HDOJ上的Doing Home Work差不多。<br>先排价值高的(排在最后一天)，要是碰到某一天已经有了就向前移动一天直到有空。<br>诡异的WA，换成一级排序就AC了，PF提交就是AC，然后我的代码给他又诡异的没有了break。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> p, d;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node x, node y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.p &gt; y.p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a[i].p, &amp;a[i].d);</span><br><span class="line">sort(a, a + n);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[a[i].d])</span><br><span class="line">&#123;</span><br><span class="line">ans += a[i].p;</span><br><span class="line">vis[a[i].d] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].d - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[j])</span><br><span class="line">&#123;</span><br><span class="line">ans += a[i].p;</span><br><span class="line">vis[j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##PKU 1328 Radar Installation</p><p>刚开始没什么思绪，后来看了题解。<br>用勾股定理配合半径r和点的y坐标求出来每个点可以达到的最大区间[x1, x2]。<br>然后问题就变成了求使区间重合的最小什么什么的，动态维护一下区间就可以了。<br>(我的代码依旧诡异的WA，最后对拍也没有找到错误，以下代码为同思路AC代码)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;a[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(node *)a).x &gt; (*(node *)b).x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,m,n,k,t,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> dist,s;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k &amp;&amp; n!=<span class="number">0</span> &amp;&amp; m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>) flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(t)&lt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算区间</span></span><br><span class="line">                dist=<span class="built_in">sqrt</span>(<span class="keyword">double</span>(k*k-t*t));</span><br><span class="line">                a[i].y=s+dist;</span><br><span class="line">                a[i].x=s-dist;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;count&lt;&lt;<span class="string">": -1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qsort(a,n,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]),cmp);<span class="comment">//注意排序，double型排序</span></span><br><span class="line">        s=a[<span class="number">0</span>].y;m=<span class="number">1</span>;<span class="comment">//雷达个数初始化为1</span></span><br><span class="line">        <span class="comment">//寻找最少区间个数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].x&gt;s)<span class="comment">//s为公共区间的右端点，若下一个区间的左端点大于s则该区间与以上的公共区间没有公共部分</span></span><br><span class="line">            &#123;</span><br><span class="line">                m++;<span class="comment">//雷达个数加1</span></span><br><span class="line">                s=a[i].y;<span class="comment">//更新公共区间右端点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//与以上公共部分有公共部分</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i].y&lt;s)</span><br><span class="line">                s=a[i].y;<span class="comment">//更新右端点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;count&lt;&lt;<span class="string">": "</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##PKU 2437 Muddy roads</p><p>使用尽量少的棍子覆盖所有池塘，比较好想，按照顺序扫一遍就行了。<br>维护一下右区间端点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn 110000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inte</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll s,e;</span><br><span class="line">&#125;inte[Maxn];</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Inte a,struct Inte b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.s&lt;b.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll la;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;n,&amp;l))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;inte[i].s,&amp;inte[i].e);</span><br><span class="line"></span><br><span class="line">        sort(inte+<span class="number">1</span>,inte+n+<span class="number">1</span>,cmp); <span class="comment">//将区间从小到大排序</span></span><br><span class="line">        la=<span class="number">-1</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>,len,num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inte[i].e&lt;=la) <span class="comment">//如果上一个棒将这个区间完全覆盖了，则不需要继续添加棒了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(inte[i].s&lt;la) <span class="comment">//如果占据了该区间一部分</span></span><br><span class="line">            &#123;</span><br><span class="line">                len=inte[i].e-la; <span class="comment">//剩下的长度</span></span><br><span class="line">                num=(len+(l<span class="number">-1</span>))/l; <span class="comment">//所需要的棒的个数，注意向上取整</span></span><br><span class="line">                ans+=num; <span class="comment">//</span></span><br><span class="line">                la+=num*l; <span class="comment">//新的棒的覆盖位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                len=inte[i].e-inte[i].s; <span class="comment">//上一个棒 没有延伸到该区间</span></span><br><span class="line">                num=(len+(l<span class="number">-1</span>))/l; <span class="comment">//棒的个数</span></span><br><span class="line">                ans+=num;</span><br><span class="line">                la=inte[i].s+num*l; <span class="comment">//新的棒的覆盖位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##PKU 2054 Color a Tree</p><p>这题还是比较有意思的，里面的那个节点合并很有技巧性。<br>其实这题很好想，就是有很多链，按照权重来决定涂色的优先级，但是不知道该怎么求权重。<br>在网上看到了这个方法，对于每条链，求权值最高的点然后和父节点合并，下面接上来，然后不停求，直到剩下最后一个包含权重的最终点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> pre, c ,t;</span><br><span class="line"><span class="keyword">double</span> w;      <span class="comment">//w为权值,即平均值</span></span><br><span class="line">&#125;e[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pos</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">double</span> maxp = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == root)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (e[i].w &gt; maxp)</span><br><span class="line">&#123;</span><br><span class="line">maxp = e[i].w;</span><br><span class="line">pos = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, root;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;root) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; root == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">ll mmax = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e[i].c);</span><br><span class="line">e[i].w = e[i].c;</span><br><span class="line">e[i].t = <span class="number">1</span>;</span><br><span class="line">ans += e[i].c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a ,&amp;b);</span><br><span class="line">e[b].pre = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">mmax = find_pos(n, root);</span><br><span class="line">e[mmax].w = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fa = e[mmax].pre;</span><br><span class="line">ans += e[mmax].c * e[fa].t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (e[j].pre == mmax)</span><br><span class="line">e[j].pre = fa;</span><br><span class="line">e[fa].c += e[mmax].c;</span><br><span class="line">e[fa].t += e[mmax].t;</span><br><span class="line">e[fa].w = <span class="number">1.0</span> * e[fa].c / e[fa].t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###就这些吧，其实大部分贪心相对来说思维要求不是很高，找到优先级就差不多了(WA的点还是有一些的)<br>(做的时候参考了一些其他巨巨的题解或代码这里就不放原文链接了，如有侵权留言即删)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="题解" scheme="http://www.winterfell30.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>位运算在ACM中的简单运用 (HDU 2095)</title>
    <link href="http://www.winterfell30.com/2015/07/08/weiyunsuan/"/>
    <id>http://www.winterfell30.com/2015/07/08/weiyunsuan/</id>
    <published>2015-07-08T13:51:21.000Z</published>
    <updated>2016-11-23T08:10:46.967Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><hr><p>此文有一些事看过的一些位运算资料，还有一些自己的总结，因为有点多就不放原文地址了。。。</p><hr><p>运算方法有六种：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&amp;       与运算   </span></span><br><span class="line"><span class="string">|       或运算  </span></span><br><span class="line">^       异或运算  </span><br><span class="line"><span class="symbol">~       非运算(求补)  </span></span><br><span class="line"><span class="symbol">&gt;&gt;      右移运算  </span></span><br><span class="line"><span class="symbol">&lt;&lt;      左移运算</span></span><br></pre></td></tr></table></figure></p><p>运用这些基本的运算，我们可以解决acm所需的各种运算,给Bit赋1，赋0，给他的值取反，还有好多段操作。如下：</p><p>  功能              |          示例            |    位运算<br>———————-+—————————+——————–<br>去掉最后一位          | (101101-&gt;10110)          | x &gt;&gt; 1<br>在最后加一个0        | (101101-&gt;1011010)        | x &lt; &lt; 1<br>在最后加一个1        | (101101-&gt;1011011)        | x &lt; &lt; 1+1<br>把最后一位变成1      | (101100-&gt;101101)          | x | 1<br>把最后一位变成0      | (101101-&gt;101100)          | x | 1-1<br>最后一位取反          | (101101-&gt;101100)          | x ^ 1<br>把右数第k位变成1      | (101001-&gt;101101,k=3)      | x | (1 &lt; &lt; (k-1))<br>把右数第k位变成0      | (101101-&gt;101001,k=3)      | x &amp; ~ (1 &lt; &lt; (k-1))<br>右数第k位取反        | (101001-&gt;101101,k=3)      | x ^ (1 &lt; &lt; (k-1))<br>取末三位              | (1101101-&gt;101)            | x &amp; 7<br>取末k位              | (1101101-&gt;1101,k=5)      | x &amp; ((1 &lt; &lt; k)-1)<br>取右数第k位          | (1101101-&gt;1,k=4)          | x &gt;&gt; (k-1) &amp; 1<br>把末k位变成1          | (101001-&gt;101111,k=4)      | x | (1 &lt; &lt; k-1)<br>末k位取反            | (101001-&gt;100110,k=4)      | x ^ (1 &lt; &lt; k-1)<br>把右边连续的1变成0    | (100101111-&gt;100100000)    | x &amp; (x+1)<br>把右起第一个0变成1    | (100101111-&gt;100111111)    | x | (x+1)<br>把右边连续的0变成1    | (11011000-&gt;11011111)      | x | (x-1)<br>取右边连续的1        | (100101111-&gt;1111)        | (x ^ (x+1)) &gt;&gt; 1<br>去掉右起第一个1的左边 | (100101000-&gt;1000)        | x &amp; (x ^ (x-1))<br>判断奇数       (x&amp;1)==1<br>判断偶数 (x&amp;1)==0       </p><p>乘除法是很消耗时间的，一般情况下位运算的速度要相对快一些。传说用位运算效率提高了60%。</p><p>常用技巧：</p><p>1、  用于整数的奇偶性判断<br>一个整数a, a &amp; 1 这个表达式可以用来判断a的奇偶性。二进制的末位为0表示偶数，最末位为1表示奇数。使用a%2来判断奇偶性和a &amp; 1是一样的作用，但是a &amp; 1要快好多。</p><p>2、  判断n是否是2的正整数冪<br>(!(n&amp;(n-1)) ) &amp;&amp; n<br>举个例子：<br>如果n = 16 = 10000， n-1 = 1111<br>那么：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10000</span><br><span class="line">&amp;1111</span><br><span class="line">---------</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>再举一个例子：如果n = 256 = 100000000， n-1 = 11111111<br>那么：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100000000</span><br><span class="line">&amp;11111111</span><br><span class="line">----------</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>好！看完上面的两个小例子，相信大家都有一个感性的认识。从理论上讲，如果一个数a他是2的正整数幂，那么a 的二进制形式必定为1000…..（后面有0个或者多个0），那么结论就很显然了。</p><p>3、对于正整数的模运算（注意，负数不能这么算）<br>先说下比较简单的：<br>乘除法是很消耗时间的，只要对数左移一位就是乘以2，右移一位就是除以2，传说用位运算效率提高了60%。<br>乘2^k 众所周知： n&lt;&lt;k。所以你以后还会傻傻地去敲2566*4的结果10264吗？直接2566&lt;&lt;2就搞定了，又快又准确。<br>除2^k众所周知： n&gt;&gt;k。<br>那么 mod 2^k 呢？（对2的倍数取模）<br>n&amp;((1&lt;&lt;k)-1)<br>用通俗的言语来描述就是,对2的倍数取模，只要将数与2的倍数-1做按位与运算即可。<br>好！方便理解就举个例子吧。<br>思考：如果结果是要求模2^k时，我们真的需要每次都取模吗?<br>在此很容易让人想到快速幂取模法。<br>快速幂取模算法<br>经常做题目的时候会遇到要计算 a^b mod c 的情况，这时候，一个不小心就TLE了。那么如何解决这个问题呢？位运算来帮你吧。</p><p>首先介绍一下秦九韶算法：(数值分析讲得很清楚)<br>把一个n次多项式f(x) = a[n]x^n+a[n-1]x^(n-1)+……+a[1]x+a[0]改写成如下形式：<br>　　f(x) = a[n]x^n+a[n-1]x^(n-1))+……+a[1]x+a[0]<br>　　= (a[n]x^(n-1)+a[n-1]x^(n-2)+……+a[1])x+a[0]<br>　　= ((a[n]x^(n-2)+a[n-1]x^(n-3)+……+a[2])x+a[1])x+a[0]<br>　　=. …..<br>　　= (……((a[n]x+a[n-1])x+a[n-2])x+……+a[1])x+a[0].<br>　　求多项式的值时，首先计算最内层括号内一次多项式的值，即<br>　　v[1]=a[n]x+a[n-1]<br>　　然后由内向外逐层计算一次多项式的值，即<br>　　v[2]=v[1]x+a[n-2]<br>　　v[3]=v[2]x+a[n-3]<br>　　……<br>　　v[n]=v[n-1]x+a[0]<br>这样，求n次多项式f(x)的值就转化为求n个一次多项式的值。</p><p>好！有了前面的基础知识，我们开始解决问题吧<br>由(a × b) mod c=( (a mod c) × b) mod c.<br>我们可以将 b先表示成就：<br>  b = a[t] × 2^t + a[t-1]× 2^(t-1) + …… + a[0] × 2^0.  (a[i]=[0,1]).<br>这样我们由 a^b  mod  c = (a^(a[t] × 2^t  +  a[t-1] × 2^（t-1） + …a[0] × 2^0) mod c.<br>然而我们求  a^( 2^(i+1) ) mod c=( (a^(2^i)) mod c)^2 mod c .求得。<br>具体实现如下：<br>使用秦九韶算法思想进行快速幂模算法，简洁漂亮<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速计算 (a ^ p) % m 的值</span></span><br><span class="line">__int64 FastM(__int64 a, __int64 p, __int64 m)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    __int64  r = a % m;</span><br><span class="line">    __int64  k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p &amp; <span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (k * r) % m; </span><br><span class="line">        &#125;</span><br><span class="line">        r = (r * r) % m;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">        <span class="keyword">return</span> (r * k) % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、按位异或运算<br>我们还可以得到一个很诡异的swap操作：<br>a  ^=  b;  b ^= a; a ^= b;<br>即a^=b^=a^=b;<br>自己拿起笔来模拟一下就很清楚的了。</p><hr><p>我一直感觉异或运算是很神奇的运算符。<br>因为之前学习博弈论的时候就用到了一个关于异或的神奇性质</p><p>对于一个局面，当且仅当A[1] xor A[2] xor … xor A[N] = 0时，该局面为P局面(即先手必败)。</p><p>对于这个结论的证明如下：</p><ol><li>全0状态为P局面，即A[i]=0，则A[1] xor A[2] xor … xor A[N] = 0。</li><li>从任意一个A[1] xor A[2] xor … xor A[N] = k != 0的状态可以移动到A[1] xor A[2] xor … xor A[N] = 0的状态。由于xor计算的特殊性，我们知道一定有一个A[i]最高位与k最高位的1是相同的，那么必然有A[i] xor k &lt; A[i]的，所以我们可以通过改变A[i]的值为A[i]’，使得A[1] xor A[2] xor … xor A[i]’ xor … xor A[N] = 0。</li><li>对于任意一个局面，若A[1] xor A[2] xor … xor A[N] = 0，则不存在任何一个移动可以使得新的局面A[1] xor A[2] xor … xor A[N] = 0。由于xor计算的特殊性，我们可以知道，一定是存在偶数个1时该位置的1才会被消除。若只改变一个A[i]，无论如何都会使得1的数量发生变化，从而导致A[1] xor A[2] xor … xor A[N] != 0。<br>以上三条满足ICG游戏中N,P局面的转移性质，所以该结论的正确性也得到了证明。</li></ol><p>任何数异或0的结果是本身，异或相同的数是零，所以可以用依次异或来找到数列中独一无二的数。</p><p>#代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("H:\\in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("H:\\out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            ans ^= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="资料" scheme="http://www.winterfell30.com/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>ACM博弈论总结</title>
    <link href="http://www.winterfell30.com/2015/06/20/nimgame/"/>
    <id>http://www.winterfell30.com/2015/06/20/nimgame/</id>
    <published>2015-06-20T07:40:36.000Z</published>
    <updated>2016-11-23T08:09:24.515Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>这篇文章是从我原来的博客上迁移过来的，因为这篇文章对博弈论入门知识的讲解非常清楚易懂。<br>昨天看大白书看到博弈的部分就想起来了这个。<br>不过直接复制过来的话会变成纯文本，效果很差，附上原文链接：<a href="http://blog.csdn.net/dreamon3/article/details/45851941" target="_blank" rel="noopener">点击打开</a>。</p><hr><p>有一种很有意思的游戏，就是有物体若干堆，可以是火柴棍或是围棋子等等均可。两个<br>人轮流从堆中取物体若干，规定最后取光物体者取胜。这是我国民间很古老的一个游戏<br>，别看这游戏极其简单，却蕴含着深刻的数学原理。下面我们来分析一下要如何才能够<br>取胜。</p><p>（一）巴什博奕（Bash Game）：只有一堆n个物品，两个人轮流从这堆物品中取物，规<br>定每次至少取一个，最多取m个。最后取光者得胜。</p><pre><code>显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，</code></pre><p>后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果<br>n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走<br>k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的<br>取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。<br>    这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十<br>个，谁能报到100者胜。<br>（二）威佐夫博奕（Wythoff Game）：有两堆各若干个物品，两个人轮流从某一堆或同<br>时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p><pre><code>这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示</code></pre><p>两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们<br>称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，<br>10）、（8，13）、（9，15）、（11，18）、（12，20）。</p><pre><code>可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有</code></pre><p>如下三条性质：</p><pre><code>1。任何自然数都包含在一个且仅有一个奇异局势中。由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1 ，而 bk= ak + k &gt; ak</code></pre><p>-1 + k-1 = bk-1 &gt; ak-1 。所以性质1。成立。<br>    2。任意操作都可将奇异局势变为非奇异局势。<br>    事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其<br>他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由<br>于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。<br>    3。采用适当的方法，可以将非奇异局势变为奇异局势。</p><pre><code>假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了</code></pre><p>奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b  – bk个物体，即变为奇异局<br>势；如果 a = ak ，  b &lt; bk ,则同时从两堆中拿走 ak – ab + ak个物体,变为奇异局<br>势（ ab – ak , ab – ak+ b – ak）；如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余<br>的数量a – ak 即可；如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k）<br>,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – a<br>j 即可。</p><pre><code>从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜</code></pre><p>；反之，则后拿者取胜。</p><pre><code>那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：ak =[k（1+√5）/2]，bk= ak + k  （k=0，1，2，…,n 方括号表示取整函数)</code></pre><p>奇妙的是其中出现了黄金分割数（1+√5）/2 = 1。618…,因此,由ak，bk组成的矩形近<br>似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[<br>j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1</p><ul><li>j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异<br>局势。</li></ul><p>（三）尼姆博奕（Nimm Game）：有三堆各若干个物品，两个人轮流从某一堆取任意多的<br>物品，规定每次至少取一个，多者不限，最后取光者得胜。</p><pre><code>这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首</code></pre><p>先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是<br>（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一<br>下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情<br>形。</p><pre><code>计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示</code></pre><p>这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结<br>果：</p><p>1 =二进制01<br>2 =二进制10<br>3 =二进制11 （+）<br>———————<br>0 =二进制00 （注意不进位）</p><pre><code>对于奇异局势（0，n，n）也一样，结果也是0。任何奇异局势（a，b，c）都有a（+）b（+）c =0。</code></pre><p>如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b<br>&lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果: a（+）b（+）(a（+）<br>b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（<br>a（+）b）即可。</p><pre><code>例1。（14，21，39），14（+）21=27，39-27=12，所以从39中拿走12个物体即可达</code></pre><p>到奇异局势（14，21，27）。</p><pre><code>例2。（55，81，121），55（+）81=102，121-102=19，所以从121中拿走19个物品</code></pre><p>就形成了奇异局势（55，81，102）。</p><pre><code>例3。（29，45，58），29（+）45=48，58-48=10，从58中拿走10个，变为（29，4</code></pre><p>5，48）。</p><pre><code>例4。我们来实际进行一盘比赛看看：    甲:(7,8,9)-&gt;(1,8,9)奇异局势    乙:(1,8,9)-&gt;(1,8,4)    甲:(1,8,4)-&gt;(1,5,4)奇异局势    乙:(1,5,4)-&gt;(1,4,4)    甲:(1,4,4)-&gt;(0,4,4)奇异局势    乙:(0,4,4)-&gt;(0,4,2)    甲:(0.4,2)-&gt;(0,2,2)奇异局势    乙:(0,2,2)-&gt;(0,2,1)    甲:(0,2,1)-&gt;(0,1,1)奇异局势    乙:(0,1,1)-&gt;(0,1,0)    甲:(0,1,0)-&gt;(0,0,0)奇异局势    甲胜。</code></pre><p>取火柴的游戏<br>题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，<br>可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法。<br>题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，<br>可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。<br>嘿嘿，这个游戏我早就见识过了。小时候用珠算玩这个游戏：第一档拨一个，第二档拨两个，依次直到第五档拨五个。然后两个人就轮流再把棋子拨下来，谁要是最后一个拨谁就赢。有一次暑假看见两个小孩子在玩这个游戏，我就在想有没有一个定论呢。下面就来试着证明一下吧<br>先解决第一个问题吧。<br>定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则，<br>为利己态，用S表示。<br>[定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。<br>证明：<br>    若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态，<br>      c = A(1) xor A(2) xor … xor A(n) &gt; 0;<br>    把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。<br>    那么我们把x = A(t) xor c,则得到x &lt; A(t).这是因为既然A(t)的第p位与c的第p位同为1,那么x的第p位变为0,而高于p的位并没有改变。所以x &lt; A(t).而<br>    A(1) xor A(2) xor … xor x xor … xor A(n)<br>  = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n)<br>  = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n)<br>  = 0<br>这就是说从A(t)堆中取出 A(t) – x 根火柴后状态就会从S态变为T态。证毕<br>[定理2]：T态，取任何一堆的若干根，都将成为S态。<br>证明：用反证法试试。<br>      若<br>      c = A(1) xor A(2) xor … xor A(i) xor … xor A(n) = 0；<br>      c’ = A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = 0;<br>      则有<br>c xor c’ = A(1) xor A(2) xor … xor A(i) xor … xor A(n) xor A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = A(i) xor A(i’) =0<br>      进而推出A(i) = A(i’)，这与已知矛盾。所以命题得证。<br>[定理 3]：S态，只要方法正确，必赢。<br>  最终胜利即由S态转变为T态，任何一个S态，只要把它变为T态，（由定理1，可以把它变成T态。）对方只能把T态转变为S态(定理2)。这样，所有S态向T态的转变都可以有己方控制，对方只能被动地实现由T态转变为S态。故S态必赢。<br>[定理4]：T态，只要对方法正确，必败。<br>  由定理3易得。<br>接着来解决第二个问题。<br>定义：若一堆中仅有1根火柴，则被称为孤单堆。若大于1根，则称为充裕堆。<br>定义：T态中，若充裕堆的堆数大于等于2，则称为完全利他态，用T2表示；若充裕堆的堆数等于0，则称为部分利他态，用T0表示。</p><p>孤单堆的根数异或只会影响二进制的最后一位，但充裕堆会影响高位（非最后一位）。一个充裕堆，高位必有一位不为0，则所有根数异或不为0。故不会是T态。<br>[定理5]：S0态，即仅有奇数个孤单堆，必败。T0态必胜。<br>证明：<br>S0态，其实就是每次只能取一根。每次第奇数根都由己取，第偶数根都由对<br>方取，所以最后一根必己取。败。同理,  T0态必胜#<br>[定理6]：S1态，只要方法正确，必胜。<br>证明：<br>若此时孤单堆堆数为奇数，把充裕堆取完；否则，取成一根。这样，就变成奇数个孤单堆，由对方取。由定理5，对方必输。己必胜。  #<br>[定理7]：S2态不可转一次变为T0态。<br>证明：<br>充裕堆数不可能一次由2变为0。得证。  # </p><p>[定理8]：S2态可一次转变为T2态。<br>证明：<br>由定理1，S态可转变为T态，态可一次转变为T态，又由定理6，S2态不可转一次变为T0态，所以转变的T态为T2态。  #<br>[定理9]：T2态，只能转变为S2态或S1态。<br>证明：<br>由定理2，T态必然变为S态。由于充裕堆数不可能一次由2变为0，所以此时的S态不可能为S0态。命题得证。<br>[定理10]：S2态，只要方法正确，必胜.<br>证明：<br>方法如下：<br>      1）  S2态，就把它变为T2态。（由定理8）<br>      2）  对方只能T2转变成S2态或S1态（定理9）<br>    若转变为S2,  转向1）<br>    若转变为S1,  这己必胜。（定理5）<br>[定理11]：T2态必输。<br>证明：同10。<br>综上所述，必输态有：  T2,S0<br>          必胜态：    S2,S1,T0.<br>两题比较：<br>第一题的全过程其实如下：<br>S2-&gt;T2-&gt;S2-&gt;T2-&gt;  ……  -&gt;T2-&gt;S1-&gt;T0-&gt;S0-&gt;T0-&gt;……-&gt;S0-&gt;T0(全0)<br>第二题的全过程其实如下：<br>S2-&gt;T2-&gt;S2-&gt;T2-&gt;  ……  -&gt;T2-&gt;S1-&gt;S0-&gt;T0-&gt;S0-&gt;……-&gt;S0-&gt;T0(全0)<br>下划线表示胜利一方的取法。  是否发现了他们的惊人相似之处。<br>我们不难发现(见加黑部分)，S1态可以转变为S0态（第二题做法），也可以转变为<br>T0（第一题做法）。哪一方控制了S1态，他即可以有办法使自己得到最后一根（转变为<br>T0）,也可以使对方得到最后一根（转变为S0）。<br>  所以，抢夺S1是制胜的关键！<br>  为此，始终把T2态让给对方，将使对方处于被动状态，他早晚将把状态变为S1.</p><p>推荐HDOJ题目<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1907" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1907</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2509" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2509</a><br>看完上面的结论，就能顺利解决上面2道了</p><p>S-Nim<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1536" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1536</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1944" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1944</a></p><p>博弈算法入门小节 1536 1517 1907<br>小子最近迷途于博弈之中。。。感触颇深。<br>为了让大家能够在学习博弈的时候少走弯路，最重要的也是为了加深自己的影响，温故而知新，特发此贴与大家共勉。<br>学博弈先从概念开始：<br>特别推荐LCY老师的课件：博弈入门。<br>下载地址：<a href="http://acm.hdu.edu.cn/forum/read.php?tid=6875" target="_blank" rel="noopener">http://acm.hdu.edu.cn/forum/read.php?tid=6875</a><br>这个课件个人认为从博弈的基本思想，一直到解博弈的中心算法做了很好的诠释。但是特别要注意的是。课件后面一部分英语写的讲义是重中之重。小子英语很弱，在这困扰很久。现在为大家大概介绍一下。<br>主要是后继点和SG值的问题:<br>SG值：一个点的SG值就是一个不等于它的后继点的SG的且大于等于零的最小整数。<br>后继点：也就是按照题目要求的走法（比如取石子可以取的数量，方法）能够走一步达到的那个点。<br>具体的有关SG值是怎么运用的希望大家自己多想想。<br>课件后面有一个1536的代码。可以放在后面做做<br>看到这里推荐大家做几道题：1846（最简单的博弈水题）<br>1847（求SG值）</p><p>有了上面的知识接下来我们来看看组合博弈（n堆石子）<br>推荐大家看个资料：<br>博弈-取石子游戏(推荐等级五星级)<br><a href="http://acm.hdu.edu.cn/forum/read.php?fid=20&amp;tid=5748" target="_blank" rel="noopener">http://acm.hdu.edu.cn/forum/read.php?fid=20&amp;tid=5748</a><br><a href="http://hi.baidu.com/netnode/blog/item/30932c2edc7384514fc226ea.html" target="_blank" rel="noopener">http://hi.baidu.com/netnode/blog/item/30932c2edc7384514fc226ea.html</a><br>这里提出了一个奇异状态的问题。看了这篇文章你会发现异或运算在博弈中使用的妙处。当然这里指出的只是组合博弈中一种特殊情况。<br>王道还是对SG值的求解，但是知道这么一种思路无疑对思维的广度和深度扩展是很有帮助的。<br>ZZ博弈<br><a href="http://acm.hdu.edu.cn/forum/read.php?fid=9&amp;tid=10617" target="_blank" rel="noopener">http://acm.hdu.edu.cn/forum/read.php?fid=9&amp;tid=10617</a><br>这里介绍了组和博弈的两种大的类型，一种是最后取的是N状态一种是最后取的是P状态，两个状态的解题方法能看懂很有帮助。当然，能够把推导过程理解，吃透无疑是大牛级的做法~小子也佩服的紧~<br>    1536题推荐做做这题，这题前面提醒大家是一个求SG值的题目，题目前面是对异或运算运用在组合博弈问题中的很好的解释。当然题目本身是有所不同的。因为在这里面对取法有所要求。那么这样就回归到了解决博弈问题的王道算法——求SG值上。<br>    有关运用求SG值的博弈题目有： 1850（也可基于奇异状态异或）<br>1848（中和的大斐波那契数列的典型求SG值题）<br>1517（个人认为有点猥琐的题目。。。。在此题上困扰很久。当然搞出来很开心。小子是用比较规矩的求SG值的方法求出来的，但是论坛有人对其推出来了规律，这里佩服一下，大家可以学习一下）<br>1079（更猥琐的题目，对新手要求较高，因为按传统方法需要比较细致的模拟加对边角状态的考虑，同样有人推出来了公式）<br>当你全部看完以上的东西。做完以上的题目的话。。。小子恭喜你~你博弈入门了~~~~<br>    这里小子告诉大家。博弈很强大。学习要耐心~谢谢<br>Current System Time : 2008-12-11 19:16:03</p><p>ACM课作业：<br>1001 Brave Game<br>1002 Good Luck in CET-4 Everybody!<br>1003 Fibonacci again and again<br>1004 Rabbit and Grass<br>1005 Being a Good Boy in Spring Festival<br>1006 Public Sale<br>1007 悼念512汶川大地震遇难同胞——选拔志愿者<br>1008 kiki’s game<br>1009 Calendar Game<br>1010 A Multiplication Game<br>1011 Digital Deletions<br>1012 S-Nim<br><a href="http://acm.hdu.edu.cn/forum/read.php?tid=11339&amp;fpage=0&amp;toread=&amp;page=1" target="_blank" rel="noopener">http://acm.hdu.edu.cn/forum/read.php?tid=11339&amp;fpage=0&amp;toread=&amp;page=1</a></p><p>1536的参考代码<br>本部分设定了隐藏,您已回复过了,以下是隐藏的内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//博弈-基于求SG值</span></span><br><span class="line"><span class="comment">//Accepted 1536 578MS 416K 904 B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>”iostream”</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">101</span>],sg[<span class="number">10001</span>],k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mex</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-f&lt;<span class="number">0</span>)<span class="comment">//b-f后继点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(sg[b-f]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sg[b-f]=mex(b-f);</span><br><span class="line">        &#125;</span><br><span class="line">        a[sg[b-f]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        <span class="keyword">if</span>(!a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,t,n,s,bead,j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k,k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(sg,<span class="number">-1</span>,<span class="keyword">sizeof</span>(sg));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">                <span class="keyword">if</span>(f&gt;f[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    f+=f[j];</span><br><span class="line">                    f[j]=f-f[j];</span><br><span class="line">                    f-=f[j];</span><br><span class="line">                &#125;</span><br><span class="line">        sg[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span>(t–)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">            s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n–)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; bead;<span class="comment">//该堆的成员个数</span></span><br><span class="line">                <span class="keyword">if</span>(sg[bead]==<span class="number">-1</span>)</span><br><span class="line">                    sg[bead]=mex(bead);</span><br><span class="line">                s=s^sg[bead];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; “L”;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; “W”;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1517参考代码<br>本部分设定了隐藏,您已回复过了,以下是隐藏的内容<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//博弈-基于求SG值</span></span><br><span class="line"><span class="comment">//Accepted 1517 234MS 0K 837 B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>”iostream”</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 a[<span class="number">7000</span>]=&#123;<span class="number">1</span>&#125;,<span class="built_in">min</span>,n;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">10</span>],sg[<span class="number">7000</span>],i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">10</span>;p=<span class="number">0</span>,i++);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">7000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>,<span class="built_in">min</span>=<span class="number">-1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span>==<span class="number">-1</span>||a[p[j]]*j&lt;a[p[<span class="built_in">min</span>]]*<span class="built_in">min</span>)</span><br><span class="line">                <span class="built_in">min</span>=j;</span><br><span class="line">        a=a[p[<span class="built_in">min</span>]]*<span class="built_in">min</span>;</span><br><span class="line">        <span class="built_in">min</span>=a[p[<span class="built_in">min</span>]]*<span class="built_in">min</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">5000000000</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[p[j]]*j==<span class="built_in">min</span>)</span><br><span class="line">                p[j]++;</span><br><span class="line">    &#125;<span class="comment">//从小到大求出所有乘积</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(“%I64d”,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sg=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;a[j]*<span class="number">9</span>&gt;=n&amp;&amp;j&gt;=<span class="number">0</span>;j–)</span><br><span class="line">            sg[j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k=j+<span class="number">1</span>;k&lt;i&amp;&amp;a[j]*<span class="number">9</span>&gt;=a[k];k++)</span><br><span class="line">                <span class="keyword">if</span>(a[k]%a[j]==<span class="number">0</span>&amp;&amp;sg[k]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sg[j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            j–;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(sg[<span class="number">0</span>]?”Stan wins.”:”Ollie wins.”);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里感谢shǎ崽同学的一段代码让小子学会了puts的妙用</p><p>1907参考代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int temp,t,n,s,x,i;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t–)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for(i=s=temp=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            if(x&gt;1)    temp=1;</span><br><span class="line">            s^=x;</span><br><span class="line">        &#125;</span><br><span class="line">        if((s&amp;&amp;temp)||(!s&amp;&amp;!temp))</span><br><span class="line">            cout &lt;&lt; “John” &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; “Brother” &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="资料" scheme="http://www.winterfell30.com/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>十个利用矩阵乘法解决的经典题目（Matrix67)</title>
    <link href="http://www.winterfell30.com/2015/06/09/Matrixlearn/"/>
    <id>http://www.winterfell30.com/2015/06/09/Matrixlearn/</id>
    <published>2015-06-09T13:28:52.000Z</published>
    <updated>2016-11-23T08:09:18.679Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>做了一个用到矩阵快速幂的题目，然后看到了这么一篇转载自Matrix67的关于矩阵的文章，感觉很感兴趣就收藏过来了。<br>我学东西真是随心所欲啊。。。看到什么学什么，感觉这样不太好。<br>不过这也就是计算机一直吸引着我的原因吧。。。总是有新鲜有趣的东西，那又何苦逼迫着自己学东西呢。</p><h2 id="Matrix67的博客地址就不发了，下面正文。"><a href="#Matrix67的博客地址就不发了，下面正文。" class="headerlink" title="Matrix67的博客地址就不发了，下面正文。"></a>Matrix67的博客地址就不发了，下面正文。</h2><p>好像目前还没有这方面题目的总结。这几天连续看到四个问这类题目的人，今天在这里简单写一下。这里我们不介绍其它有关矩阵的知识，只介绍矩阵乘法和相关性质。<br>    不要以为数学中的矩阵也是黑色屏幕上不断变化的绿色字符。在数学中，一个矩阵说穿了就是一个二维数组。一个n行m列的矩阵可以乘以一个m行p列的矩阵，得到的结果是一个n行p列的矩阵，其中的第i行第j列位置上的数等于前一个矩阵第i行上的m个数与后一个矩阵第j列上的m个数对应相乘后所有m个乘积的和。比如，下面的算式表示一个2行2列的矩阵乘以2行3列的矩阵，其结果是一个2行3列的矩阵。其中，结果的那个4等于2<em>2+0</em>1：</p><pre><code>下面的算式则是一个1 x 3的矩阵乘以3 x 2的矩阵，得到一个1 x 2的矩阵：矩阵乘法的两个重要性质：一，矩阵乘法不满足交换律；二，矩阵乘法满足结合律。为什么矩阵乘法不满足交换律呢？废话，交换过来后两个矩阵有可能根本不能相乘。为什么它又满足结合律呢？仔细想想你会发现这也是废话。假设你有三个矩阵A、B、C，那么(AB)C和A(BC)的结果的第i行第j列上的数都等于所有A(ik)*B(kl)*C(lj)的和（枚举所有的k和l）。</code></pre><p>经典题目1 给定n个点，m个操作，构造O(m+n)的算法输出m个操作后各点的位置。操作有平移、缩放、翻转和旋转<br>    这里的操作是对所有点同时进行的。其中翻转是以坐标轴为对称轴进行翻转（两种情况），旋转则以原点为中心。如果对每个点分别进行模拟，那么m个操作总共耗时O(mn)。利用矩阵乘法可以在O(m)的时间里把所有操作合并为一个矩阵，然后每个点与该矩阵相乘即可直接得出最终该点的位置，总共耗时O(m+n)。假设初始时某个点的坐标为x和y，下面5个矩阵可以分别对其进行平移、旋转、翻转和旋转操作。预先把所有m个操作所对应的矩阵全部乘起来，再乘以(x,y,1)，即可一步得出最终点的位置。</p><p>经典题目2 给定矩阵A，请快速计算出A^n（n个A相乘）的结果，输出的每个数都mod p。<br>    由于矩阵乘法具有结合律，因此A^4 = A <em> A </em> A <em> A = (A</em>A) <em> (A</em>A) = A^2 <em> A^2。我们可以得到这样的结论：当n为偶数时，A^n = A^(n/2) </em> A^(n/2)；当n为奇数时，A^n = A^(n/2) <em> A^(n/2) </em> A （其中n/2取整）。这就告诉我们，计算A^n也可以使用二分快速求幂的方法。例如，为了算出A^25的值，我们只需要递归地计算出A^12、A^6、A^3的值即可。根据这里的一些结果，我们可以在计算过程中不断取模，避免高精度运算。</p><p>经典题目3 POJ3233 (感谢rmq)<br>    题目大意：给定矩阵A，求A + A^2 + A^3 + … + A^k的结果（两个矩阵相加就是对应位置分别相加）。输出的数据mod m。k&lt;=10^9。<br>    这道题两次二分，相当经典。首先我们知道，A^i可以二分求出。然后我们需要对整个题目的数据规模k进行二分。比如，当k=6时，有：<br>    A + A^2 + A^3 + A^4 + A^5 + A^6 =(A + A^2 + A^3) + A^3*(A + A^2 + A^3)<br>    应用这个式子后，规模k减小了一半。我们二分求出A^3后再递归地计算A + A^2 + A^3，即可得到原问题的答案。</p><p>经典题目4 VOJ1049<br>    题目大意：顺次给出m个置换，反复使用这m个置换对初始序列进行操作，问k次置换后的序列。m&lt;=10, k&lt;2^31。<br>    首先将这m个置换“合并”起来（算出这m个置换的乘积），然后接下来我们需要执行这个置换k/m次（取整，若有余数则剩下几步模拟即可）。注意任意一个置换都可以表示成矩阵的形式。例如，将1 2 3 4置换为3 1 2 4，相当于下面的矩阵乘法：</p><pre><code>置换k/m次就相当于在前面乘以k/m个这样的矩阵。我们可以二分计算出该矩阵的k/m次方，再乘以初始序列即可。做出来了别忙着高兴，得意之时就是你灭亡之日，别忘了最后可能还有几个置换需要模拟。</code></pre><p>经典题目5 《算法艺术与信息学竞赛》207页（2.1代数方法和模型，[例题5]细菌，版次不同可能页码有偏差）<br>    大家自己去看看吧，书上讲得很详细。解题方法和上一题类似，都是用矩阵来表示操作，然后二分求最终状态。</p><p>经典题目6 给定n和p，求第n个Fibonacci数mod p的值，n不超过2^31<br>    根据前面的一些思路，现在我们需要构造一个2 x 2的矩阵，使得它乘以(a,b)得到的结果是(b,a+b)。每多乘一次这个矩阵，这两个数就会多迭代一次。那么，我们把这个2 x 2的矩阵自乘n次，再乘以(0,1)就可以得到第n个Fibonacci数了。不用多想，这个2 x 2的矩阵很容易构造出来：</p><p>经典题目7 VOJ1067<br>    我们可以用上面的方法二分求出任何一个线性递推式的第n项，其对应矩阵的构造方法为：在右上角的(n-1)*(n-1)的小矩阵中的主对角线上填1，矩阵第n行填对应的系数，其它地方都填0。例如，我们可以用下面的矩阵乘法来二分计算f(n) = 4f(n-1) - 3f(n-2) + 2f(n-4)的第k项：</p><pre><code>利用矩阵乘法求解线性递推关系的题目我能编出一卡车来。这里给出的例题是系数全为1的情况。</code></pre><p>经典题目8 给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值<br>    把给定的图转为邻接矩阵，即A(i,j)=1当且仅当存在一条边i-&gt;j。令C=A<em>A，那么C(i,j)=ΣA(i,k)</em>A(k,j)，实际上就等于从点i到点j恰好经过2条边的路径数（枚举k为中转点）。类似地，C*A的第i行第j列就表示从i到j经过3条边的路径数。同理，如果要求经过k步的路径数，我们只需要二分求出A^k即可。</p><p>经典题目9 用1 x 2的多米诺骨牌填满M x N的矩形有多少种方案，M&lt;=5，N&lt;2^31，输出答案mod p的结果</p><pre><code>我们以M=3为例进行讲解。假设我们把这个矩形横着放在电脑屏幕上，从右往左一列一列地进行填充。其中前n-2列已经填满了，第n-1列参差不齐。现在我们要做的事情是把第n-1列也填满，将状态转移到第n列上去。由于第n-1列的状态不一样（有8种不同的状态），因此我们需要分情况进行讨论。在图中，我把转移前8种不同的状态放在左边，转移后8种不同的状态放在右边，左边的某种状态可以转移到右边的某种状态就在它们之间连一根线。注意为了保证方案不重复，状态转移时我们不允许在第n-1列竖着放一个多米诺骨牌（例如左边第2种状态不能转移到右边第4种状态），否则这将与另一种转移前的状态重复。把这8种状态的转移关系画成一个有向图，那么问题就变成了这样：从状态111出发，恰好经过n步回到这个状态有多少种方案。比如，n=2时有3种方案，111-&gt;011-&gt;111、111-&gt;110-&gt;111和111-&gt;000-&gt;111，这与用多米诺骨牌覆盖3x2矩形的方案一一对应。这样这个题目就转化为了我们前面的例题8。后面我写了一份此题的源代码。你可以再次看到位运算的相关应用。</code></pre><p>经典题目10 POJ2778<br>    题目大意是，检测所有可能的n位DNA串有多少个DNA串中不含有指定的病毒片段。合法的DNA只能由ACTG四个字符构成。题目将给出10个以内的病毒片段，每个片段长度不超过10。数据规模n&lt;=2 000 000 000。<br>    下面的讲解中我们以ATC,AAA,GGC,CT这四个病毒片段为例，说明怎样像上面的题一样通过构图将问题转化为例题8。我们找出所有病毒片段的前缀，把n位DNA分为以下7类：以AT结尾、以AA结尾、以GG结尾、以?A结尾、以?G结尾、以?C结尾和以??结尾。其中问号表示“其它情况”，它可以是任一字母，只要这个字母不会让它所在的串成为某个病毒的前缀。显然，这些分类是全集的一个划分（交集为空，并集为全集）。现在，假如我们已经知道了长度为n-1的各类DNA中符合要求的DNA个数，我们需要求出长度为n时各类DNA的个数。我们可以根据各类型间的转移构造一个边上带权的有向图。例如，从AT不能转移到AA，从AT转移到??有4种方法（后面加任一字母），从?A转移到AA有1种方案（后面加个A），从?A转移到??有2种方案（后面加G或C），从GG到??有2种方案（后面加C将构成病毒片段，不合法，只能加A和T）等等。这个图的构造过程类似于用有限状态自动机做串匹配。然后，我们就把这个图转化成矩阵，让这个矩阵自乘n次即可。最后输出的是从??状态到所有其它状态的路径数总和。<br>    题目中的数据规模保证前缀数不超过100，一次矩阵乘法是三方的，一共要乘log(n)次。因此这题总的复杂度是100^3 * log(n)，AC了。</p><pre><code>最后给出第9题的代码供大家参考（今天写的，熟悉了一下C++的类和运算符重载）。为了避免大家看代码看着看着就忘了，我把这句话放在前面来说：Matrix67原创，转贴请注明出处。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE (1&lt;&lt;m)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 32</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">long</span> element[MAX_SIZE][MAX_SIZE];</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setModulo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        CMatrix <span class="keyword">operator</span>* (CMatrix);</span><br><span class="line">        <span class="function">CMatrix <span class="title">power</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">long</span> modulo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMatrix::setSize</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a; j++)</span><br><span class="line">            element[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">size</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMatrix::setModulo</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    modulo = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMatrix CMatrix::<span class="keyword">operator</span>* (CMatrix param)</span><br><span class="line">&#123;</span><br><span class="line">    CMatrix product;</span><br><span class="line">    product.setSize(<span class="built_in">size</span>);</span><br><span class="line">    product.setModulo(modulo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">size</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="built_in">size</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="built_in">size</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                product.element[i][j]+=element[i][k]*param.element[k][j];</span><br><span class="line">                product.element[i][j]%=modulo;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CMatrix <span class="title">CMatrix::power</span><span class="params">(<span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMatrix tmp = (*<span class="keyword">this</span>) * (*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span>==<span class="number">1</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> &amp; <span class="number">1</span>) <span class="keyword">return</span> tmp.power(<span class="built_in">exp</span>/<span class="number">2</span>) * (*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tmp.power(<span class="built_in">exp</span>/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> validSet[]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">24</span>,<span class="number">27</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">long</span> n, m, p;</span><br><span class="line">    CMatrix unit;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    unit.setSize(SIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;SIZE; j++)</span><br><span class="line">            <span class="keyword">if</span>( ((~i)&amp;j) == ((~i)&amp;(SIZE<span class="number">-1</span>)) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> <span class="built_in">isValid</span>=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">8</span>; k++)<span class="built_in">isValid</span>=<span class="built_in">isValid</span>||(i&amp;j)==validSet[k];</span><br><span class="line">                unit.element[i][j]=<span class="built_in">isValid</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    unit.setModulo(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, unit.power(n).element[SIZE<span class="number">-1</span>][SIZE<span class="number">-1</span>] );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="资料" scheme="http://www.winterfell30.com/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>《高质量C++编程指南》即C++编程规范</title>
    <link href="http://www.winterfell30.com/2015/06/06/C-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://www.winterfell30.com/2015/06/06/C-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</id>
    <published>2015-06-06T03:32:14.000Z</published>
    <updated>2016-11-23T08:08:12.379Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p><p>看到很多大神们的代码符号之间一些空格感觉很漂亮，于是也打算开始使用这种风格写代码，后来发现原来不只是空格，还有很多写法都是不符合标准的，于是开始看C++的编程规范，让代码尽量标准化一点，但是左大括号不要重起一行这条可以去死了。。。<br>以下为转载，原文链接点这里：<a href="http://www.cnblogs.com/dongzhiquan/archive/2010/11/20/1994534.html" target="_blank" rel="noopener">仓</a>。</p><p>读这本书,感觉非常有用.只是有些公用的规则就不一一列举,只记下自己以前不是那么清楚地规则。</p><pre><code>代码质量保证优先原则:    （1）正确性，指程序要实现设计要求的功能。    （2）稳定性、安全性，指程序稳定、可靠、安全。    （3）可测试性，指程序要具有良好的可测试性。    （4）规范/可读性，指程序书写风格、命名规则等要符合规范。    （5）全局效率，指软件系统的整体效率。    （6）局部效率，指某个模块/子模块/函数的本身效率。    （7）个人表达方式/个人方便性，指个人编程习惯。C语言中，static局部变量将在内存“数据区”中生成，而非static局部变量将在“堆栈”中生成。长语句分多行书写比:在低优先级操作符处划分新行，可使每一行具有相当独立而完整的含义，从而比较清晰。折行时，操作符要放行首。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。如果case 语句中需要定义新的变量,则必须用{}括起来,否则可以不必用{}.内存释放后，一定要把指针置为NULL.编程时，要防止差1错误。有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）某些语句经编译后产生告警，但如果你确认它是正确的，那么应通过某种手段去掉告警信息。C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</code></pre><p>内存分配:<br>    内存分配方式有三种：<br>    （1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。<br>    （2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>    （3） 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多释放了内存却继续使用它。<br>    有三种情况：<br>    （1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。<br>    （2）函数的 return 语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用” ，因为该内存在函数体结束时被自动销毁。<br>    （3）使用 free 或 delete 释放了内存后，没有将指针设置为 NULL。导致产生“野指针” 。<br>        char a[] = “hello”;<br>        a[0] = ‘X’;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>        char <em>p = “world”;     //  注意 p 指向常量字符串<br>        p[0] = ‘X’;            //  编译器不能发现该错误<br>        cout &lt;&lt; p &lt;&lt; endl;<br>格式:<br>    在每个类声明之后、每个函数定义结束之后都要加空行。<br>空格添加:<br>    函数名之后不要留空格，紧跟左括号‘ （’ ，以与关键字区别。<br>    ‘ （’向后紧跟， ‘） ’ 、 ‘， ’ 、 ‘;’向前紧跟，紧跟处不留空格。<br>    象 if、for、while 等关键字之后应留一个空格再跟左括号‘ （’ ，以突出关键字。<br>    如果‘;’不是一行的结束符号，其后要留空格，如 for (initialization; condition; update)。<br>    if、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。<br>    逗号、分号只在后面加空格。<br>    赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“=” 、 “+=”  “&gt;=” 、 “&lt;=” 、 “+” 、 “</em>” 、 “%” 、 “&amp;&amp;” 、 “||” 、 “&lt;&lt;”,“^”等二元操作符的前后应当加空格。<br>    一元操作符如“!” 、 “~” 、 “++” 、 “–” 、 “&amp;” （地址运算符）等前后不加空格。<br>        应当将修饰符 <em>  和  ＆  紧靠变量名<br>        若将修饰符 </em>  靠近数据类型，例如：int<em>  x;  从语义上讲此写法比较直观，即 x 是<br>        int  类型的指针。<br>        上述写法的弊端是容易引起误解，例如：int</em>  x, y;  此处 y 容易被误解为指针变量。<br>        虽然将 x 和 y 分行定义可以避免误解，但并不是人人都愿意这样做。<br>    对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格，如 for (i=0; i&lt;10; i++)和 if ((a&lt;=b) &amp;&amp; (c&lt;=d))<br>        不好的实践:for (i = 0; I &lt; 10; i ++)                 //  过多的空格<br>注释:<br>    对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。<br>    好的实践:当代码规模较大,逻辑复杂时,先写注释，再写代码有利于理清思路.<br>    将注释与其上面的代码用空行隔开.<br>    在命名良好的程序里可以减少注释,充分利用代码的自注释.<br>    注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。<br>    通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。<br>参数:<br>    明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。<br>    非调度函数应减少或防止控制参数，尽量只使用数据参数。 (本建议目的是防止函数间的控制耦合。调度函数是指根据输入的消息类型或控制命令，来启动相应的功能实体（即函数或过程），而本身并不完成具体功能。控制参数是指改变函数功能行为的参数，即函数要根据此参数来决定具体怎样工作。非调度函数的控制参数增加了函数间的控制耦合，很可能使函数间的耦合度增大，并使函数的功能不唯一。)<br>函数:<br>    功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。<br>    当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。<br>      示例：在某过程中较多引用TheReceiveBuffer[FirstSocket].byDataPtr，则可以通过以下宏定义来代替：# define pSOCKDATA TheReceiveBuffer[FirstScoket].byDataPtr<br>DEBUG:<br>    同一工程调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。<br>    使用断言来发现软件问题，提高代码可测性。<br>        下面是C语言中的一个断言，用宏来设计的。（其中NULL为0L）</p><pre><code>#ifdef _EXAM_ASSERT_TEST_ // 若使用断言测试    void exam_assert( char * file_name, unsigned int line_no )    {        printf( &quot;\n[EXAM]Assert failed: %s, line %u\n&quot;,        file_name, line_no );        abort( );    }    #define EXAM_ASSERT( condition )    if (condition) // 若条件成立，则无动作        NULL;    else // 否则报告        exam_assert( __FILE__, __LINE__ )#else // 若不使用断言测试    #define EXAM_ASSERT(condition) NULL#endif /* end of ASSERT */</code></pre><p>循环:<br>    在多重循环中，应将最忙的循环放在最内层。(说明：减少CPU切入循环层的次数。)<br>    在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层， 以减少CPU跨切循环层的次数。<br>    避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。(说明：目的是减少判断次数。循环体中的判断语句是否可以移到循环体外，要视程序的具体情况而言，一般情况，与循环变量无关的判断语句可以移到循环体外，而有关的则不可以。)<br>细节:<br>    尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。(说明：浮点运算除法要占用较多CPU资源。#define PAI_RECIPROCAL (1 / 3.1416 ) // 编译器编译时，将生成具体浮点数)</p><p>////////////////////////////////</p><p>头文件:<br>    头文件的作用:<br>        （1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。<br>        （2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。<br>    头文件中只存放“声明”而不存放“定义”;头文件里面需要放置定义的情况<br>    不提倡使用全局变量，尽量不要在头文件中出现象 extern int value  这类声明。 ;Extern作用(参考C++programming)<br>类:<br>    （1）将private 类型的数据写在前面，而将 public 类型的函数写在后面。采用这种版式的程序员主张类的设计“以数据为中心” ，重点关注类的内部结构。<br>    （2）将public 类型的函数写在前面，而将 private 类型的数据写在后面。采用这种版式的程序员主张类的设计“以行为为中心” ，重点关注的是类应该提供什么样的接口（或服务） 。<br>    全局函数和类的成员函数同名不算重载，因为函数的作用域不同。</p><pre><code>全局函数被调用时应加‘::’标志。如  ::Print(…); //  表示 Print 是全局函数而非成员函数。    成员函数被重载的特征：     （1）相同的范围（在同一个类中） ；     （2）函数名字相同；     （3）参数不同；     （4）virtual 关键字可有可无。 覆盖是指派生类函数覆盖基类函数，特征是：     （1）不同的范围（分别位于派生类与基类） ；     （2）函数名字相同；     （3）参数相同；     （4）基类函数必须有 virtual 关键字。“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：     （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆） 。     （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。    很多 C++程序员没有意识到有“隐藏”这回事。由于认识不够深刻，“隐藏”的发生可谓神出鬼没，常常产生令人迷惑的结果。     初始化表达式表（简称初始化表）:初始化表位于函数参数表之后，却在函数体{}之前。这说明该表里的初始化工作发生在函数体内的任何代码被执行之前。 构造函数初始化表的使用规则：    如果类存在继承关系，派生类必须在其初始化表里调用基类的构造函数。    类的 const 常量只能在初始化表里被初始化，因为它不能在函数体内用赋值的方式来初始化.    非内部数据类型的成员对象应当采用第一种方式初始化，以获取更高的效率。如果不主动编写拷贝构造函数和赋值函数，编译器将以“位拷贝”的方式自动生成缺省的函数。倘若类中含有指针变量，那么这两个缺省的函数就隐含了错误,赋值前后对象中的指针变量将指向同一块内存,导致无法正确释放内存。    String  c = a; //  调用了拷贝构造函数，最好写成 c(a);     c = b;  //  调用了赋值函数     第三个语句的风格较差，宜改写成 String c(a)以区别于第四个语句。如果类之间存在继承关系，在编写上述基本函数时应注意以下事项：     派生类的构造函数应在其初始化表里调用基类的构造函数。     基类与派生类的析构函数应该为虚（即加 virtual 关键字）</code></pre><p>命名:<br>    一般来说，长名字能更好地表达含义，所以函数名、变量名、类名长达十几个字符不足为怪。那么名字是否越长约好？不见得!  例如变量名 maxval 就比 maxValueUntilOverflow好用。单字符的名字也是有用的，常见的如 i,j,k,m,n,x,y,z 等，它们通常可用作函数内的局部变量。<br>    Windows应用程序的标识符通常采用“大小写”混排的方式，如 AddChild。而Unix应用程序的标识符通常采用“小写加下划线”的方式，如 add_child。<br>    全局函数的名字应当使用“动词”或者“动词＋名词” （动宾词组） 。类的成员函数应当只使用“动词” ，被省略掉的名词就是对象本身。<br>    简单的 Windows 应用程序命名规则<br>        作者对“匈牙利”命名规则做了合理的简化，下述的命名规则简单易用，比较适合于 Windows 应用软件的开发。<br>         【规则 3-2-1】类名和函数名用大写字母开头的单词组合而成。<br>        例如：<br>         class Node;     //  类名<br>         class LeafNode;    //  类名<br>         void  Draw(void);   //  函数名<br>         void  SetValue(int value); //  函数名 </p><pre><code> 【规则 3-2-2】变量和参数用小写字母开头的单词组合而成。 例如：  BOOL flag;  int  drawMode;  【规则 3-2-3】常量全用大写的字母，用下划线分割单词。 例如：  const int MAX = 100;  const int MAX_LENGTH = 100;  【规则 3-2-4】静态变量加前缀 s_（表示 static） 。 例如： void Init(…) {  static int s_initValue; //  静态变量  … }  【规则 3-2-5】如果不得已需要全局变量，则使全局变量加前缀 g_（表示 global） 。 例如： int g_howManyPeople; //  全局变量 int g_howMuchMoney; //  全局变量  【规则 3-2-6】类的数据成员加前缀 m_（表示 member） ，这样可以避免数据成员与成员函数的参数同名。 例如：  void Object::SetValue(int width, int height)  {   m_width = width; m_height = height; } 【规则 3-2-7】为了防止某一软件库中的一些标识符和其它软件库中的冲突，可以为各种标识符加上能反映软件性质的前缀。例如三维图形标准 OpenGL 的所有库函数均以 gl 开头，所有常量（或宏定义）均以 GL 开头</code></pre><p>比较:<br>    不可将布尔变量直接与 TRUE、FALSE 或者 1、0 进行比较。<br>    不可将浮点变量用“==”或“！=”与任何数字比较.<br>    应当将整型变量用“==”或“！=”直接与 0 比较。<br>常量:<br>    有时我们希望某些常量只在类中有效。const 数据成员的确是存在的，但其含义却不是我们所期望的。const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。   不能在类声明中初始化 const 数据成员。const 数据成员的初始化只能在类构造函数的初始化表中进行.<br>    如果输入参数以值传递的方式传递对象，则宜改用“const &amp;”方式来传递，这样可以省去临时对象的构造和析构过程，从而提高效率。</p><pre><code>sizeof(a)的值是 12（注意别忘了’\0’） 。指针 p 指向 a，但是 sizeof(p)的值却是 4。这是因为 sizeof(p)得到的是一个指针变量的字节数， 相当于 sizeof(char*)， 而不是 p 所指的内存容量。 C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。示例7-3-3（b）中，不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。在用 delete 释放对象数组时，留意不要丢了符号‘[]’ 。例如      delete []objects; //  正确的用法     delete objects; //  错误的用法     后者相当于 delete objects[0]，漏掉了另外 99 个对象。由于编译后的名字不同，C++程序不能直接调用 C 函数。C++提供了一个 C 连接交换指定符号 extern“C”来解决这个问题。    例如：     extern “C”     {        void foo(int x, int y);        … //  其它函数     }     或者写成     extern “C”     {        #include “myheader.h”        … //  其它 C 头文件     }     这就告诉 C++编译译器，函数 foo 是个 C 连接，应该到库中找名字_foo 而不是找_foo_int_int。C++编译器开发商已经对 C 标准库的头文件作了 extern“C”处理，所以我们可以用＃include直接引用这些头文件。 如果函数有多个参数，参数只能从后向前挨个儿缺省，否则将导致函数调用语句怪模怪样。不合理地使用参数的缺省值将导致重载函数 output 产生二义性。用内联取代宏代码inline 是一种“用于实现的关键字” ，而不是一种“用于声明的关键字” 。一般地，用户可以阅读函数的声明，但是看不到函数的定义。对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型） 。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样） 。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。定义在类声明之中的成员函数将自动地成为内联函数;将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格;将类成员函数放在声明体外定义,然后再加上inline关键字.内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：     （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。     （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联.初始化列表的效率比在构造函数体内赋值要高效先看一下对象创建,对象的创建分两步：1. 数据成员初始化。2. 执行被调用构造函数体内的动作。当类中存在非基本类型成员变量时,会在第一步时首先调用其各个非基本类型成员的构造函数.然后再调用当前类自身的构造函数,此时倘若构造函数中还有赋值操作则需要再次执行一边赋值函数.而使用了初始化列表则不同结果,非基本类型成员仅会在第一步中直接调用其成员类型的带参构造函数即可.前置增减效率高后置增减操作会隐含产生临时变量，因为它要保存操作前的值所为这条语句的值。如果是对基础类型进行后置增减，在不需要使用操作前的值时，生成临时变量的动作会被编译器优化掉。不过对于已经重载过的后置操作这种优化编译器很难做到，特别常见的就是使用标准库时的迭代器自加操作，应该尽量使用前置增减。字符串判空字符串判空的一种高效方式，不用strlen来扫描内存可以提高效率char * s;if (!s || !(*s)){    return false;}GNU-C自带的STL里的std::string是没有引用计数机制的，赋值操作就是重新分配内存，然后从源内存块复制。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://www.winterfell30.com/tags/C/"/>
    
  </entry>
  
</feed>
